<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"cyyzero.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="右值引用，移动语义和完美转发 *移动语义(Move semantics)*往往可以用来替代copy操作，减小开销。而且还要某些对象(比如std::unique_ptr, std::futrue, std::thread)只允许move，禁止copy。可是在某些情况下，它的开销并不一定比copy小。  *完美转发(Perfect forwarding)*可以让模板接受参数，然后转发给其它函数，保持参">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective Modern C++读书笔记(三)">
<meta property="og:url" content="http://cyyzero.github.io/2018/03/01/C++/effective_modern_cpp_3/index.html">
<meta property="og:site_name" content="Eden">
<meta property="og:description" content="右值引用，移动语义和完美转发 *移动语义(Move semantics)*往往可以用来替代copy操作，减小开销。而且还要某些对象(比如std::unique_ptr, std::futrue, std::thread)只允许move，禁止copy。可是在某些情况下，它的开销并不一定比copy小。  *完美转发(Perfect forwarding)*可以让模板接受参数，然后转发给其它函数，保持参">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2018-03-01T13:15:31.000Z">
<meta property="article:modified_time" content="2023-10-29T07:13:44.879Z">
<meta property="article:author" content="Yiyang Chen">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://cyyzero.github.io/2018/03/01/C++/effective_modern_cpp_3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://cyyzero.github.io/2018/03/01/C++/effective_modern_cpp_3/","path":"2018/03/01/C++/effective_modern_cpp_3/","title":"Effective Modern C++读书笔记(三)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Effective Modern C++读书笔记(三) | Eden</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Eden" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Eden</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-number">1.</span> <span class="nav-text">右值引用，移动语义和完美转发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-23"><span class="nav-number">1.1.</span> <span class="nav-text">Item 23</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#std-move"><span class="nav-number">1.1.1.</span> <span class="nav-text">std::move</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-forward"><span class="nav-number">1.1.2.</span> <span class="nav-text">std::forward</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-24"><span class="nav-number">1.2.</span> <span class="nav-text">Item 24</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-25"><span class="nav-number">1.3.</span> <span class="nav-text">Item 25</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-26"><span class="nav-number">1.4.</span> <span class="nav-text">Item 26</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-27"><span class="nav-number">1.5.</span> <span class="nav-text">Item 27</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-28"><span class="nav-number">1.6.</span> <span class="nav-text">Item 28</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-29"><span class="nav-number">1.7.</span> <span class="nav-text">Item 29</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-30"><span class="nav-number">1.8.</span> <span class="nav-text">Item 30</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yiyang Chen"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Yiyang Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cyyzero" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cyyzero" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cyyzero@qq.com" title="E-Mail → mailto:cyyzero@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/9748477/cyyzero" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;9748477&#x2F;cyyzero" rel="noopener me" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2018/03/01/C++/effective_modern_cpp_3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Effective Modern C++读书笔记(三) | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Effective Modern C++读书笔记(三)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-03-01 13:15:31" itemprop="dateCreated datePublished" datetime="2018-03-01T13:15:31+00:00">2018-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="右值引用，移动语义和完美转发"><a href="#右值引用，移动语义和完美转发" class="headerlink" title="右值引用，移动语义和完美转发"></a>右值引用，移动语义和完美转发</h1><ul>
<li><p>*移动语义(Move semantics)*往往可以用来替代copy操作，减小开销。而且还要某些对象(比如<code>std::unique_ptr</code>, <code>std::futrue</code>, <code>std::thread</code>)只允许move，禁止copy。可是在某些情况下，它的开销并不一定比copy小。</p>
</li>
<li><p>*完美转发(Perfect forwarding)*可以让模板接受参数，然后转发给其它函数，保持参数的类型不变。在某些时候，它也并不是完美的。</p>
</li>
</ul>
<p>而*右值引用(Rvalue reference)*就是使上述两个看似不相干的特性连接起来的胶水。它是支撑着移动语义和完美转的潜在语言机制。</p>
<hr>
<h2 id="Item-23"><a href="#Item-23" class="headerlink" title="Item 23"></a>Item 23</h2><p><code>std::move</code>不移动任何东西。<code>std::forward</code>不转发任何东西。在运行期间，不产生可执行的代码，不产升任何字节。它们只是是执行类型转换的函数模板(function templates)。</p>
<h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><ul>
<li><p><code>std::mvoe</code>无条件地将它的参数转化成右值。可以看下一个接近标准库的简单实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  并且在c–14中，,<code>std::move</code>还能实现得更精炼：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  由于<code>std::move</code>只做了将参数转化成右值的工作，甚至有人建议将它的名字改成<code>ralue_cast</code>。当然，右值是可移动的，所以将<code>std::move</code>用于一个对象，可以告诉编译器这个对象是可被移动的。可能这就是命名为<code>std::move</code>的原因。</p>
</li>
<li><p><code>std::mvoe</code>并不一定真正能引发移动操作。举个例子：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="type">const</span> std::string text)</span></span></span><br><span class="line"><span class="function">    : value(std::move(text)) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  你可能预想<code>value(std::move(text))</code>讲引发<code>std::string</code>的移动构造函数。但是，这里却发生了copy。原因在于<code>text</code>是个const对象。<code>std::move</code>作用于const对象时，返回值是个const限定的右值。而std::string构造函数的签名却大概是如下这样的：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;                          <span class="comment">// typedef for std::basic_string&lt;char&gt;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::<span class="built_in">string</span>(<span class="type">const</span> string&amp; rhs);     <span class="comment">// copy ctor</span></span><br><span class="line">    std::<span class="built_in">string</span>(string&amp;&amp; rhs);          <span class="comment">// move ctor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...Other code</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  <code>const std::string</code>的右值不能传给<code>rvalue reference to a non-const std::string</code>(即不会调用移动构造函数)，却可以传给<code>lvalue-reference-to-const</code>(即会调用拷贝构造函数)。因为移动一个对象会改变它的某些值，所以c–不允许<code>const</code>对象传给可能会改变它们值的函数。</p>
<p>  所以，有两个教训：</p>
<ul>
<li>如果你想要移动某个对象，不要将它声明为const。否则实际将会引发copy操作。</li>
<li><code>std::move</code>不移动任何东西。它只是保证它转化的对象将会有资格被移动，即被转化成右值。</li>
</ul>
</li>
</ul>
<h3 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h3><ul>
<li><p><code>std::forward</code>的转化只在某些特定情况下工作。它最常用的场景是在<code>universal reference</code>作为参数的函数模板(function template)中，用于将参数传给另一个函数。比如说：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> Widget&amp; lvalArg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; rvalArg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndProcess</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(<span class="string">&quot;Calling &#x27;process&#x27;&quot;</span>, now);</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget W;</span><br><span class="line"><span class="built_in">logAndProcess</span>(w);               <span class="comment">// (1) call with lvalue</span></span><br><span class="line"><span class="built_in">logAndProcess</span>(std::<span class="built_in">move</span>(w));    <span class="comment">// (2) call with rvalue</span></span><br></pre></td></tr></table></figure>

<p>  试想一下，如果没有<code>std::forward</code>会如何。param会被推断成左值或者右值的引用(详情见第一章)。但是，无论如何，param本身都是一个左值，所以调用process的参数匹配的时候，都会调用参数是lvalue reference的重载版本。<em>我们需要一个机制，只有当传给<code>param</code>的对象是右值的时候，将<code>param</code>从rvalue reference(是左值)转换右值。</em>事实上，这就是上述提到的希望<code>std::forward</code>工作的特定情况。</p>
<p>  BTW，你可能会奇怪<code>std::forward</code>如何区分传给它的对象被初始化之前的类型。秘密就藏在模板参数T里面。后面Item 28会详细讲。</p>
<p>  事实上，某些时候，我们可以用<code>std::forward</code>来代替<code>std::move</code>：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs)</span><br><span class="line">    : <span class="built_in">s</span>(std::<span class="built_in">move</span>(rhs.s)) &#123; &#125;</span><br><span class="line"><span class="comment">// 等价于下面这么写</span></span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs)</span><br><span class="line">    : <span class="built_in">s</span>(std::forward&lt;std::string&gt;(rhs)) &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  注意到<code>std::forward</code>的模板参数是<code>std::string</code>,这可以让它的返回值是右值。但是这么写很不方便。所以还是用<code>std::move</code>来得好。</p>
</li>
</ul>
<hr>
<h2 id="Item-24"><a href="#Item-24" class="headerlink" title="Item 24"></a>Item 24</h2><ul>
<li><p><code>univsersialcv reference</code>可以绑定到任意类型，const或volatile限定的rvalue或lvalue。通常有两个运用的地方，并且都伴随着类型推断：</p>
<ul>
<li><p>模板中：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;          <span class="comment">// param is a universal reference</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>auto 表达式</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = val1;         <span class="comment">// var2 is a universal reference</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如果加了const，就会绑定到rvalue reference</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;           <span class="comment">// param is a rvalue reference</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在模板里看到<code>T&amp;&amp;</code>就以为是<code>universal reference</code>。比如在vector中：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);                 <span class="comment">// x is a reference to rvalue</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span>;     <span class="comment">// args are universial references</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++14的lambda表达式可以声明 <code>auto&amp;&amp;</code> 参数：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> timeFuncInvocation = </span><br><span class="line">    [](<span class="keyword">auto</span>&amp;&amp; func, <span class="keyword">auto</span>&amp;&amp;... params)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//start timer;</span></span><br><span class="line">        std::forward&lt;<span class="keyword">decltype</span>(func)&gt;(func)(</span><br><span class="line">            std::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params)...</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">//stop timer and record elapased time</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>universal reference</code>只是一层抽象，背后的原理是 <code>reference collapsing</code>(引用折叠)。</p>
</li>
</ul>
<hr>
<h2 id="Item-25"><a href="#Item-25" class="headerlink" title="Item 25"></a>Item 25</h2><ul>
<li><p>合理运用<code>universal reference</code>可以有许多好处。考虑下以下两端代码：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With universial reference</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name = std::forward&lt;T&gt;(newName);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ... Other codes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// With two override functions</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(std::string&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> = newName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ... Other codes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  前者就比后者好一些。首先，后者增加了源代码的编写以及要维护的代码量。其次，它可能更加低效。比如说：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.<span class="built_in">setname</span>(<span class="string">&quot;cyyzero&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  使用<code>universal reference</code>版本，那么它被转发给<code>std::string</code>,并且只调用 <code>std::string</code> 的一次赋值函数。而对于两个重载版本的<code>setName</code>，将会创建一个临时的<code>std::string</code>对象，然后临时对象移动，最后析构。Last but not least，对于后者不仅源代码体积膨胀和执行期的效率低下，而且它是一种可拓展性很差的设计。可能需要重载的数量会很多。</p>
</li>
<li><p>在某些情况下，你想要用绑定到 <em>rvalue reference</em> 或者 <em>universal reference</em> 的值多次，那么在最后一次才用<code>std::move</code>或者<code>std::forward</code>.</p>
</li>
<li><p>RVO， 即<code>return value optimization</code>，是指编译器对于返回值需要copy 的情况进行了优化，让copy避免。通常<em>当local对象和返回值类型相同，并且这个local对象被返回</em>，则会进行RVO优化。如果不符合消除拷贝的条件，返回值会被视为右值。所以对于<code>return std::move(ret);</code>这样试图对返回局部变量进行优化的情况，属于画蛇添足。它不会帮到编译器，还可能阻碍了优化(因为所返回对象的类型变成了rvalue reference)。</p>
</li>
<li><p>对于返回值是传值，但返回的对象是左值或者右值引用的情况，那么把 <code>std::move</code> 用在右值引用上， <code>std::forward</code> 用在 <em>universal reference</em> 上。</p>
</li>
</ul>
<hr>
<h2 id="Item-26"><a href="#Item-26" class="headerlink" title="Item 26"></a>Item 26</h2><ul>
<li><p>对参数是 <em>universal reference</em> 的模板函数的重载，将会导致几乎都只调用参数是 <em>universal reference</em> 的版本。</p>
</li>
<li><p>完美转发的构造函数一般会导致很多问题，因为对于参数是<code>non-const lvalue</code>的拷贝构造，和它的继承类调用它的拷贝或移动构造函数的时候，都会调用它。</p>
</li>
<li><p>总而言之，尽量别对参数是<em>universal reference</em>的函数重载。</p>
</li>
</ul>
<hr>
<h2 id="Item-27"><a href="#Item-27" class="headerlink" title="Item 27"></a>Item 27</h2><p>对于上述的问题，有一些办法可以解决。</p>
<ul>
<li><p>放弃重载。定义多个不同的函数。</p>
</li>
<li><p>通过<code>const T&amp;</code>传参数。缺陷就在于效率可能会降低（因为不能move）。但是有时候选择放弃效率带来代码的简单，不失为一种方案。</p>
</li>
<li><p>传值。这可能是反直觉的，因为传值意味着拷贝对象，很多时候都会带来很大的开销。但是知道需要拷贝的时候，就可以考虑传值，然后再将副本move。</p>
</li>
<li><p>用<em>Tag dispath</em>（标签分派）。函数A参数设置为<em>universal reference</em>，然后通过对参数类型的分类，分派给其他函数。举个例子：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; names;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">nameFromIdx</span><span class="params">(<span class="type">int</span> idx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(<span class="type">int</span> idx, std::true_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logAndAdd</span>(<span class="built_in">nameFromIdx</span>(idx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(T&amp;&amp; name, std::false_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrno::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logAndAddImpl</span>(</span><br><span class="line">        std::forward&lt;T&gt;(name), </span><br><span class="line">        std::is_integral&lt;<span class="keyword">typename</span> std::remove_referene&lt;T&gt;::type&gt;()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>约束接收universal reference作为参数的模板。这是后需要用到<code>std::enable_if</code>。它的工作原理基于SFINAE。配合type traits，可以出色地完成工作：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span></span><br><span class="line">    &lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if</span><br><span class="line">        &lt;</span><br><span class="line">            !std::is_base_of</span><br><span class="line">            &lt;</span><br><span class="line">                Person,</span><br><span class="line">                <span class="keyword">typename</span> std::decay&lt;T&gt;::type</span><br><span class="line">            &gt;::type</span><br><span class="line">            &amp;&amp;</span><br><span class="line">            !std::is_integeral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;::value</span><br><span class="line">        &gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="built_in">Person</span>(T&amp;&amp; t)</span><br><span class="line">        :<span class="built_in">name</span>(std::forward&lt;T&gt;(t)) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> Idx)</span><br><span class="line">        :<span class="built_in">name</span>(<span class="built_in">nameFromIdx</span>(Idx)) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  不太好理解的地方：<code>std::enable_if</code>,<code>std::is_base_of</code>,<code>std::decay</code>,<code>std::is_integeral</code>.</p>
</li>
<li><p>权衡。使用universal reference通常能减小开销，但是随之而来的也有许多劣势。一来有些参数不能玩么转发。二来有时候完美转发后的出错信息可读性差。比如说上面的例子，传给Person的参数不能构造<code>std::string</code>，此时的报错将很感人。所以最好用<code>static_assert</code>确定它时候符合要求。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span></span><br><span class="line">    &lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if</span><br><span class="line">        &lt;</span><br><span class="line">            !std::is_base_of</span><br><span class="line">            &lt;</span><br><span class="line">                Person,</span><br><span class="line">                <span class="keyword">typename</span> std::decay&lt;T&gt;::type</span><br><span class="line">            &gt;::type</span><br><span class="line">            &amp;&amp;</span><br><span class="line">            !std::is_integeral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;::value</span><br><span class="line">        &gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="built_in">Person</span>(T&amp;&amp; t)</span><br><span class="line">        :<span class="built_in">name</span>(std::forward&lt;T&gt;(t))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">static_assert</span></span><br><span class="line">            (</span><br><span class="line">                std::is_constructible&lt;std::string, T&gt;::value,</span><br><span class="line">                <span class="string">&quot;Parameter n can;t be usedd to construct a std::string&quot;</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="Item-28"><a href="#Item-28" class="headerlink" title="Item 28"></a>Item 28</h2><p>C++禁止声明引用的引用。但是编译器可能在特定上下文，以及模板实例化的时候遇到它们。这时候，引用折叠(<em>reference collapsing</em>)就派上用场了。引用折叠大概的规则就是：<em>如果有一个是左值引用，结果就是左值引用。否则(即都是右值引用)，结果为右值引用</em>。</p>
<ul>
<li>T&amp;&amp; &amp;&amp; &#x3D;&gt; T&amp;&amp;</li>
<li>T&amp;&amp; &amp;  &#x3D;&gt; T&amp;</li>
<li>T&amp; &amp;&amp;  &#x3D;&gt; T&amp;</li>
<li>T&amp; &amp;   &#x3D;&gt; T&amp;</li>
</ul>
<p>引用折叠主要在四种情况中出现：</p>
<ul>
<li><p>模板实例化。其实主要就是参数是<em>universal reference</em>的函数模板实例化的时候。<em>universal reference</em>配上<code>std::forward</code>，主要就是引用折叠的规则才使得完美转发成为可能。比如说有个完美转发的例子：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//std::forward的简单实现</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_refrence&lt;T&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">someFunc</span>(forward&lt;T&gt;(fParam));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回Widget对象的工厂函数</span></span><br><span class="line"><span class="function">Widget <span class="title">getWidget</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="built_in">f</span>(w);                <span class="comment">// 情况(1)</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="built_in">getWidget</span>());      <span class="comment">// 情况(2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  对于情况(1)，f函数和forward函数会被推断成这样：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp; &amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">someFunc</span>(forward&lt;Widget&amp;&gt;(fParam));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget&amp; &amp;&amp; <span class="title">forward</span><span class="params">(Widget &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  正是由于引用折叠的存在，它事实上是这样的：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">someFunc</span>(forward&lt;Widget&amp;&gt;(fParam));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget&amp; <span class="title">forward</span><span class="params">(Widget &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <em>函数返回左值引用，返回值是个左值</em>。所以 forward 返回值是 Widget 左值。于是完美转发成功。</p>
<p>  对于情况(2)， f 函数和 forward 函数会被推断成这样：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">someFunc</span>(forward&lt;Widget&gt;(fParam));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  *函数返回右值引用，返回值是 xvalue (一种右值)*。所以forward的返回值是 Widget 右值。完美转发也成功了。</p>
<p>  ps：一开始我对于在f函数体内somefunc函数匹配规则不太理解，不太理解引用作为参数模板怎么推断。后来查了下，<em>从函数调用推导模板参数 P 的时候，若 P 是引用类型，则用 P 所引用的类型推导</em>。那么一切问题都迎刃而解了。</p>
</li>
<li><p>auto类型推导的时候。这个也不难想到，因为 auto 推导规则和模板类型推导差不多(见 Item 3)。还是来看一些例子：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; wi = w;</span><br><span class="line"><span class="comment">// 等价于 Widget&amp; &amp;&amp; w1 = w;   =&gt;     Widget &amp;w1 = w;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; w2 = <span class="built_in">getWidget</span>();</span><br><span class="line"><span class="comment">// 等价于 Widget&amp;&amp; w2 = getWidget();</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><em>typedef</em> 和 <em>alias declarations</em>。在模板中声明等价类型的时候，也经常运用引用折叠。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;&amp; RvalueRefToT;     <span class="comment">// RvalueRefToT类型可能和预期的右值引用不太一样，由于T类型未知，如果发生引种折叠，它还可能是左值引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>decltype</em>。当使用<em>decltype</em>配合引用的时候，也可可能发生引用折叠。</p>
</li>
</ul>
<p>最后总结:<code>universal reference</code>能工作就是依靠两点，一是类型推导能区分左值和右值，二是引用折叠的作用。</p>
<hr>
<h2 id="Item-29"><a href="#Item-29" class="headerlink" title="Item 29"></a>Item 29</h2><ul>
<li><p>有时候，移动不一定比拷贝快。举个例子：</p>
<ul>
<li><code>std::array</code>。<code>std::array</code> 的数据不会存放在堆上，基本就是内置数组类型的简单封装。所以移动也是O(n)复杂度。</li>
<li>很多 <code>std::string</code> 的实现都采用了 *small string optimization(SSO)*。比较短的字符串可能不会在存在堆上。这样移动的话效率也不会比拷贝高。</li>
</ul>
</li>
<li><p>有些时候，为了保证老代码在C++98下的强异常安全，如果有移动操作但移动操作没有声明 <code>noexcept</code>，编译器也会选择采用拷贝操作。</p>
</li>
</ul>
<hr>
<h2 id="Item-30"><a href="#Item-30" class="headerlink" title="Item 30"></a>Item 30</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(T&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;T&gt;(params)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很简答的完美转发的例子。但是实际上，它有时候并非如“完美”。在以下情况中完美转发会失败：</p>
<ul>
<li>编译器无法推断类型。</li>
<li>推断的类型并非预期。这可能会造成编译失败，或者匹配重载函数的其他版本。</li>
</ul>
<p>当参数比较特殊的收就很容易出错。举一些例子：</p>
<ul>
<li><p><em>Branced initializers</em> 。假设 <em>f</em> 声明为如下：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);             <span class="comment">// Ok, 列表隐式转化为向量</span></span><br><span class="line"><span class="built_in">fwd</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);           <span class="comment">// 编译失败</span></span><br></pre></td></tr></table></figure>

<p>  这是因为如果直接调用 <em>f</em> ，编译器将会对实参和形参类型匹配，但必要的时候会进行隐式转化。而通过 <em>fwd</em> 调用的时候，标准规定不能推断表达式 <code>&#123;1,2,3&#125;</code> 的类型(<code>std::initializer_list</code> 是 “<em>non-deduced context</em>”)。只有fwd的参数被声明为 <code>std::initializer_list</code>的时候，才可以这么传参数。而 <code>auto</code> 就不受这个限制了，可以这么写：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> il = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">fwd</span>(il);              <span class="comment">// It works.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>0 或者 <em>NULL</em>。很可能会被腿短成int类型，而非空指针。所以用 <code>nullptr</code> 代替它们。</p>
</li>
<li><p>只有声明的 static const 成员变量。建议写上定义(不要重复初始化)。否则可能会在参数是引用的函数传参时链接失败。</p>
</li>
<li><p>重载函数的名字或者模板的名字。这通常对于 <em>f</em> 参数是函数指针的时候，给 <em>f</em> 传重载函数的函数名，编译器会选择签名相同函数传指针过去。而对于 <em>fwd</em> ，来说，如果给它的参数是重载函数或者模板的名字，就无法推断，编译出错。解决的办法就是先定义一个函数指针，然后再作为参数传递给 <em>fwd</em> 。</p>
</li>
<li><p>位域(<em>Bitfields</em>)。因为位域的成员是无法引用的，所以将它作为参数传递给 <em>fwd</em> 就会出问题。(原因在于位域的成员可能是任意的bit，比如说一个32位int类型的第3到第5个bit，这就无法寻址)。</p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/02/12/C++/effective_modern_cpp_2/" rel="prev" title="Effective Modern C++读书笔记(二)">
                  <i class="fa fa-angle-left"></i> Effective Modern C++读书笔记(二)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/04/20/C++/effective_modern_cpp_4/" rel="next" title="Effective Modern C++读书笔记(四)">
                  Effective Modern C++读书笔记(四) <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yiyang Chen</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/cyyzero" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"cyyzero","repo":"cyyzero.github.io","client_id":"1185801249b8bbce5127","client_secret":"fbbb24c3e0613419f2505f94baa921f61606bac1","admin_user":"cyyzero","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"cdbd1f660c0eff7ad084418ca6a21616"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
