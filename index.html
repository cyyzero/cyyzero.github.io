<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"cyyzero.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Eden">
<meta property="og:url" content="http://cyyzero.github.io/index.html">
<meta property="og:site_name" content="Eden">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yiyang Chen">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://cyyzero.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Eden</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Eden" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Eden</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yiyang Chen"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Yiyang Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cyyzero" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cyyzero" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cyyzero@qq.com" title="E-Mail → mailto:cyyzero@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/9748477/cyyzero" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;9748477&#x2F;cyyzero" rel="noopener me" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2023/10/29/Linux/overlayfs_volatile_option/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/29/Linux/overlayfs_volatile_option/" class="post-title-link" itemprop="url">overlayfs挂载选项volatile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-10-29 15:19:23 / Modified: 08:06:58" itemprop="dateCreated datePublished" datetime="2023-10-29T15:19:23+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>最近在公司遇到了容器相关的线上问题, 简单来说就是K8s会出现PLEG not healthy的报错. 经过初步的排查, 发现是docker有个goroutine卡在了<code>umount</code>, 同时这个这个groutine会占用某个锁, 导致查询状态的handler里拿不到锁, 最终导致k8s层面的报错.</p>
<p>通过对umount事件的监控, 以及相关源码代码的阅读, 发现是overlayfs在umount的时候, 会对upper层所在的fs进行一次sync, 导致大量脏页回写. 如果这个机器内存较大, 并且有过频繁的IO, 那么就会脏页较多, overlayfs umount时等待磁盘IO完成而阻塞过久.</p>
<p>umount的stack trace如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[&lt;0&gt;] wb_wait_for_completion+0x5a/0x90</span><br><span class="line">[&lt;0&gt;] __writeback_inodes_sb_nr+0xa0/0xd0</span><br><span class="line">[&lt;0&gt;] writeback_inodes_sb+0x3d/0x50</span><br><span class="line">[&lt;0&gt;] _sync_filesystem+0x55/0x60</span><br><span class="line">[&lt;0&gt;] sync_filesystem+0x33/0x50</span><br><span class="line">[&lt;0&gt;] ovl_sync_fs+0x61/0xa0 [overlay]</span><br><span class="line">[&lt;0&gt;] _sync_filesystem+0x33/0x60</span><br><span class="line">[&lt;0&gt;] sync_filesystem+0x44/0x50</span><br><span class="line">[&lt;0&gt;] generic_shutdown_super+0x27/0x120</span><br><span class="line">[&lt;0&gt;] kill_anon_super+0x18/0x30</span><br><span class="line">[&lt;0&gt;] deactivate_locked_super+0x3b/0x90</span><br><span class="line">[&lt;0&gt;] deactivate_super+0x42/0x50</span><br><span class="line">[&lt;0&gt;] cleanup_mnt+0x109/0x170</span><br><span class="line">[&lt;0&gt;] _cleanup_mnt+0x12/0x20</span><br><span class="line">[&lt;0&gt;] task_work_run+0x70/0xb0</span><br><span class="line">[&lt;0&gt;] exit_to_user_mode_prepare+0x1b6/0x1c0</span><br><span class="line">[&lt;0&gt;] syscall_exit_to_user_mode+0x27/0x50</span><br><span class="line">[&lt;0&gt;] do_syscall_64+0x69/0xc0</span><br><span class="line">[&lt;0&gt;] entry_SYSCALL_64_after_hwframe+0x61/0xcb</span><br></pre></td></tr></table></figure>

<p>重点在这个<code>ovl_sync_fs</code>函数, 它会对整个overlayfs的uppser层所在文件系统进行sync操作: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from kernel 5.10</span></span><br><span class="line"><span class="comment">/* Sync real dirty inodes in upper filesystem (if it exists) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ovl_sync_fs</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="type">int</span> wait)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ovl_fs</span> *<span class="title">ofs</span> =</span> sb-&gt;s_fs_info;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">upper_sb</span>;</span></span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ovl_upper_mnt(ofs))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ovl_should_sync(ofs))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Not called for sync(2) call or an emergency sync (SB_I_SKIP_SYNC).</span></span><br><span class="line"><span class="comment">         * All the super blocks will be iterated, including upper_sb.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If this is a syncfs(2) call, then we do need to call</span></span><br><span class="line"><span class="comment">         * sync_filesystem() on upper_sb, but enough if we do it when being</span></span><br><span class="line"><span class="comment">         * called with wait == 1.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!wait)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到upper层所在的fs</span></span><br><span class="line">        upper_sb = ovl_upper_mnt(ofs)-&gt;mnt_sb;</span><br><span class="line"></span><br><span class="line">        down_read(&amp;upper_sb-&gt;s_umount);</span><br><span class="line">        <span class="comment">// 执行sync, 会造成整个fs脏页回写磁盘, 耗时很长</span></span><br><span class="line">        ret = sync_filesystem(upper_sb);</span><br><span class="line">        up_read(&amp;upper_sb-&gt;s_umount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然, 对于k8s的很多场景来说, sync文件系统是多余的操作. k8s每次实例启动都重新挂载rootfs, 实例退出后将rootfs umount并删除(可能描述的不对). 所以最好有办法能够避免overlayfs umount时候的强制刷盘.</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>如果仔细查看<code>ovl_sync_fs</code>函数, 可以发现它会在函数开头执行两个判断, 一次是判断upper层是否存在, 一次是<code>ovl_should_sync</code>判断overlayfs是否应该进行sync. 解决问题的关键可能就在于ovl_should_sync能否绕过sync.</p>
<h2 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h2><p>ovl_should_sync函数被包含在2020.8.31提的patch里</p>
<p><a target="_blank" rel="noopener" href="https://lore.kernel.org/all/20200722175024.GA608248@redhat.com/">[PATCH v5] overlayfs: Provide a mount option “ volatile” to skip sync - Vivek Goyal</a></p>
<p>这个patch给overlayfs提供了一个新的挂载选项volatile, 当挂载这个选项后, overlayfs会去掉一些sync操作, 包括针对单独文件的sync以及整个文件系统的sync.</p>
<p>影响的地方如下: </p>
<ol>
<li><p>umount不会再强制对upper层文件系统执行sync, 也就是针对本次问题出现的场景.</p>
</li>
<li><p>remount的时候, 也可能对upper层所在文件系统进行sync, 这是2020年加内核主线的patch.<br><a target="_blank" rel="noopener" href="https://www.spinics.net/lists/linux-unionfs/msg07682.html">[PATCH] ovl: sync dirty data when remounting to ro mode ‒ Union Filesystem</a><br>这是因为把overlayfs remount成只读之后, 在umount overlayfs时,<code>kill_anon_super</code> -&gt; <code>generic_shutdown_super</code> -&gt; <code>sync_filesystem</code>检查overlayfs为只读时会跳过sync_filesystem. 所以把overlayfs从可写remount成只读的时候, 直接进行一次sync_filesystem, 避免最终umount的时候遗漏sync_filesystem操作. volatile选项会取消这一次sync_filesystem操作.</p>
</li>
<li><p>针对单个文件fsync调用, 如果带有volatile挂载选项, 会跳过.</p>
</li>
<li><p>当文件copy up到upper层的时候, 也会进行vfs_fsync()操作. 如果带有volatile选项, 会跳过.</p>
</li>
<li><p>O_SYNC的场景, 如果有volatile选项, 也会绕过sync退化成overlayfs默认的写行为.</p>
</li>
</ol>
<p><strong>本质上这些sync操作都是为了避免系统crash造成overlayfs磁盘数据丢失. volatile挂载选项和Kubernetes的使用场景十分契合. 如果内核在向overlayfs写入数据时崩溃, kubelet总是会重新创建新的容器, 而不会复用之前的rootfs. 因此，在 kubernetes中, 容器的rootfs是临时的. 在pod中使用 volatile 选项是安全的, 因为我们没有机会重复使用旧的rootfs. 在有状态容器中使用这种配置也是安全的, 因为需要持久化的数据理应写入外部卷, 在运行时不会受到volatile标志的影响.</strong></p>
<h2 id="contianerd"><a href="#contianerd" class="headerlink" title="contianerd"></a>contianerd</h2><p>当然, 新的挂载选项需要runtime的支持, 才能够在挂载rootfs带上这个选项.</p>
<p>在contaienrd社区已经有了许多相关讨论:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/issues/8698">https://github.com/containerd/containerd/issues/8698</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/issues/6406">https://github.com/containerd/containerd/issues/6406</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/pull/4785">https://github.com/containerd/containerd/pull/4785</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/pull/8402">https://github.com/containerd/containerd/pull/8402</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/pull/8676">https://github.com/containerd/containerd/pull/8676</a></li>
</ul>
<p>这个pr <a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/pull/8676">[overlay] add configurable mount options to overlay snapshotter by dmcgowan · Pull Request #8676</a> 允许对overlayfs的挂载选项进行设置, 并且被backport到了1.6.24.</p>
<h2 id="requirements"><a href="#requirements" class="headerlink" title="requirements"></a>requirements</h2><p>总结一下, overlayfs volatile特性, 需要的版本如下:</p>
<ul>
<li>Linux kernel &gt;&#x3D; 5.10<br>对应patch: <a target="_blank" rel="noopener" href="https://lore.kernel.org/all/20200722175024.GA608248@redhat.com/">[PATCH] ovl: sync dirty data when remounting to ro mode ‒ Union Filesystem</a></li>
<li>containerd &gt;&#x3D; 1.6.24 or containerd &gt;&#x3D; 1.7.4<br>对应PR: <a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/pull/8676">[overlay] add configurable mount options to overlay snapshotter by dmcgowan · Pull Request #8676</a></li>
</ul>
<p>containerd配置:</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/containerd/config.toml</span></span><br><span class="line"><span class="attr">version</span> = <span class="number">2</span></span><br><span class="line"><span class="section">[plugins]</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.snapshotter.v1.overlayfs&quot;]</span></span><br><span class="line">    <span class="attr">mount_options</span> = [<span class="string">&quot;volatile&quot;</span>]</span><br></pre></td></tr></table></figure>

<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ol>
<li><a target="_blank" rel="noopener" href="https://lore.kernel.org/all/20200722175024.GA608248@redhat.com/">https:&#x2F;&#x2F;lore.kernel.org&#x2F;all&#x2F;20200722175024.GA608248@redhat.com/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/pull/8676">https://github.com/containerd/containerd/pull/8676</a></li>
<li><a target="_blank" rel="noopener" href="https://fuweid.com/post/2023-08-sync-containerd-issue/">https://fuweid.com/post/2023-08-sync-containerd-issue/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.redhat.com/sysadmin/container-volatile-overlay-mounts">https://www.redhat.com/sysadmin/container-volatile-overlay-mounts</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.kernel.org/filesystems/overlayfs.html#volatile-mount">https://docs.kernel.org/filesystems/overlayfs.html#volatile-mount</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2023/07/29/Linux/Ext4_mount_default_opts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/29/Linux/Ext4_mount_default_opts/" class="post-title-link" itemprop="url">ext4文件系统默认挂载选项</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-07-29 17:08:29" itemprop="dateCreated datePublished" datetime="2023-07-29T17:08:29+00:00">2023-07-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/v4.19/filesystems/ext4/ext4.html#options">Ext4的官方文档</a>里，可以看到有很多挂载的选项，并且有一些被标记为了默认，比如<code>delalloc</code>。但是通过<code>procfs</code>的<code>/proc/mounts</code>并没有看到这些默认的选项，比如<code>delalloc</code>（有个<code>nodelalloc</code>的disable delalloc选项，这两个是非此即彼的关系，却都没有出现）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/mounts| grep ext4</span><br><span class="line">/dev/sdb / ext4 rw,relatime,discard,errors=remount-ro,data=ordered 0 0</span><br></pre></td></tr></table></figure>

<p>而对于另一个文件系统相关的文件里，却能够看到这些完整的选项：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/fs/ext4/sdb/options    </span><br><span class="line">rw</span><br><span class="line">bsddf</span><br><span class="line">nogrpid</span><br><span class="line">block_validity</span><br><span class="line">dioread_nolock</span><br><span class="line">discard</span><br><span class="line">delalloc</span><br><span class="line">nowarn_on_error</span><br><span class="line">journal_checksum</span><br><span class="line">barrier</span><br><span class="line">auto_da_alloc</span><br><span class="line">user_xattr</span><br><span class="line">acl</span><br><span class="line">noquota</span><br><span class="line">resuid=0</span><br><span class="line">resgid=0</span><br><span class="line">errors=remount-ro</span><br><span class="line">commit=5</span><br><span class="line">min_batch_time=0</span><br><span class="line">max_batch_time=15000</span><br><span class="line">stripe=0</span><br><span class="line">data=ordered</span><br><span class="line">inode_readahead_blks=32</span><br><span class="line">init_itable=10</span><br><span class="line">max_dir_size_kb=0</span><br></pre></td></tr></table></figure>

<p>带着这个问题，基于6.1.36内核源码，梳理了文件系统如何通过<code>procfs</code>来展示挂载信息，并且在创建和挂载文件系统时如何处理挂载选项。</p>
<h2 id="procfs的数据"><a href="#procfs的数据" class="headerlink" title="procfs的数据"></a>procfs的数据</h2><h3 id="proc-pid-mounts"><a href="#proc-pid-mounts" class="headerlink" title="&#x2F;proc&#x2F;{pid}&#x2F;mounts"></a>&#x2F;proc&#x2F;{pid}&#x2F;mounts</h3><p>由于有了mount namespace，系统挂载点可以在各个进程之间相互隔离，不再是全局一致。所以<code>/proc/mounts</code>其实是指向<code>/proc/self/mounts</code>的符号链接。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /proc/mounts</span><br><span class="line">lrwxrwxrwx 1 root root 11 Jul 30 05:31 /proc/mounts -&gt; self/mounts</span><br></pre></td></tr></table></figure>

<p>展示的函数是<code>show_vfsmnt</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/proc_namespace.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">show_vfsmnt</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_mounts</span> *<span class="title">p</span> =</span> m-&gt;private;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">r</span> =</span> real_mount(mnt);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">mnt_path</span> =</span> &#123; .dentry = mnt-&gt;mnt_root, .mnt = mnt &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> mnt_path.dentry-&gt;d_sb;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sb-&gt;s_op-&gt;show_devname) &#123;</span><br><span class="line">		err = sb-&gt;s_op-&gt;show_devname(m, mnt_path.dentry);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mangle(m, r-&gt;mnt_devname ? r-&gt;mnt_devname : <span class="string">&quot;none&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	seq_putc(m, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	<span class="comment">/* mountpoints outside of chroot jail will give SEQ_SKIP on this */</span></span><br><span class="line">	err = seq_path_root(m, &amp;mnt_path, &amp;p-&gt;root, <span class="string">&quot; \t\n\\&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	seq_putc(m, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	show_type(m, sb);</span><br><span class="line">	seq_puts(m, __mnt_is_readonly(mnt) ? <span class="string">&quot; ro&quot;</span> : <span class="string">&quot; rw&quot;</span>);</span><br><span class="line">	err = show_sb_opts(m, sb);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	show_mnt_opts(m, mnt);</span><br><span class="line">	<span class="keyword">if</span> (sb-&gt;s_op-&gt;show_options)</span><br><span class="line">		err = sb-&gt;s_op-&gt;show_options(m, mnt_path.dentry);</span><br><span class="line">	seq_puts(m, <span class="string">&quot; 0 0\n&quot;</span>);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中主要有三个函数输出了options，<code>show_sb_opts()</code>和<code>show_mnt_opts()</code>，还有<code>sb-&gt;s_op-&gt;show_options</code>，其中<code>show_sb_opts()</code>和<code>show_mnt_opts</code>打印的是vfs层面通用的一些选项，比较少。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/proc_namespace.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">show_sb_opts</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> super_block *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_fs_opts</span> <span class="title">fs_opts</span>[] =</span> &#123;</span><br><span class="line">		&#123; SB_SYNCHRONOUS, <span class="string">&quot;,sync&quot;</span> &#125;,</span><br><span class="line">		&#123; SB_DIRSYNC, <span class="string">&quot;,dirsync&quot;</span> &#125;,</span><br><span class="line">		&#123; SB_MANDLOCK, <span class="string">&quot;,mand&quot;</span> &#125;,</span><br><span class="line">		&#123; SB_LAZYTIME, <span class="string">&quot;,lazytime&quot;</span> &#125;,</span><br><span class="line">		&#123; <span class="number">0</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_fs_opts</span> *<span class="title">fs_infop</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (fs_infop = fs_opts; fs_infop-&gt;flag; fs_infop++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sb-&gt;s_flags &amp; fs_infop-&gt;flag)</span><br><span class="line">			seq_puts(m, fs_infop-&gt;str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> security_sb_show_options(m, sb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_mnt_opts</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_fs_opts</span> <span class="title">mnt_opts</span>[] =</span> &#123;</span><br><span class="line">		&#123; MNT_NOSUID, <span class="string">&quot;,nosuid&quot;</span> &#125;,</span><br><span class="line">		&#123; MNT_NODEV, <span class="string">&quot;,nodev&quot;</span> &#125;,</span><br><span class="line">		&#123; MNT_NOEXEC, <span class="string">&quot;,noexec&quot;</span> &#125;,</span><br><span class="line">		&#123; MNT_NOATIME, <span class="string">&quot;,noatime&quot;</span> &#125;,</span><br><span class="line">		&#123; MNT_NODIRATIME, <span class="string">&quot;,nodiratime&quot;</span> &#125;,</span><br><span class="line">		&#123; MNT_RELATIME, <span class="string">&quot;,relatime&quot;</span> &#125;,</span><br><span class="line">		&#123; MNT_NOSYMFOLLOW, <span class="string">&quot;,nosymfollow&quot;</span> &#125;,</span><br><span class="line">		&#123; <span class="number">0</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_fs_opts</span> *<span class="title">fs_infop</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (fs_infop = mnt_opts; fs_infop-&gt;flag; fs_infop++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mnt-&gt;mnt_flags &amp; fs_infop-&gt;flag)</span><br><span class="line">			seq_puts(m, fs_infop-&gt;str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mnt_user_ns(mnt) != &amp;init_user_ns)</span><br><span class="line">		seq_puts(m, <span class="string">&quot;,idmapped&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>sb-&gt;s_op-&gt;show_options</code>，对于<code>ext4</code>文件系统来说，是<code>_ext4_show_options</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/ext4/super.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">ext4_sops</span> =</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	.show_options	= ext4_show_options,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ext4_show_options</span><span class="params">(<span class="keyword">struct</span> seq_file *seq, <span class="keyword">struct</span> dentry *root)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _ext4_show_options(seq, root-&gt;d_sb, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Show an option if</span></span><br><span class="line"><span class="comment"> *  - it&#x27;s set to a non-default value OR</span></span><br><span class="line"><span class="comment"> *  - if the per-sb default is different from the global default</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _ext4_show_options(<span class="keyword">struct</span> seq_file *seq, <span class="keyword">struct</span> super_block *sb,</span><br><span class="line">			      <span class="type">int</span> nodefs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_sb_info</span> *<span class="title">sbi</span> =</span> EXT4_SB(sb);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_super_block</span> *<span class="title">es</span> =</span> sbi-&gt;s_es;</span><br><span class="line">	<span class="type">int</span> def_errors, def_mount_opt = sbi-&gt;s_def_mount_opt;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mount_opts</span> *<span class="title">m</span>;</span></span><br><span class="line">	<span class="type">char</span> sep = nodefs ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEQ_OPTS_PUTS(str) seq_printf(seq, <span class="string">&quot;%c&quot;</span> str, sep)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEQ_OPTS_PRINT(str, arg) seq_printf(seq, <span class="string">&quot;%c&quot;</span> str, sep, arg)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sbi-&gt;s_sb_block != <span class="number">1</span>)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;sb=%llu&quot;</span>, sbi-&gt;s_sb_block);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (m = ext4_mount_opts; m-&gt;token != Opt_err; m++) &#123;</span><br><span class="line">		<span class="type">int</span> want_set = m-&gt;flags &amp; MOPT_SET;</span><br><span class="line">		<span class="keyword">if</span> (((m-&gt;flags &amp; (MOPT_SET|MOPT_CLEAR)) == <span class="number">0</span>) ||</span><br><span class="line">		    (m-&gt;flags &amp; MOPT_CLEAR_ERR) || m-&gt;flags &amp; MOPT_SKIP)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (!nodefs &amp;&amp; !(m-&gt;mount_opt &amp; (sbi-&gt;s_mount_opt ^ def_mount_opt)))</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">/* skip if same as the default */</span></span><br><span class="line">		<span class="keyword">if</span> ((want_set &amp;&amp;</span><br><span class="line">		     (sbi-&gt;s_mount_opt &amp; m-&gt;mount_opt) != m-&gt;mount_opt) ||</span><br><span class="line">		    (!want_set &amp;&amp; (sbi-&gt;s_mount_opt &amp; m-&gt;mount_opt)))</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">/* select Opt_noFoo vs Opt_Foo */</span></span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;%s&quot;</span>, token2str(m-&gt;token));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nodefs || !uid_eq(sbi-&gt;s_resuid, make_kuid(&amp;init_user_ns, EXT4_DEF_RESUID)) ||</span><br><span class="line">	    le16_to_cpu(es-&gt;s_def_resuid) != EXT4_DEF_RESUID)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;resuid=%u&quot;</span>,</span><br><span class="line">				from_kuid_munged(&amp;init_user_ns, sbi-&gt;s_resuid));</span><br><span class="line">	<span class="keyword">if</span> (nodefs || !gid_eq(sbi-&gt;s_resgid, make_kgid(&amp;init_user_ns, EXT4_DEF_RESGID)) ||</span><br><span class="line">	    le16_to_cpu(es-&gt;s_def_resgid) != EXT4_DEF_RESGID)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;resgid=%u&quot;</span>,</span><br><span class="line">				from_kgid_munged(&amp;init_user_ns, sbi-&gt;s_resgid));</span><br><span class="line">	def_errors = nodefs ? <span class="number">-1</span> : le16_to_cpu(es-&gt;s_errors);</span><br><span class="line">	<span class="keyword">if</span> (test_opt(sb, ERRORS_RO) &amp;&amp; def_errors != EXT4_ERRORS_RO)</span><br><span class="line">		SEQ_OPTS_PUTS(<span class="string">&quot;errors=remount-ro&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (test_opt(sb, ERRORS_CONT) &amp;&amp; def_errors != EXT4_ERRORS_CONTINUE)</span><br><span class="line">		SEQ_OPTS_PUTS(<span class="string">&quot;errors=continue&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (test_opt(sb, ERRORS_PANIC) &amp;&amp; def_errors != EXT4_ERRORS_PANIC)</span><br><span class="line">		SEQ_OPTS_PUTS(<span class="string">&quot;errors=panic&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (nodefs || sbi-&gt;s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;commit=%lu&quot;</span>, sbi-&gt;s_commit_interval / HZ);</span><br><span class="line">	<span class="keyword">if</span> (nodefs || sbi-&gt;s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;min_batch_time=%u&quot;</span>, sbi-&gt;s_min_batch_time);</span><br><span class="line">	<span class="keyword">if</span> (nodefs || sbi-&gt;s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;max_batch_time=%u&quot;</span>, sbi-&gt;s_max_batch_time);</span><br><span class="line">	<span class="keyword">if</span> (sb-&gt;s_flags &amp; SB_I_VERSION)</span><br><span class="line">		SEQ_OPTS_PUTS(<span class="string">&quot;i_version&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (nodefs || sbi-&gt;s_stripe)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;stripe=%lu&quot;</span>, sbi-&gt;s_stripe);</span><br><span class="line">	<span class="keyword">if</span> (nodefs || EXT4_MOUNT_DATA_FLAGS &amp;</span><br><span class="line">			(sbi-&gt;s_mount_opt ^ def_mount_opt)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)</span><br><span class="line">			SEQ_OPTS_PUTS(<span class="string">&quot;data=journal&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)</span><br><span class="line">			SEQ_OPTS_PUTS(<span class="string">&quot;data=ordered&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)</span><br><span class="line">			SEQ_OPTS_PUTS(<span class="string">&quot;data=writeback&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nodefs ||</span><br><span class="line">	    sbi-&gt;s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;inode_readahead_blks=%u&quot;</span>,</span><br><span class="line">			       sbi-&gt;s_inode_readahead_blks);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_opt(sb, INIT_INODE_TABLE) &amp;&amp; (nodefs ||</span><br><span class="line">		       (sbi-&gt;s_li_wait_mult != EXT4_DEF_LI_WAIT_MULT)))</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;init_itable=%u&quot;</span>, sbi-&gt;s_li_wait_mult);</span><br><span class="line">	<span class="keyword">if</span> (nodefs || sbi-&gt;s_max_dir_size_kb)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;max_dir_size_kb=%u&quot;</span>, sbi-&gt;s_max_dir_size_kb);</span><br><span class="line">	<span class="keyword">if</span> (test_opt(sb, DATA_ERR_ABORT))</span><br><span class="line">		SEQ_OPTS_PUTS(<span class="string">&quot;data_err=abort&quot;</span>);</span><br><span class="line"></span><br><span class="line">	fscrypt_show_test_dummy_encryption(seq, sep, sb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sb-&gt;s_flags &amp; SB_INLINECRYPT)</span><br><span class="line">		SEQ_OPTS_PUTS(<span class="string">&quot;inlinecrypt&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_opt(sb, DAX_ALWAYS)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (IS_EXT2_SB(sb))</span><br><span class="line">			SEQ_OPTS_PUTS(<span class="string">&quot;dax&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			SEQ_OPTS_PUTS(<span class="string">&quot;dax=always&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (test_opt2(sb, DAX_NEVER)) &#123;</span><br><span class="line">		SEQ_OPTS_PUTS(<span class="string">&quot;dax=never&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (test_opt2(sb, DAX_INODE)) &#123;</span><br><span class="line">		SEQ_OPTS_PUTS(<span class="string">&quot;dax=inode&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ext4_show_quota_options(seq, sb);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="proc-fs-ext4-device-options"><a href="#proc-fs-ext4-device-options" class="headerlink" title="&#x2F;proc&#x2F;fs&#x2F;ext4&#x2F;{device}&#x2F;options"></a>&#x2F;proc&#x2F;fs&#x2F;ext4&#x2F;{device}&#x2F;options</h3><p>在ext4文件系统被挂载的时候，会在<code>__ext4_fill_super()</code>里调用<code>ext4_register_sysfs()</code>来注册procfs的条目：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/ext4/sysfs.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ext4_register_sysfs</span><span class="params">(<span class="keyword">struct</span> super_block *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> (sbi-&gt;s_proc) &#123;</span><br><span class="line">		proc_create_single_data(<span class="string">&quot;options&quot;</span>, S_IRUGO, sbi-&gt;s_proc,</span><br><span class="line">				ext4_seq_options_show, sb);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>展示数据的函数为<code>ext4_seq_options_show()</code>，最终也是调用了<code>_ext4_show_options()</code>，不过最后一个参数<code>nodefs</code>为1，导致和<code>/proc/&#123;pid&#125;/mounts</code>的输出不一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/ext4/super.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ext4_seq_options_show</span><span class="params">(<span class="keyword">struct</span> seq_file *seq, <span class="type">void</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> seq-&gt;private;</span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">	seq_puts(seq, sb_rdonly(sb) ? <span class="string">&quot;ro&quot;</span> : <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">	rc = _ext4_show_options(seq, sb, <span class="number">1</span>);</span><br><span class="line">	seq_puts(seq, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，导致差异的点有两个，一个是导致sep为’,’还是’\n’；另一个是nodefs为0的情况下，会省略一些选项的输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _ext4_show_options(<span class="keyword">struct</span> seq_file *seq, <span class="keyword">struct</span> super_block *sb,</span><br><span class="line">			      <span class="type">int</span> nodefs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_sb_info</span> *<span class="title">sbi</span> =</span> EXT4_SB(sb);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_super_block</span> *<span class="title">es</span> =</span> sbi-&gt;s_es;</span><br><span class="line">	<span class="type">int</span> def_errors, def_mount_opt = sbi-&gt;s_def_mount_opt;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mount_opts</span> *<span class="title">m</span>;</span></span><br><span class="line">	<span class="type">char</span> sep = nodefs ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sbi-&gt;s_sb_block != <span class="number">1</span>)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;sb=%llu&quot;</span>, sbi-&gt;s_sb_block);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (m = ext4_mount_opts; m-&gt;token != Opt_err; m++) &#123;</span><br><span class="line">		<span class="type">int</span> want_set = m-&gt;flags &amp; MOPT_SET;</span><br><span class="line">		<span class="keyword">if</span> (((m-&gt;flags &amp; (MOPT_SET|MOPT_CLEAR)) == <span class="number">0</span>) ||</span><br><span class="line">		    m-&gt;flags &amp; MOPT_SKIP)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (!nodefs &amp;&amp; !(m-&gt;mount_opt &amp; (sbi-&gt;s_mount_opt ^ def_mount_opt)))</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">/* skip if same as the default */</span></span><br><span class="line">		<span class="keyword">if</span> ((want_set &amp;&amp;</span><br><span class="line">		     (sbi-&gt;s_mount_opt &amp; m-&gt;mount_opt) != m-&gt;mount_opt) ||</span><br><span class="line">		    (!want_set &amp;&amp; (sbi-&gt;s_mount_opt &amp; m-&gt;mount_opt)))</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">/* select Opt_noFoo vs Opt_Foo */</span></span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;%s&quot;</span>, token2str(m-&gt;token));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nodefs || !uid_eq(sbi-&gt;s_resuid, make_kuid(&amp;init_user_ns, EXT4_DEF_RESUID)) ||</span><br><span class="line">	    le16_to_cpu(es-&gt;s_def_resuid) != EXT4_DEF_RESUID)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;resuid=%u&quot;</span>,</span><br><span class="line">				from_kuid_munged(&amp;init_user_ns, sbi-&gt;s_resuid));</span><br><span class="line">	<span class="keyword">if</span> (nodefs || !gid_eq(sbi-&gt;s_resgid, make_kgid(&amp;init_user_ns, EXT4_DEF_RESGID)) ||</span><br><span class="line">	    le16_to_cpu(es-&gt;s_def_resgid) != EXT4_DEF_RESGID)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;resgid=%u&quot;</span>,</span><br><span class="line">				from_kgid_munged(&amp;init_user_ns, sbi-&gt;s_resgid));</span><br><span class="line">	def_errors = nodefs ? <span class="number">-1</span> : le16_to_cpu(es-&gt;s_errors);</span><br><span class="line">	<span class="keyword">if</span> (test_opt(sb, ERRORS_RO) &amp;&amp; def_errors != EXT4_ERRORS_RO)</span><br><span class="line">		SEQ_OPTS_PUTS(<span class="string">&quot;errors=remount-ro&quot;</span>);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> (nodefs || sbi-&gt;s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;commit=%lu&quot;</span>, sbi-&gt;s_commit_interval / HZ);</span><br><span class="line">	<span class="keyword">if</span> (nodefs || sbi-&gt;s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;min_batch_time=%u&quot;</span>, sbi-&gt;s_min_batch_time);</span><br><span class="line">	<span class="keyword">if</span> (nodefs || sbi-&gt;s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;max_batch_time=%u&quot;</span>, sbi-&gt;s_max_batch_time);</span><br><span class="line">	<span class="keyword">if</span> (nodefs || sbi-&gt;s_stripe)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;stripe=%lu&quot;</span>, sbi-&gt;s_stripe);</span><br><span class="line">	<span class="keyword">if</span> (nodefs || EXT4_MOUNT_DATA_FLAGS &amp;</span><br><span class="line">			(sbi-&gt;s_mount_opt ^ def_mount_opt)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)</span><br><span class="line">			SEQ_OPTS_PUTS(<span class="string">&quot;data=journal&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)</span><br><span class="line">			SEQ_OPTS_PUTS(<span class="string">&quot;data=ordered&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)</span><br><span class="line">			SEQ_OPTS_PUTS(<span class="string">&quot;data=writeback&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nodefs ||</span><br><span class="line">	    sbi-&gt;s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;inode_readahead_blks=%u&quot;</span>,</span><br><span class="line">			       sbi-&gt;s_inode_readahead_blks);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_opt(sb, INIT_INODE_TABLE) &amp;&amp; (nodefs ||</span><br><span class="line">		       (sbi-&gt;s_li_wait_mult != EXT4_DEF_LI_WAIT_MULT)))</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;init_itable=%u&quot;</span>, sbi-&gt;s_li_wait_mult);</span><br><span class="line">	<span class="keyword">if</span> (nodefs || sbi-&gt;s_max_dir_size_kb)</span><br><span class="line">		SEQ_OPTS_PRINT(<span class="string">&quot;max_dir_size_kb=%u&quot;</span>, sbi-&gt;s_max_dir_size_kb);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看来起来主要就是nodefs为1和0的两种情况导致输出不一致。可以看到这段逻辑，如果是default的options，并且nodefs为0，就跳过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!nodefs &amp;&amp; !(m-&gt;mount_opt &amp; (sbi-&gt;s_mount_opt ^ def_mount_opt)))</span><br><span class="line">	<span class="keyword">continue</span>; <span class="comment">/* skip if same as the default */</span></span><br></pre></td></tr></table></figure>

<p>这里default_options应该就是文档里描述的那些。我先入为主的以为这个就是磁盘上super_block的s_default_opts字段，于是通过tune_2fs查看了下，发现并不是。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tune2fs -l /dev/sdb</span><br><span class="line">tune2fs 1.46.5 (30-Dec-2021)</span><br><span class="line">// ...</span><br><span class="line">Default mount options:    user_xattr acl</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>

<p>这里只有user_xattr和acl，理论上其他的那些options当nodefs为0时也会输出，比如delalloc。但是却并没有。所以，还得探究下这个<code>sbi-&gt;s_def_mount_opt</code>字段究竟是如何被设置的。</p>
<h2 id="默认挂载选项"><a href="#默认挂载选项" class="headerlink" title="默认挂载选项"></a>默认挂载选项</h2><p>熟悉linux文件系统的都知道，vfs会有个通用的super block，每个文件系统也会有自己的super block，它们在磁盘和在内存上都会有些许差距。对于ext4来说，它在磁盘上的super block布局为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/ext4/ext4.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure of the super block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_super_block</span> &#123;</span></span><br><span class="line"><span class="comment">/*00*/</span>	__le32	s_inodes_count;		<span class="comment">/* Inodes count */</span></span><br><span class="line">	__le32	s_blocks_count_lo;	<span class="comment">/* Blocks count */</span></span><br><span class="line">	__le32	s_r_blocks_count_lo;	<span class="comment">/* Reserved blocks count */</span></span><br><span class="line">	__le32	s_free_blocks_count_lo;	<span class="comment">/* Free blocks count */</span></span><br><span class="line"><span class="comment">/*10*/</span>	__le32	s_free_inodes_count;	<span class="comment">/* Free inodes count */</span></span><br><span class="line">	__le32	s_first_data_block;	<span class="comment">/* First Data Block */</span></span><br><span class="line">	__le32	s_log_block_size;	<span class="comment">/* Block size */</span></span><br><span class="line">	__le32	s_log_cluster_size;	<span class="comment">/* Allocation cluster size */</span></span><br><span class="line"><span class="comment">/*20*/</span>	__le32	s_blocks_per_group;	<span class="comment">/* # Blocks per group */</span></span><br><span class="line">	__le32	s_clusters_per_group;	<span class="comment">/* # Clusters per group */</span></span><br><span class="line">	__le32	s_inodes_per_group;	<span class="comment">/* # Inodes per group */</span></span><br><span class="line">	__le32	s_mtime;		<span class="comment">/* Mount time */</span></span><br><span class="line"><span class="comment">/*30*/</span>	__le32	s_wtime;		<span class="comment">/* Write time */</span></span><br><span class="line">	__le16	s_mnt_count;		<span class="comment">/* Mount count */</span></span><br><span class="line">	__le16	s_max_mnt_count;	<span class="comment">/* Maximal mount count */</span></span><br><span class="line">	__le16	s_magic;		<span class="comment">/* Magic signature */</span></span><br><span class="line">	__le16	s_state;		<span class="comment">/* File system state */</span></span><br><span class="line">	__le16	s_errors;		<span class="comment">/* Behaviour when detecting errors */</span></span><br><span class="line">	__le16	s_minor_rev_level;	<span class="comment">/* minor revision level */</span></span><br><span class="line"><span class="comment">/*40*/</span>	__le32	s_lastcheck;		<span class="comment">/* time of last check */</span></span><br><span class="line">	__le32	s_checkinterval;	<span class="comment">/* max. time between checks */</span></span><br><span class="line">	__le32	s_creator_os;		<span class="comment">/* OS */</span></span><br><span class="line">	__le32	s_rev_level;		<span class="comment">/* Revision level */</span></span><br><span class="line"><span class="comment">/*50*/</span>	__le16	s_def_resuid;		<span class="comment">/* Default uid for reserved blocks */</span></span><br><span class="line">	__le16	s_def_resgid;		<span class="comment">/* Default gid for reserved blocks */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * These fields are for EXT4_DYNAMIC_REV superblocks only.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Note: the difference between the compatible feature set and</span></span><br><span class="line"><span class="comment">	 * the incompatible feature set is that if there is a bit set</span></span><br><span class="line"><span class="comment">	 * in the incompatible feature set that the kernel doesn&#x27;t</span></span><br><span class="line"><span class="comment">	 * know about, it should refuse to mount the filesystem.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * e2fsck&#x27;s requirements are more strict; if it doesn&#x27;t know</span></span><br><span class="line"><span class="comment">	 * about a feature in either the compatible or incompatible</span></span><br><span class="line"><span class="comment">	 * feature set, it must abort and not try to meddle with</span></span><br><span class="line"><span class="comment">	 * things it doesn&#x27;t understand...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__le32	s_first_ino;		<span class="comment">/* First non-reserved inode */</span></span><br><span class="line">	__le16  s_inode_size;		<span class="comment">/* size of inode structure */</span></span><br><span class="line">	__le16	s_block_group_nr;	<span class="comment">/* block group # of this superblock */</span></span><br><span class="line">	__le32	s_feature_compat;	<span class="comment">/* compatible feature set */</span></span><br><span class="line"><span class="comment">/*60*/</span>	__le32	s_feature_incompat;	<span class="comment">/* incompatible feature set */</span></span><br><span class="line">	__le32	s_feature_ro_compat;	<span class="comment">/* readonly-compatible feature set */</span></span><br><span class="line"><span class="comment">/*68*/</span>	__u8	s_uuid[<span class="number">16</span>];		<span class="comment">/* 128-bit uuid for volume */</span></span><br><span class="line"><span class="comment">/*78*/</span>	<span class="type">char</span>	s_volume_name[EXT4_LABEL_MAX];	<span class="comment">/* volume name */</span></span><br><span class="line"><span class="comment">/*88*/</span>	<span class="type">char</span>	s_last_mounted[<span class="number">64</span>] __nonstring;	<span class="comment">/* directory where last mounted */</span></span><br><span class="line"><span class="comment">/*C8*/</span>	__le32	s_algorithm_usage_bitmap; <span class="comment">/* For compression */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Performance hints.  Directory preallocation should only</span></span><br><span class="line"><span class="comment">	 * happen if the EXT4_FEATURE_COMPAT_DIR_PREALLOC flag is on.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__u8	s_prealloc_blocks;	<span class="comment">/* Nr of blocks to try to preallocate*/</span></span><br><span class="line">	__u8	s_prealloc_dir_blocks;	<span class="comment">/* Nr to preallocate for dirs */</span></span><br><span class="line">	__le16	s_reserved_gdt_blocks;	<span class="comment">/* Per group desc for online growth */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Journaling support valid if EXT4_FEATURE_COMPAT_HAS_JOURNAL set.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="comment">/*D0*/</span>	__u8	s_journal_uuid[<span class="number">16</span>];	<span class="comment">/* uuid of journal superblock */</span></span><br><span class="line"><span class="comment">/*E0*/</span>	__le32	s_journal_inum;		<span class="comment">/* inode number of journal file */</span></span><br><span class="line">	__le32	s_journal_dev;		<span class="comment">/* device number of journal file */</span></span><br><span class="line">	__le32	s_last_orphan;		<span class="comment">/* start of list of inodes to delete */</span></span><br><span class="line">	__le32	s_hash_seed[<span class="number">4</span>];		<span class="comment">/* HTREE hash seed */</span></span><br><span class="line">	__u8	s_def_hash_version;	<span class="comment">/* Default hash version to use */</span></span><br><span class="line">	__u8	s_jnl_backup_type;</span><br><span class="line">	__le16  s_desc_size;		<span class="comment">/* size of group descriptor */</span></span><br><span class="line"><span class="comment">/*100*/</span>	__le32	s_default_mount_opts;</span><br><span class="line">	__le32	s_first_meta_bg;	<span class="comment">/* First metablock block group */</span></span><br><span class="line">	__le32	s_mkfs_time;		<span class="comment">/* When the filesystem was created */</span></span><br><span class="line">	__le32	s_jnl_blocks[<span class="number">17</span>];	<span class="comment">/* Backup of the journal inode */</span></span><br><span class="line">	<span class="comment">/* 64bit support valid if EXT4_FEATURE_COMPAT_64BIT */</span></span><br><span class="line"><span class="comment">/*150*/</span>	__le32	s_blocks_count_hi;	<span class="comment">/* Blocks count */</span></span><br><span class="line">	__le32	s_r_blocks_count_hi;	<span class="comment">/* Reserved blocks count */</span></span><br><span class="line">	__le32	s_free_blocks_count_hi;	<span class="comment">/* Free blocks count */</span></span><br><span class="line">	__le16	s_min_extra_isize;	<span class="comment">/* All inodes have at least # bytes */</span></span><br><span class="line">	__le16	s_want_extra_isize; 	<span class="comment">/* New inodes should reserve # bytes */</span></span><br><span class="line">	__le32	s_flags;		<span class="comment">/* Miscellaneous flags */</span></span><br><span class="line">	__le16  s_raid_stride;		<span class="comment">/* RAID stride */</span></span><br><span class="line">	__le16  s_mmp_update_interval;  <span class="comment">/* # seconds to wait in MMP checking */</span></span><br><span class="line">	__le64  s_mmp_block;            <span class="comment">/* Block for multi-mount protection */</span></span><br><span class="line">	__le32  s_raid_stripe_width;    <span class="comment">/* blocks on all data disks (N*stride)*/</span></span><br><span class="line">	__u8	s_log_groups_per_flex;  <span class="comment">/* FLEX_BG group size */</span></span><br><span class="line">	__u8	s_checksum_type;	<span class="comment">/* metadata checksum algorithm used */</span></span><br><span class="line">	__u8	s_encryption_level;	<span class="comment">/* versioning level for encryption */</span></span><br><span class="line">	__u8	s_reserved_pad;		<span class="comment">/* Padding to next 32bits */</span></span><br><span class="line">	__le64	s_kbytes_written;	<span class="comment">/* nr of lifetime kilobytes written */</span></span><br><span class="line">	__le32	s_snapshot_inum;	<span class="comment">/* Inode number of active snapshot */</span></span><br><span class="line">	__le32	s_snapshot_id;		<span class="comment">/* sequential ID of active snapshot */</span></span><br><span class="line">	__le64	s_snapshot_r_blocks_count; <span class="comment">/* reserved blocks for active</span></span><br><span class="line"><span class="comment">					      snapshot&#x27;s future use */</span></span><br><span class="line">	__le32	s_snapshot_list;	<span class="comment">/* inode number of the head of the</span></span><br><span class="line"><span class="comment">					   on-disk snapshot list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_S_ERR_START offsetof(struct ext4_super_block, s_error_count)</span></span><br><span class="line">	__le32	s_error_count;		<span class="comment">/* number of fs errors */</span></span><br><span class="line">	__le32	s_first_error_time;	<span class="comment">/* first time an error happened */</span></span><br><span class="line">	__le32	s_first_error_ino;	<span class="comment">/* inode involved in first error */</span></span><br><span class="line">	__le64	s_first_error_block;	<span class="comment">/* block involved of first error */</span></span><br><span class="line">	__u8	s_first_error_func[<span class="number">32</span>] __nonstring;	<span class="comment">/* function where the error happened */</span></span><br><span class="line">	__le32	s_first_error_line;	<span class="comment">/* line number where error happened */</span></span><br><span class="line">	__le32	s_last_error_time;	<span class="comment">/* most recent time of an error */</span></span><br><span class="line">	__le32	s_last_error_ino;	<span class="comment">/* inode involved in last error */</span></span><br><span class="line">	__le32	s_last_error_line;	<span class="comment">/* line number where error happened */</span></span><br><span class="line">	__le64	s_last_error_block;	<span class="comment">/* block involved of last error */</span></span><br><span class="line">	__u8	s_last_error_func[<span class="number">32</span>] __nonstring;	<span class="comment">/* function where the error happened */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_S_ERR_END offsetof(struct ext4_super_block, s_mount_opts)</span></span><br><span class="line">	__u8	s_mount_opts[<span class="number">64</span>];</span><br><span class="line">	__le32	s_usr_quota_inum;	<span class="comment">/* inode for tracking user quota */</span></span><br><span class="line">	__le32	s_grp_quota_inum;	<span class="comment">/* inode for tracking group quota */</span></span><br><span class="line">	__le32	s_overhead_clusters;	<span class="comment">/* overhead blocks/clusters in fs */</span></span><br><span class="line">	__le32	s_backup_bgs[<span class="number">2</span>];	<span class="comment">/* groups with sparse_super2 SBs */</span></span><br><span class="line">	__u8	s_encrypt_algos[<span class="number">4</span>];	<span class="comment">/* Encryption algorithms in use  */</span></span><br><span class="line">	__u8	s_encrypt_pw_salt[<span class="number">16</span>];	<span class="comment">/* Salt used for string2key algorithm */</span></span><br><span class="line">	__le32	s_lpf_ino;		<span class="comment">/* Location of the lost+found inode */</span></span><br><span class="line">	__le32	s_prj_quota_inum;	<span class="comment">/* inode for tracking project quota */</span></span><br><span class="line">	__le32	s_checksum_seed;	<span class="comment">/* crc32c(uuid) if csum_seed set */</span></span><br><span class="line">	__u8	s_wtime_hi;</span><br><span class="line">	__u8	s_mtime_hi;</span><br><span class="line">	__u8	s_mkfs_time_hi;</span><br><span class="line">	__u8	s_lastcheck_hi;</span><br><span class="line">	__u8	s_first_error_time_hi;</span><br><span class="line">	__u8	s_last_error_time_hi;</span><br><span class="line">	__u8	s_first_error_errcode;</span><br><span class="line">	__u8    s_last_error_errcode;</span><br><span class="line">	__le16  s_encoding;		<span class="comment">/* Filename charset encoding */</span></span><br><span class="line">	__le16  s_encoding_flags;	<span class="comment">/* Filename charset encoding flags */</span></span><br><span class="line">	__le32  s_orphan_file_inum;	<span class="comment">/* Inode for tracking orphan inodes */</span></span><br><span class="line">	__le32	s_reserved[<span class="number">94</span>];		<span class="comment">/* Padding to the end of the block */</span></span><br><span class="line">	__le32	s_checksum;		<span class="comment">/* crc32c(superblock) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它会有个字段<code>s_default_mount_opts</code>，其实就是tune2fs工具展示的Default mount options，这个值是在磁盘上永久保存的，一般都是当mkfs创建文件系统的时候写入，也可以通过tune2fs工具来修改。</p>
<p>它允许的默认值包括如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/ext4/ext4.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Default mount options</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_DEBUG		0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_BSDGROUPS	0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_XATTR_USER	0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_ACL		0x0008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_UID16		0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_JMODE		0x0060</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_JMODE_DATA	0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_JMODE_ORDERED	0x0040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_JMODE_WBACK	0x0060</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_NOBARRIER	0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_BLOCK_VALIDITY 0x0200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_DISCARD	0x0400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_NODELALLOC	0x0800</span></span><br></pre></td></tr></table></figure>

<p>mkfs可以通过配置文件来设置创建文件系统后super block里default_mntopts字段的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// /etc/mke2fs.conf</span><br><span class="line">[defaults]</span><br><span class="line">        base_features = sparse_super,large_file,filetype,resize_inode,dir_index,ext_attr</span><br><span class="line">        default_mntopts = acl,user_xattr</span><br><span class="line">        enable_periodic_fsck = 0</span><br><span class="line">        blocksize = 4096</span><br><span class="line">        inode_size = 256</span><br><span class="line">        inode_ratio = 16384</span><br><span class="line"></span><br><span class="line">[fs_types]</span><br><span class="line">        ext3 = &#123;</span><br><span class="line">                features = has_journal</span><br><span class="line">        &#125;</span><br><span class="line">        ext4 = &#123;</span><br><span class="line">                features = has_journal,extent,huge_file,flex_bg,metadata_csum,64bit,dir_nlink,extra_isize</span><br><span class="line">        &#125;</span><br><span class="line">        small = &#123;</span><br><span class="line">                inode_ratio = 4096</span><br><span class="line">        &#125;</span><br><span class="line">        floppy = &#123;</span><br><span class="line">                inode_ratio = 8192</span><br><span class="line">        &#125;</span><br><span class="line">        big = &#123;</span><br><span class="line">                inode_ratio = 32768</span><br><span class="line">        &#125;</span><br><span class="line">        huge = &#123;</span><br><span class="line">                inode_ratio = 65536</span><br><span class="line">        &#125;</span><br><span class="line">        news = &#123;</span><br><span class="line">                inode_ratio = 4096</span><br><span class="line">        &#125;</span><br><span class="line">        largefile = &#123;</span><br><span class="line">                inode_ratio = 1048576</span><br><span class="line">                blocksize = -1</span><br><span class="line">        &#125;</span><br><span class="line">        largefile4 = &#123;</span><br><span class="line">                inode_ratio = 4194304</span><br><span class="line">                blocksize = -1</span><br><span class="line">        &#125;</span><br><span class="line">        hurd = &#123;</span><br><span class="line">             blocksize = 4096</span><br><span class="line">             inode_size = 128</span><br><span class="line">             warn_y2038_dates = 0</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以确定，内存里加载过后的superblock的字段<code>s_def_mount_opt</code>和磁盘上super block的字段<code>s_default_mount_opts</code>实际上并非对应的关系，在内核挂载阶段的内核代码里会对<code>ext4_sb_info -&gt; s_def_mount_opt</code>进行设置。有意思的是，可以在磁盘上的superblock里设置EXT4_DEFM_NODELALLOC，从而改变挂载时默认delalloc的逻辑。</p>
<p>接下来梳理了一下内核代码关于mount option的设置流程：<code>sys_mount()</code> -&gt; <code>do_mount()</code> -&gt; <code>path_mount()</code> -&gt; <code>do_new_mount()</code> -&gt; <code>vfs_get_tree()</code> -&gt; <code>ext4_get_tree()</code> -&gt; <code>get_tree_bdev()</code> -&gt; <code>ext4_fill_super</code> -&gt; <code>__ext4_fill_super()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/ext4/super.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __ext4_fill_super(<span class="keyword">struct</span> fs_context *fc, <span class="keyword">struct</span> super_block *sb)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_super_block</span> *<span class="title">es</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_sb_info</span> *<span class="title">sbi</span> =</span> EXT4_SB(sb);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">flex_groups</span> **<span class="title">flex_groups</span>;</span></span><br><span class="line">	<span class="type">ext4_fsblk_t</span> block;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">root</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_fs_context</span> *<span class="title">ctx</span> =</span> fc-&gt;fs_private;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载sbi-&gt;s_es，es指向磁盘上布局的super block数据</span></span><br><span class="line">	err = ext4_load_super(sb, &amp;logical_sb_block, silent);</span><br><span class="line"></span><br><span class="line">	es = sbi-&gt;s_es;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析es-&gt;s_default_mount_opts，这也是mkfs时可以设置的挂载options</span></span><br><span class="line">	<span class="comment">// 这个字段为字符串</span></span><br><span class="line">	ext4_set_def_opts(sb, es);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析es-&gt;s_mount_opts</span></span><br><span class="line">	err = parse_apply_sb_mount_options(sb, ctx);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> failed_mount;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里的赋值很关键，会把上述解析出来的option都列为s_def_mount_opt</span></span><br><span class="line">	sbi-&gt;s_def_mount_opt = sbi-&gt;s_mount_opt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里在设置挂载时参数附带的options，不再将其设置为s_def_mount_opt</span></span><br><span class="line">	ext4_apply_options(fc, sb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里也有可能设置sbi-&gt;s_def_mount_opt</span></span><br><span class="line">	<span class="keyword">if</span> (!test_opt(sb, NOLOAD) &amp;&amp; ext4_has_feature_journal(sb)) &#123;</span><br><span class="line">		err = ext4_load_and_init_journal(sb, es, ctx);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> failed_mount3a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过es-&gt;s_default_mount_opts来设置sbi-&gt;s_mount_opt</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ext4_set_def_opts</span><span class="params">(<span class="keyword">struct</span> super_block *sb,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> ext4_super_block *es)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> def_mount_opts;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set defaults before we parse the mount options */</span></span><br><span class="line">	def_mount_opts = le32_to_cpu(es-&gt;s_default_mount_opts);</span><br><span class="line">	set_opt(sb, INIT_INODE_TABLE);</span><br><span class="line">	<span class="keyword">if</span> (def_mount_opts &amp; EXT4_DEFM_DEBUG)</span><br><span class="line">		set_opt(sb, DEBUG);</span><br><span class="line">	<span class="keyword">if</span> (def_mount_opts &amp; EXT4_DEFM_BSDGROUPS)</span><br><span class="line">		set_opt(sb, GRPID);</span><br><span class="line">	<span class="keyword">if</span> (def_mount_opts &amp; EXT4_DEFM_UID16)</span><br><span class="line">		set_opt(sb, NO_UID32);</span><br><span class="line">	<span class="comment">/* xattr user namespace &amp; acls are now defaulted on */</span></span><br><span class="line">	set_opt(sb, XATTR_USER);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXT4_FS_POSIX_ACL</span></span><br><span class="line">	set_opt(sb, POSIX_ACL);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (ext4_has_feature_fast_commit(sb))</span><br><span class="line">		set_opt2(sb, JOURNAL_FAST_COMMIT);</span><br><span class="line">	<span class="comment">/* don&#x27;t forget to enable journal_csum when metadata_csum is enabled. */</span></span><br><span class="line">	<span class="keyword">if</span> (ext4_has_metadata_csum(sb))</span><br><span class="line">		set_opt(sb, JOURNAL_CHECKSUM);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((def_mount_opts &amp; EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)</span><br><span class="line">		set_opt(sb, JOURNAL_DATA);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((def_mount_opts &amp; EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)</span><br><span class="line">		set_opt(sb, ORDERED_DATA);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((def_mount_opts &amp; EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)</span><br><span class="line">		set_opt(sb, WRITEBACK_DATA);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (le16_to_cpu(es-&gt;s_errors) == EXT4_ERRORS_PANIC)</span><br><span class="line">		set_opt(sb, ERRORS_PANIC);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (le16_to_cpu(es-&gt;s_errors) == EXT4_ERRORS_CONTINUE)</span><br><span class="line">		set_opt(sb, ERRORS_CONT);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		set_opt(sb, ERRORS_RO);</span><br><span class="line">	<span class="comment">/* block_validity enabled by default; disable with noblock_validity */</span></span><br><span class="line">	set_opt(sb, BLOCK_VALIDITY);</span><br><span class="line">	<span class="keyword">if</span> (def_mount_opts &amp; EXT4_DEFM_DISCARD)</span><br><span class="line">		set_opt(sb, DISCARD);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((def_mount_opts &amp; EXT4_DEFM_NOBARRIER) == <span class="number">0</span>)</span><br><span class="line">		set_opt(sb, BARRIER);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * enable delayed allocation by default</span></span><br><span class="line"><span class="comment">	 * Use -o nodelalloc to turn it off</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!IS_EXT3_SB(sb) &amp;&amp; !IS_EXT2_SB(sb) &amp;&amp;</span><br><span class="line">	    ((def_mount_opts &amp; EXT4_DEFM_NODELALLOC) == <span class="number">0</span>))</span><br><span class="line">		set_opt(sb, DELALLOC);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sb-&gt;s_blocksize == PAGE_SIZE)</span><br><span class="line">		set_opt(sb, DIOREAD_NOLOCK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果之前没有设置过EXT4_MOUNT_JOURNAL_DATA字段，也会将其设置成默认字段</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ext4_load_and_init_journal</span><span class="params">(<span class="keyword">struct</span> super_block *sb,</span></span><br><span class="line"><span class="params">				      <span class="keyword">struct</span> ext4_super_block *es,</span></span><br><span class="line"><span class="params">				      <span class="keyword">struct</span> ext4_fs_context *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We have now updated the journal if required, so we can</span></span><br><span class="line"><span class="comment">	 * validate the data journaling mode. */</span></span><br><span class="line">	<span class="keyword">switch</span> (test_opt(sb, DATA_FLAGS)) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="comment">/* No mode set, assume a default based on the journal</span></span><br><span class="line"><span class="comment">		 * capabilities: ORDERED_DATA if the journal can</span></span><br><span class="line"><span class="comment">		 * cope, else JOURNAL_DATA</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (jbd2_journal_check_available_features</span><br><span class="line">		    (sbi-&gt;s_journal, <span class="number">0</span>, <span class="number">0</span>, JBD2_FEATURE_INCOMPAT_REVOKE)) &#123;</span><br><span class="line">			set_opt(sb, ORDERED_DATA);</span><br><span class="line">			sbi-&gt;s_def_mount_opt |= EXT4_MOUNT_ORDERED_DATA;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			set_opt(sb, JOURNAL_DATA);</span><br><span class="line">			sbi-&gt;s_def_mount_opt |= EXT4_MOUNT_JOURNAL_DATA;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EXT4_MOUNT_ORDERED_DATA:</span><br><span class="line">	<span class="keyword">case</span> EXT4_MOUNT_WRITEBACK_DATA:</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在挂载的过程中，<code>sbi-&gt;s_def_mount_opt</code>和<code>es-&gt;s_mount_opts</code>并非简单的对应关系，ext4会对<code>sbi-&gt;s_def_mount_opt</code>进行额外的设置。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Ext4文件系统的mount option设置来源有几个地方，一是通过mkfs时在磁盘上的superblock写入，二是挂载时的参数。但是这些和内存中文件系统相关的mount options和default mount options都不是简单的对应关系，ext4会根据其他的信息设置options。</p>
<p>查看ext4挂载选项认准<code>/proc/fs/ext4/&#123;device&#125;/options</code>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2021/09/01/Linux/Linux_uids/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/01/Linux/Linux_uids/" class="post-title-link" itemprop="url">Linux访问控制模型和进程凭证</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-01 14:43:31" itemprop="dateCreated datePublished" datetime="2021-09-01T14:43:31+00:00">2021-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Linux的访问控制模型"><a href="#Linux的访问控制模型" class="headerlink" title="Linux的访问控制模型"></a>Linux的访问控制模型</h2><p>Linux传统的访问控制模型是DAC（Discretionary Access Control，自主访问控制）。DAC Model是根据自主访问控制策略建立的一种模型，允许合法用户以用户或用户组的身份访问策略规定的客体，同时阻止非授权用户访问客体，某些用户还可以自主地把自己所拥有的客体的访问权限授予其他用户。在Linux中，这里用户和用户组就对应了user和group，客体就代表了文件、文件夹、IPC等共享资源。对于客体，比如文件来说，可以对于不同的主体分别设置rwx权限。当然，对于主体的划分粒度较粗，只能对文件所有者、同组用户、其他用户分别设置，没法针对每个用户单独设立权限。</p>
<p>ps：SELinux上引入了MAC模型，这里不做深入。</p>
<h2 id="进程的用户ID凭证"><a href="#进程的用户ID凭证" class="headerlink" title="进程的用户ID凭证"></a>进程的用户ID凭证</h2><p>众所周知，Linux上一切操作都是基于进程来进行，比如常见的在shell里执行命令等。在执行需要权限判断的操作时，进程都会通过某个系统调用陷入内核，由内核来进行权限的判断。那么很自然就能想到，既然Linux的DAC模型基于用户和组做权限控制，那么进程里必然得保存关于用户和组的信息。具体实现上来说，进程都有一套数字来表示它所属于的用户ID和组ID。以下主要讲解用户ID凭证，组ID的原理和实现和用户类似，就不再赘述。这些ID称为进程凭证。对于用户ID来说，具体有三个：</p>
<ul>
<li>实际用户ID(real user ID)</li>
<li>有效用户ID(effective user ID)</li>
<li>保存的set-user-ID(saved-user-ID)</li>
</ul>
<h3 id="需要保存三个uid吗？"><a href="#需要保存三个uid吗？" class="headerlink" title="需要保存三个uid吗？"></a>需要保存三个uid吗？</h3><h4 id="一个ID够吗？"><a href="#一个ID够吗？" class="headerlink" title="一个ID够吗？"></a>一个ID够吗？</h4><p>可能有人会困惑，为什么需要保存三个id。只保存一个启动进程的用户ID可不可行呢？当前用户通过login进程登录之后，保存它的<code>uid</code>。后续再由该用户启动的程序都是login进程的子孙进程，只要让子进程的<code>uid</code>凭证都继承自父进程，<code>uid</code>就此就能保存下来。</p>
<p>以上的设计在大部分场景下够用。但是有些程序的权限需求比较特殊，得让普通用户执行也有文件所有者的权限。比如说用户的密码储存在<code>/etc/shadow</code>中，普通用户不可读写。但是，<code>passwd</code>程序允许用户修改它们自己的密码。也就是，当用户执行<code>passwd</code>，它们可以突然修改<code>/etc/shadow</code>，而且得识别出启动进程的用户，如何实现？如果按照上述的设计，普通用户执行<code>passwd</code>，进程<code>uid</code>为非0，那必然没有<code>/etc/shadow</code>的读写权限。</p>
<h4 id="set-uid-两个ID够吗？"><a href="#set-uid-两个ID够吗？" class="headerlink" title="set-uid,两个ID够吗？"></a>set-uid,两个ID够吗？</h4><p>于是，早年的开发者们就想到了，在文件的属性上加了一位做标记，<code>set-user-id</code>位。那么，继续沿用上述的设计，在<code>exec</code>标志<code>set-user-id</code>位的可执行程序时，将进程的<code>uid</code>改成文件所有者，普通用户无法读写<code>/etc/shadow</code>问题就迎刃而解了。但这样引入了了另一个问题，诸如<code>passwd</code>这样的程序无法知道启动进程的用户，都不知道该改哪个用户的密码了。很显然，进程保存一个<code>uid</code>肯定是不够用了，至少得再加一个。一个记录运行程序的用户id，一个记录实际用于权限判断的用户id。实际上，<code>real-uid</code>和<code>effective-uid</code>就是干的这个事情。<code>real-uid</code>为启动进程的用户id，<code>effective-uid</code>为实际用户权限判断的用户id。大部分情况下，<code>real-uid</code>和<code>effective-uid</code>相同。运行设置<code>set-uid</code>的程序，<code>effective-uid</code>会改成程序文件的owner。</p>
<p>这样的设计也不够好，因为<code>effective-uid</code>的更改变成了一锤子买卖。如果有进程需要在启动的用户和文件owner之间反复横跳怎么办？<code>effective-uid</code>改回<code>real-uid</code>之后文件所属用户id就丢失了（进程得根据执行的文件<code>exe</code>大费周折去文件系统的inode里查所属用户）。</p>
<h4 id="最小权限原则，三个ID"><a href="#最小权限原则，三个ID" class="headerlink" title="最小权限原则，三个ID"></a>最小权限原则，三个ID</h4><p>这个”反复横跳”的需求也是很有必要的。有个最小权限原则（最早由 Saltzer 和 Schroeder 提出）：</p>
<blockquote>
<p>每个程序和系统用户都应该具有完成任务所必需的最小权限集合。<br>限制代码运行所需的安全权限，有一个非常重要的原因，就是降低你的代码在被恶意用户利用时，造成的损失。如果你的代码仅仅使用最小权限来执行，恶意用户就难以使用它造成损失。如果你需要用户使用管理员权限来执行代码，任何代码中的安全缺陷，都会通过利用该缺陷的恶意用户，潜在造成更大的损失。</p>
</blockquote>
<p>根据最小权限原则，只有实际进行关键操作的时候获取权限，其余时候应该禁用。比如说对于<code>passwd</code>程序来说，最好就是只有在读写<code>/etc/shadow</code>的时候获取root权限，其余时候（比如说等待用户输入时）放弃特权。</p>
<h4 id="具体规则"><a href="#具体规则" class="headerlink" title="具体规则"></a>具体规则</h4><p>所以，最后就形成了现今的实现，进程里保存了三个uid。这三个uid初始化的规则如下：</p>
<ol>
<li><code>real-uid</code>为启动进程的用户。</li>
<li>如果是<code>set-uid</code>程序运行的进程，<code>effective-uid</code>为文件的所有者；否则和<code>real-uid</code>相同，为启动进程的用户。</li>
<li><code>saved-uid</code>由<code>effective-uid</code>复制而来。</li>
</ol>
<p>对于普通的非特权用户来说，允许通过一些系统调用让<code>effective-uid</code>在<code>real-uid</code>和<code>saved-uid</code>之间来回变动。进程运行时，权限的检查则都是基于<code>effective uid</code>。对于一个拥有良好安全设计的<code>set-uid</code>程序来说，只有需要使用特殊权限的时候才把<code>effective-uid</code>切换成文件所有者，其余时候都应该为进程启动者。</p>
<h4 id="系统接口"><a href="#系统接口" class="headerlink" title="系统接口"></a>系统接口</h4><p>Linux上支持改动修改进程凭证的一些系统接口：</p>
<p><img src="/img/setuid.png" alt="修改进程凭证的一些系统调用"></p>
<p><strong>参考</strong>：</p>
<ol>
<li>《Linux系统编程手册》第9章</li>
<li><a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/syracuse-sec-lecture-notes/content/3.html">https://wizardforcel.gitbooks.io/syracuse-sec-lecture-notes/content/3.html</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2021/08/19/container/A%20Tale%20of%20Two%20Systems%20Using%20Containers%20to%20Deploy%20HPC%20Applications%20on%20Supercomputers%20and%20Clouds/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/19/container/A%20Tale%20of%20Two%20Systems%20Using%20Containers%20to%20Deploy%20HPC%20Applications%20on%20Supercomputers%20and%20Clouds/" class="post-title-link" itemprop="url">A Tale of Two Systems: Using Containers to Deploy HPC Applications on Supercomputers and Clouds</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-19 12:15:31" itemprop="dateCreated datePublished" datetime="2021-08-19T12:15:31+00:00">2021-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Container/" itemprop="url" rel="index"><span itemprop="name">Container</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Container/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">论文笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Younge, Andrew J., et al. “A tale of two systems: Using containers to deploy HPC applications on supercomputers and clouds.” 2017 IEEE International Conference on Cloud Computing Technology and Science (CloudCom). IEEE, 2017.</p>
<h2 id="container"><a href="#container" class="headerlink" title="container"></a>container</h2><ul>
<li>Docker</li>
<li>Shifter</li>
<li>Charliecloud</li>
<li>Singularity</li>
</ul>
<h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><p><img src="/img/devops.png" alt="DevOps"></p>
<p>部署的工作流：</p>
<ol>
<li>在本地电脑上使用docker容器（因为桌面电脑用win和macOS的比较多，docker都支持），将Dockerfile和项目代码保存到git项目中。</li>
<li>项目推送到远端的仓库，并将容器镜像放进容器注册服务。</li>
<li>在多个平台上（EC2、cluster、supercomputer）拉取代码，在容器中执行。</li>
</ol>
<h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><ul>
<li><p>镜像环境：</p>
<ul>
<li><p>HPCG benchmark</p>
</li>
<li><p>Intel MPI Benchmark suite (IMB)</p>
</li>
<li><p>base image: Centos 7, both benchmarks were built using the Intel 2017 Parallel Studio, which includes the latest Intel compilers and Intel MPI library.</p>
<p>拉取镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ajyounge/hpcg-container</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Cray  XC30 supercomputing platform</p>
<ul>
<li><p>hardware:</p>
<blockquote>
<p>Volta includes 56 compute nodes packaged in a single enclosure, with each node consisting of two Intel Ivy Bridge E5-2695v2 2.4 GHz processors (24 cores total), 64GB of memory, and a Cray Aries network interface.</p>
</blockquote>
</li>
<li><p>shared file system</p>
<blockquote>
<p>Shared file system supportis provided by NFS I&#x2F;O servers projected to compute nodes via Cray’s proprietary DVS storage infrastructure.</p>
</blockquote>
</li>
<li><p>OS:Cray Compute Node Linux (CNL ver. 5.2.UP04, 基于SUSE Linux 11), linux kernel v3.0.101</p>
<pre><code>内核版本过老，需要做出修改才能使用Singularity。具体来说，增加了对loopback设备和EXT3文件系统的支持。
</code></pre>
<ul>
<li><p>config：</p>
<blockquote>
<p>Specifically, we configure Singularity to mount &#x2F;opt&#x2F;cray, as well as &#x2F;var&#x2F;opt&#x2F;cray for each container instance.</p>
</blockquote>
<blockquote>
<p>In order to leverage the Aries interconnect as well as advanced shared memory intra-node communication mechanisms, we dynamically link Cray’s MPI and associated libraries provided in &#x2F;opt&#x2F;cray directly within the container</p>
</blockquote>
<p>  链接的动态库包括：</p>
<ul>
<li>Cray’s uGNI messaging interface</li>
<li>XPMEM shared memory subsystem</li>
<li>Cray PMI runtime libraries</li>
<li>uDREG registration cache</li>
<li>application placement scheduler (ALPS)</li>
<li>configure workload manager</li>
<li>some Intel Parallel Studio libraries</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Amazon EC2: c3.8xlarge</p>
<ul>
<li><p>hardware:</p>
<ul>
<li>cpu: Intel Xeon “Ivy-Bridge” E5-2680 v2 (2.8 GHz, 8 cores, hyperthread) x 2</li>
<li>memory: 60GB of RAM</li>
<li>disk: 2x320 GB SSDs</li>
<li>network: 10 Gb Ethernet network</li>
</ul>
</li>
<li><p>OS: RHEL7</p>
<ul>
<li>config:<br>  使用SR-IOV技术，加载了ixgbevf内核模块。</li>
</ul>
</li>
<li><p>Docker: v1.19</p>
</li>
</ul>
</li>
</ul>
<h2 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h2><blockquote>
<p>Benchmarks are reported as the average of 10 trials for IMB and 3 trials for HPCG, with negligible run-to-runvariance that is therefore not shown.</p>
</blockquote>
<ul>
<li><p>IMB</p>
<p>  测试网络的带宽和延迟，对应MPI节点通信的性能。对于全静态链接和动态链接的版本做了测试。</p>
<ul>
<li><p>PingPong bandwidth</p>
<p><img src="/img/IMB_pingpong.png" alt="IMB PingPong bandwidth"></p>
<p>Singularity容器中链接CrayMPI，带宽最高，接近native。表明MPI库的选择会严重影响性能，针对特殊机器做过优化的版本最优。</p>
</li>
<li><p>PingPong Latency</p>
<p><img src="/img/IMB_PingPong_latency.png" alt="IMB PingPong Latency"></p>
<p>Singularity链接CrayMPI，延迟和native采用动态链接基本一致。静态链接的版本延迟最低。</p>
</li>
</ul>
</li>
<li><p>HPCG</p>
<p>  MPI程序的性能</p>
<p>  <img src="/img/Cray_HPCG.png" alt="HPCG benchmark"></p>
<p>  可以观察到，随着rank数量增加，Cray相比EC2的性能优势开始体现；Singularity链接CrayMPI的性能接近native；链接IntelMPI的性能甚至不如kvm虚拟机。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2021/08/18/container/Performance%20Evaluation%20of%20Container-based%20Virtualization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/18/container/Performance%20Evaluation%20of%20Container-based%20Virtualization/" class="post-title-link" itemprop="url">Performance Evaluation of Container-based Virtualization for High Performance Computing Environments</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-18 12:15:31" itemprop="dateCreated datePublished" datetime="2021-08-18T12:15:31+00:00">2021-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Container/" itemprop="url" rel="index"><span itemprop="name">Container</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Container/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">论文笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Xavier, Miguel G., et al. “Performance evaluation of container-based virtualization for high performance computing environments.” 2013 21st Euromicro International Conference on Parallel, Distributed, and Network-Based Processing. IEEE, 2013.</p>
<h2 id="containers"><a href="#containers" class="headerlink" title="containers"></a>containers</h2><ul>
<li>LXC(<strong>L</strong>inu<strong>x</strong> <strong>C</strong>ontainer) 2.0.9</li>
<li>docker 17.03.0-ce, build 60ccb22</li>
<li>singularity 2.2.1</li>
</ul>
<p>singularity相比另外两款容器技术在功能上适当舍弃，比如启动不改变用户、没有使用cgroup等。这些都对性能有积极影响。</p>
<h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><blockquote>
<p>CPU model Intel(R) Xeon(R) CPU E5-2683v4  @  2.10GHz(64-core  node);  Memory  164  GB  DDR3-1,866  MHz,  72-bit  wide  bus  at  14.9  GB&#x2F;s  on  P244br  anda HPE Dynamic Smart Array B140i Disk; OS Ubuntu 16.04(64-bit) distribution was installed on the host machine.</p>
</blockquote>
<h2 id="benchmarks"><a href="#benchmarks" class="headerlink" title="benchmarks"></a>benchmarks</h2><ul>
<li><p>执行基本命令 echo hello world</p>
<p>  <img src="/img/echo-helloworld.png" alt="/bin/echo &quot;hello world&quot; result"></p>
</li>
<li><p>HPL</p>
<p>  用于测试CPU性能。编译环境：GNU C&#x2F;C++ 5.4，OpenMPI 2.0.2。</p>
<blockquote>
<p>For  the  HPL  benchmark,  the  performance  results  dependon two main factors: the Basic Linear Algebra Subprogram(BLAS) library,  and  the  problem  size.  We  used  in  our experiments the GotoBLAS library, which is one of the bestportable  solutions,  freely  available  to  scientists.  Searchingfor  the  problem  size  that  can  deliver  peak  performance  isextensive; instead, we used the same problem size 10 times(10 N, 115840 Ns) for performance analysis.</p>
</blockquote>
<p>  BLAS库：GotoBLAS， 问题规模：10 N, 115840 Ns</p>
<p>  <img src="/img/hpl.png" alt="hpl result"></p>
<blockquote>
<p>The  LXC  was  not  able  to achieve  native  performance  presenting  an  average  overheadof 7.76%, Docker overhead was 2.89%, this could be probably caused by the default CPU use restrictions set on the daemon which by default each container is allowed to use a node’s CPU for a predefined amount of time. Singularity was able to achieve a better performance than native with 5.42% because is not emulating a full hardware level virtualization(only the mount namespace) paradigm and as the image itself is only a single metadata lookup this can yield in very high performance benefits.</p>
</blockquote>
<p>  <strong>TODO:</strong> singularity为什么比裸机还快？docker或者LXC通过调整cgroup的配置能否进一步释放性能？</p>
</li>
<li><p>IOzone</p>
<p>  测试IO。</p>
<blockquote>
<p>We  ran  the  benchmark  witha  file  size  of  15GB  and  64KB  for  the  record  size,  under two(2)  scenarios. The  first  scenario  was  a  totally  containedfilesystem  (without  any  bind  or  mount  volume),  and  thesecond scenario was a NFS binding from the local cluster.</p>
</blockquote>
<p>  <img src="/img/IOzone-1.png" alt="IOzone read and write"></p>
<p>  <img src="/img/IOzone-2.png" alt="IOzone random read and write"></p>
<blockquote>
<p>Docker advanced multi-layered unificationfilesystem (AUFS)  has  it  drawbacks.  When  an  applicationrunning in a container needs to write a single new value toa file on a AUFS, it must copy on write up the file from theunderlying  image.  The  AUFS  storage  driver  searches  eachimage  layer  for  the  file.  The  search order is from top to bottom. When it is found, the entire file is copied up to thecontainer’s top writable layer. From there, it can be openedand modified.</p>
</blockquote>
<p>  Docker读写no-bind普遍比较慢的原因是AUFS。</p>
<p>  <strong>TODO:</strong> 连续读写和随机读写时，bind和no-bind的性能优劣正好反过来。why？（猜测：可能和文件系统、挂载的硬盘有关）</p>
</li>
<li><p>STREAM</p>
<p>  测试内存带宽。</p>
<p>  <img src="/img/stream.png" alt="stream"></p>
<p>  singularity性能最优，因为没有cgroup对资源的限制。</p>
</li>
<li><p>MVA-PICH OSU Micro-Benchmarks 5.3.2</p>
<p>  测试MPI通信的带宽和延迟。</p>
<p>  <img src="/img/MPI-bandwidth.png" alt="MPI bandwidth"><br>  <img src="/img/MPI-latency.png" alt="MPI latency"></p>
<blockquote>
<p>These results can be explained  due  to  different  implementations  of  the  network isolation  of  the  virtualization  systems. While  Singularity container  does  not  implement  virtualized  network  devices,both  Docker  and  LXC  implement  network  namespace  that provides  an  entire  network  subsystem.  COS  network  performance  degradation  is  caused  by  the  extra  complexity  oftransmit and receive packets (e.g. Daemon processes).</p>
</blockquote>
</li>
<li><p>NAMD</p>
<p>  测试GPU性能</p>
<ul>
<li><p>Environment:</p>
<blockquote>
<p>The  performance  studies  were  executed  on  a  Dell  Po-werEdge  R720,  with  2*Intel(R)  Xeon(R)  CPU  E5-2603  @1.80GHz  (8  cores)  and  a  NVIDIA  Tesla  K20M.7.  Froma  system  point  of  view,  we  used  Ubuntu  16.04.2  (64-bit),with NVIDIA cuda 8.0 and the NVIDIA driver version375.26.</p>
</blockquote>
</li>
<li><p>version:</p>
<ul>
<li>Singularity 2.2.1</li>
<li>Docker 17.03.0-ce, build 60ccb22</li>
<li>LXC 2.0.9</li>
</ul>
</li>
<li><p>detail：</p>
<blockquote>
<p>We  ran  those  GPU  benchmarks  on  a  Tesla  K20m  with  “NAMD  x8664  multicoreCUDA version 2017-03-16” [on the stmv dataset (1066628 Atoms)],  using  the  8  cores  and  the  GPU  card,  withoutany  specific  additional  configuration,  except  the  use  of  the“gpu4singularity” code  for  Singularity  and  the  “nvidia-docker” tool  for  Docker.</p>
</blockquote>
</li>
<li><p>result:</p>
<p><img src="/img/NAMD.png" alt="NAMD"></p>
<p>单位：天&#x2F;纳秒。越低越好。</p>
</li>
</ul>
</li>
</ul>
<h3 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h3><p>作者在github上开源了测试运行的脚本。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ArangoGutierrez/containers-benchs">https://github.com/ArangoGutierrez/containers-benchs</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2021/08/17/container/HPC%20container%20runtime%20performance%20overhead/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/17/container/HPC%20container%20runtime%20performance%20overhead/" class="post-title-link" itemprop="url">HPC container runtime performance overhead: At first order, there is none</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-17 12:15:31" itemprop="dateCreated datePublished" datetime="2021-08-17T12:15:31+00:00">2021-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Container/" itemprop="url" rel="index"><span itemprop="name">Container</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Container/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">论文笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Torrez, Alfred, Reid Priedhorsky, and Timothy Randles. “HPC container runtime performance overhead: At first order, there is none.” (2020).</p>
<h2 id="containters"><a href="#containters" class="headerlink" title="containters"></a>containters</h2><ul>
<li>Charliecloud</li>
<li>Shifter</li>
<li>Singularity</li>
</ul>
<h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><p>LANL’s CTS-1 clusters Grizzly (1490 nodes,<br>128 GiB RAM&#x2F;node; HPCG) and Fog (32 nodes, 256 GiB RAM&#x2F;node; SysBench, STREAM, and HPCG)</p>
<p>分别在三种容器以及裸机环境中进行测试。</p>
<h2 id="benchmarks"><a href="#benchmarks" class="headerlink" title="benchmarks"></a>benchmarks</h2><ul>
<li><p>SysBench</p>
<p>  CPU性能。36路线程计算低于4000万的质数。</p>
<p>  4个环境下耗时几乎相同。</p>
</li>
<li><p>STREAM</p>
<p>  内存性能。编译选项 STREAM_ARRAY_SIZE&#x3D;2,000,000 –cpu_bind&#x3D;v,core,map_cpu:23。跑了100个单独的线程。</p>
<blockquote>
<p>We compiled with STREAM_ARRAY_SIZE set to 2 billion to match the recommended 4× cache and pinned the process to a semi-arbitrary core using the Slurm argument –cpu_bind&#x3D;v,core,map_cpu:23.</p>
</blockquote>
<p>  4个环境下测试出的带宽几乎相同</p>
</li>
<li><p>HPCG(High Performance Conjugate Gradients)</p>
<blockquote>
<p>We used a cube dimension of 104 and a run time of 60 seconds, all 36 cores per node, one MPI rank per core, and one thread per rank.</p>
</blockquote>
<p>  <img src="/img/1.png" alt="HPCG"></p>
</li>
<li><p>memory usage</p>
<blockquote>
<p>To understand node memory usage with STREAM, we computed MemTotal – MemFree from &#x2F;proc&#x2F;meminfo, sampled at 10-second intervals.</p>
</blockquote>
<blockquote>
<p>Bare metal total node usage was a median of 50.8 MiB. Charliecloud added 1200 MiB, Shifter 16 MiB, and Singularity 37 MiB.</p>
</blockquote>
<p>  Charliecloudn内存使用多可能是因为存储在tmpfs里的1.2Gib镜像。</p>
<blockquote>
<p>For HPCG, we sampled at 10-second intervals the writeable&#x2F;private field of pmap(1), which reports memory consumption of individual processes. Median memory usage for all three container technologies is, to two significant figures, 0.64% lower than bare metal at 1 node, 0.53% lower at 8 nodes, 0.53–0.54% lower at 64 nodes, and 1.2% higher at 512 nodes, a minimal difference.</p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2019/02/19/C++/member_pointer_implemention/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/19/C++/member_pointer_implemention/" class="post-title-link" itemprop="url">Itanium C++ ABI下member pointer的实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-02-19 13:15:31" itemprop="dateCreated datePublished" datetime="2019-02-19T13:15:31+00:00">2019-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Itanium-C-ABI"><a href="#Itanium-C-ABI" class="headerlink" title="Itanium C++ ABI"></a>Itanium C++ ABI</h2><p><a target="_blank" rel="noopener" href="https://itanium-cxx-abi.github.io/cxx-abi/">Itanium C++ ABI</a>是一个用于C++的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>。作为ABI，它给出了实现该语言的精确规则，确保程序中单独编译的部分能够成功地互操作。尽管它最初是为Itanium架构开发的，但它不是特定于平台的，可以在任意的C ABI之上进行分层移植。因此，它被用作所有主要架构上的许多主要操作系统的标准C++ ABI，并在许多主要的c++编译器中实现，包括GCC和Clang。</p>
<p>简单点来说，x64的Linux上，GCC和Clang都是遵循Itanium C++ ABI的。所以今天就针对这个它来探讨一下member pointer的实现。</p>
<h2 id="pointer-to-data-member"><a href="#pointer-to-data-member" class="headerlink" title="pointer to data member"></a>pointer to data member</h2><blockquote>
<p>A pointer to data member is an offset from the base address of the class object containing it, represented as a ptrdiff_t. It has the size and alignment attributes of a ptrdiff_t. A NULL pointer is represented as -1.</p>
</blockquote>
<p>指向数据成员的指针，实现为在整个类中的偏移量。可以看成是<code>ptrdiff_t</code>类型的数据。</p>
<p>接下来看个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Test::*ptr2a = &amp;Test::a;</span><br><span class="line">    <span class="type">char</span> Test::*ptr2b = &amp;Test::b;</span><br><span class="line">    <span class="type">double</span> Test::*ptr2c = &amp;Test::c;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; *(std::<span class="type">ptrdiff_t</span>*)(&amp;ptr2a) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *(std::<span class="type">ptrdiff_t</span>*)(&amp;ptr2b) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *(std::<span class="type">ptrdiff_t</span>*)(&amp;ptr2c) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为0,4,8。考虑到对齐，确实为各个成员的偏移量。</p>
<h2 id="pointer-to-function"><a href="#pointer-to-function" class="headerlink" title="pointer to function"></a>pointer to function</h2><blockquote>
<p>A pointer to member function is a pair as follows:</p>
<p>ptr:</p>
<p>   For a non-virtual function, this field is a simple function pointer. (Under current base Itanium psABI conventions, that is a pointer to a GP&#x2F;function address pair.) For a virtual function, it is 1 plus the virtual table offset (in bytes) of the function, represented as a ptrdiff_t. The value zero represents a NULL pointer, independent of the adjustment field value below.</p>
<p>adj:</p>
<p>   The required adjustment to this, represented as a ptrdiff_t.</p>
</blockquote>
<p>指向成员函数的指针。分为ptr部分和adj部分。ptr可分为指向非虚函数和虚函数的情况。adj表示对于this的调整，可以看成<code>ptrdiff_t</code>类型。</p>
<p>ps：关于这个adj是干什么用的我也不是很清楚，猜测有可能和多继承有关系？ &#x3D; &#x3D;。 以后知道了再补充吧，现在先主要讲解ptr。</p>
<ul>
<li><p>pointer to non-virtual function</p>
<p>  对于非虚函数来说，ptr部分就是简单的函数地址。可以通过这个得到成员函数地址，甚至直接调用它：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  Test::func() is called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> ptr2func = &amp;Test::func;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 得到func的地址</span></span><br><span class="line">    <span class="type">uint64_t</span> addr = *(<span class="type">uint64_t</span>*)&amp;ptr2func;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内联汇编，等效于下面一行</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;leaq %0, %%rdi ; callq *%1&quot;</span> : : <span class="string">&quot;m&quot;</span>(t),<span class="string">&quot;r&quot;</span> (addr) : <span class="string">&quot;rdi&quot;</span> )</span></span>;</span><br><span class="line">    <span class="comment">// (t.*ptr2func)();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里将<code>ptr2func</code>定义为成员函数指针，然后提取出它的ptr部分，既函数地址，保存到<code>addr</code>中。然后将t的地址传入<code>rdi</code>寄存器，充当<code>this</code>指针。x64的calling convention中，<code>rdi</code>存储函数调用的第一个参数，所以将<code>this</code>指针作为隐式的第一个参数存进了<code>rdi</code>寄存器。最后通过addr的函数地址，<code>call</code>指令进行调用。最后打印出<code>this</code>，与直接<code>(t.*ptr2func)()</code>效果相同。</p>
</li>
<li><p>pointer to virtual function</p>
<p>  对于虚函数来说，ptr部分为函数在虚表中的偏移量(单位为byte)加1。如果为0，表示为NLLL pointer，虚表中没有这个函数的指针。</p>
<p>  所以，如果我们知道了虚表的位置(对象的第一个字，就是虚表指针)，结合ptr表示的偏移量，也能得到函数的地址，从而调用它：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  Test::f1() is called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  Test::f2() is called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ptr2f1 = &amp;Test::f1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到虚表的地址</span></span><br><span class="line">    <span class="type">uint8_t</span>* vtable = *(<span class="type">uint8_t</span>**)(&amp;t);</span><br><span class="line">    <span class="comment">// 得到f1函数在虚表中的偏移量</span></span><br><span class="line">    std::<span class="type">ptrdiff_t</span> f1_offset = *(std::<span class="type">ptrdiff_t</span>*)(&amp;ptr2f1) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 得到f1函数的地址</span></span><br><span class="line">    <span class="type">uint64_t</span> f1_addr = *(<span class="type">uint64_t</span>*)(vtable + f1_offset);</span><br><span class="line">    <span class="comment">// 调用它，相面两行等效</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;leaq %0, %%rdi; callq *%1&quot;</span> : : <span class="string">&quot;m&quot;</span> (t), <span class="string">&quot;r&quot;</span> (f1_addr) : <span class="string">&quot;rdi&quot;</span>)</span></span>;</span><br><span class="line">    (t.*ptr2f1)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  可以看到，我们首先在对象的首字处得到了虚表的地址<code>vtable</code>，然后通过成员函数指针的ptr部分得到了<code>f1</code>函数在虚表中的偏移量<code>f1_offset</code>。然后解引用得到了<code>f1</code>函数的地址，最后调用它。<code>rdi</code>寄存器存储<code>this</code>指针，这点前面已经谈过。最终结果与<code>(t.*ptr2f1)()</code>等价。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2019/02/02/x86/x64_syscall/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/02/x86/x64_syscall/" class="post-title-link" itemprop="url">x64上Linux的系统调用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-02-02 13:15:31" itemprop="dateCreated datePublished" datetime="2019-02-02T13:15:31+00:00">2019-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/x86/" itemprop="url" rel="index"><span itemprop="name">x86</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>x64上Linux的系统调用</p>
<p><strong>写在前面</strong>：本文希望读者有一定的Linux基础，了解过系统调用和crt的包装函数的区别。可以看我之前写过的关于<a target="_blank" rel="noopener" href="https://cyyzero.herokuapp.com/articles/8">IA32上Linux系统调用的简介</a>，以及<a target="_blank" rel="noopener" href="https://cyyzero.herokuapp.com/articles/19">《Linux内核设计与实现》一书中对系统调用的笔记</a>。</p>
<p>众所周知，在IA32上，Linux的系统调用是通过<code>int 0x80</code>中断，访问中断向量表，调用<code>sys_call()</code>。它通过<code>eax</code>传递系统调用号；其他一系列寄存器传递参数，分别存储在<code>ebx</code>，<code>ecx</code>，<code>edx</code>，<code>esi</code>，<code>edi</code>，<code>ebp</code>；返回值存储在<code>eax</code>。</p>
<p>现今，x86 64体系结构引入了一条专用指令<code>syscall</code>。它不访问中断描述符表，速度更快。它通过<code>rax</code>传递系统调用号；其他一系列寄存器传递参数，分别存储在<code>rdi</code>，<code>rsi</code>，<code>rdx</code>，<code>r10</code>，<code>r8</code>，<code>r9</code>；返回值存储在<code>rax</code>。</p>
<p>很明显，系统调用的ABI发生了剧烈的改变。进行系统调用的指令，传递系统调用号的寄存器，传递参数的寄存器，返回值的寄存器，甚至系统调用对应的编号，32位与64位都存在着很大的差异。理论上系统调用表都是向后兼容的，每次更新时只能往后添加系统调用号，已有的系统调用号则保持。我在Stack Exchange上找到了一个<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/10281567/why-are-the-system-call-numbers-different-in-amd64-linux/10281881#10281881">回答</a>，解释了从32位到64位系统调用表更改的原因：x86 64体系结构出现时，ABI(传递参数、返回值)是不同的，因此内核开发人员利用这个机会带来了期待已久的更改，为了对高速缓存行使用级别进行优化。比如，常用的<code>sys_read/sys_write/sys_open/sys_close</code>分别位于前四个系统调用号；<code>sys_exit</code>原本很靠前(原本系统调用号为1)，但每个进程都在退出时才调用一次，所以现在是靠后的60作为系统调用号。</p>
<p>目测是为了兼容，我在内核版本为4.14.0的ubuntu上仍然能通<code>int 0x80</code>进行系统调用，下面是测试的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">section .data</span><br><span class="line">str: db &quot;Hello world&quot;</span><br><span class="line">str_len equ $-str</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">[bits 64]</span><br><span class="line">_start:</span><br><span class="line">    mov eax, 4           ; sys_write的系统调用号</span><br><span class="line">    mov ebx, 1           ; 第一个参数为int fd</span><br><span class="line">    mov ecx, str         ; 第二个参数为char *buf</span><br><span class="line">    mov edx, str_len     ; 第三个参数为size_t count</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">    mov eax, 1           ; sys_exit的系统调用号</span><br><span class="line">    mov ebx, 0           ; 第一个参数为int status</span><br><span class="line">    int 0x80</span><br></pre></td></tr></table></figure>

<p>不过，x86_64的Linux最好还是通过<code>syscall</code>进行系统调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">section .data</span><br><span class="line">str: db &quot;Hello world&quot;</span><br><span class="line">str_len equ $-str</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">[bits 64]</span><br><span class="line">_start:</span><br><span class="line">    mov eax, 1           ; 代表sys_write</span><br><span class="line">    mov rdi, 1           ; 第一个参数为int fd</span><br><span class="line">    mov rsi, str         ; 第二个参数为char *buf</span><br><span class="line">    mov rdx, str_len     ; 第三个参数为size_t count</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov eax, 60          ; sys_exit的系统调用号</span><br><span class="line">    mov rdi, 0           ; 第一个参数为int status</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2018/08/31/Linux/tlpi_thread_bug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/31/Linux/tlpi_thread_bug/" class="post-title-link" itemprop="url">记 TLPI 上一个多线程代码例子的bug</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-08-31 13:15:31" itemprop="dateCreated datePublished" datetime="2018-08-31T13:15:31+00:00">2018-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ps:<code>TLPI</code> 是 <code>The Linux Programming Interface</code> 一书的缩写。</p>
<hr>
<p>今天试着跑 <code>TLPI</code> 第30章上一个程序的时候，老是运行时出bug。程序不是很难，主要是讲解 <code>pthread</code> 条件变量的使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> thread_died = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> thread_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> tot_threads = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num_live = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num_unjoined = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TS_ALIVE,</span><br><span class="line">    TS_TERMINATED,</span><br><span class="line">    TS_JOINED</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">tstate</span> <span class="title">state</span>;</span></span><br><span class="line">    <span class="type">int</span> sleep_time;</span><br><span class="line">&#125; *thread;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx = *((*<span class="type">int</span>)arg);</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    sleep(thread[idx].sleep_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %d terminating\n&quot;</span>, idx);</span><br><span class="line"></span><br><span class="line">    s = pthread_mutex_lock(&amp;thread_mutex);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    num_unjoined++;</span><br><span class="line">    thread[idx].state = TS_TERMINATED;</span><br><span class="line"></span><br><span class="line">    s = pthread_mutex_unlock(&amp;thread_mutex);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_cond_signal(&amp;thread_died);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_cond_signal&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s, idx;</span><br><span class="line"></span><br><span class="line">    thread = <span class="built_in">calloc</span>(argc - <span class="number">1</span>, <span class="keyword">sizeof</span>(*thread));</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>)</span><br><span class="line">        errExit(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; argc<span class="number">-1</span>; ++idx)</span><br><span class="line">    &#123;</span><br><span class="line">        thread[idx].sleep_time = getInt(argv[idx+<span class="number">1</span>], GN_NONNEG, <span class="literal">NULL</span>);</span><br><span class="line">        thread[idx].state = TS_ALIVE;</span><br><span class="line">        s = pthread_create(&amp;thread[idx].tid, <span class="literal">NULL</span>, thread_func, &amp;idx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tot_threads = argc - <span class="number">1</span>;</span><br><span class="line">    num_live = tot_threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (num_live &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = pthread_mutex_lock(&amp;thread_mutex);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num_unjoined == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = pthread_cond_wait(&amp;thread_died, &amp;thread_mutex);</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">                errExitEN(s, <span class="string">&quot;pthread_cond_wait&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; tot_threads; ++idx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (thread[idx].state == TS_TERMINATED)</span><br><span class="line">            &#123;</span><br><span class="line">                s = pthread_join(thread[idx].tid, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">                    errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line"></span><br><span class="line">                thread[idx].state = TS_JOINED;</span><br><span class="line">                num_live--;</span><br><span class="line">                num_unjoined--;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Reaped thread %d (num_live=%d)\n&quot;</span>, idx, num_live);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = pthread_mutex_unlock(&amp;thread_mutex);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后来我调试的时候，却往往能够正常运行，但运行时候的错误却很一致：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out 1 2 1</span><br><span class="line">Thread 3 terminating</span><br><span class="line">Thread 1 terminating</span><br><span class="line">Thread 2 terminating</span><br></pre></td></tr></table></figure>

<p>然后就卡死…</p>
<p>仔细观察过输出结果，这是每次创建的线程中输出的结果。程序首先通过一个循环创建线程，然后把下标传址给线程作为参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数中</span></span><br><span class="line"><span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; argc<span class="number">-1</span>; ++idx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    s = pthread_create(&amp;thread[idx].tid, <span class="literal">NULL</span>, thread_func, &amp;idx);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在线程中，每次都将对idx解引用，得到下标，并输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个新线程的函数中, arg是传进的参数</span></span><br><span class="line"><span class="type">int</span> idx = *((*<span class="type">int</span>)arg);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Thread %d terminating\n&quot;</span>, idx);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>可能大家也可以看出来了，妥妥的 <em>race condition</em>，多个线程通过指针访问同一个变量，没有进行同步和互斥的工作。有可能新的线程直到循环中的下标自增之后才执行解引用（实际上在我电脑上就是按照这个顺序执行了）。</p>
<p>比较简单的修改方法就是将<code>int</code>类型的下标直接强制转化成<code>void *</code>的类型的参数传值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在main函数里：</span></span><br><span class="line"><span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; argc<span class="number">-1</span>; ++idx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    s = pthread_create(&amp;thread[idx].tid, <span class="literal">NULL</span>, thread_func, (<span class="type">void</span>*)idx);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新线程的函数里</span></span><br><span class="line"><span class="type">int</span> idx = (<span class="type">int</span>)arg;</span><br></pre></td></tr></table></figure>

<p>这个改法看似简单，但其实有点问题。因为在C标准里整形和指针类型的强制转化是 <code>implementation-defined</code>。一下摘抄自<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/cast">cppreference</a>：</p>
<blockquote>
<p>Any integer can be cast to any pointer type. Except for the null pointer constants such as NULL (which doesn’t need a cast), the result is implementation-defined, may not be correctly aligned, may not point to an object of the referenced type, and may be a trap representation. </p>
</blockquote>
<blockquote>
<p>Any pointer type can be cast to any integer type. The result is implementation-defined, even for null pointer values (they do not necessarily result in the value zero). If the result cannot be represented in the target type, the behavior is undefined (unsigned integers do not implement modulo arithmetic on a cast from pointer) </p>
</blockquote>
<p>事实上，在64位x86上，指针类型占8字节，<code>int</code>类型占4字节，用脚趾头都知道它们之间的转化很不安全。</p>
<p>在 <a target="_blank" rel="noopener" href="http://www.man7.org/tlpi/errata/index.html">TLPI 官网上的勘误</a>中也提到了这个错误，上面还给了两种避免指针和整型转化的方法。</p>
<ul>
<li><p>一种解决方法是把当前 <code>thread[idx]</code> 地址传过去，这样只需进行不同指针的转化，这是C语言允许的。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = pthread_create(&amp;thread[idx].tid, <span class="literal">NULL</span>, threadFunc, &amp;thread[idx]);</span><br></pre></td></tr></table></figure>

<p>  然后线程的函数中只需要对传入的地址和首元素地址进行相减就能得到相应的下标：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tinfo</span> *<span class="title">tptr</span> =</span> arg;</span><br><span class="line"><span class="type">int</span> idx = tptr - thread;    <span class="comment">/* Obtain index in &#x27;thread&#x27; array */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>另一个解决方法就是用 <code>uintptr_t</code> 代替 <code>int</code> 类型。<code>unitptr_t</code> 类型是从C99标准开始有的类型，定义在头文件 <code>&lt;stdint.h&gt;</code> 中。它用来表示一个能够容纳指针值的无符号整型。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2018/08/23/Linux/LKD_syscall/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/23/Linux/LKD_syscall/" class="post-title-link" itemprop="url">《Linux内核设计与实现》读书笔记——系统调用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-08-23 13:15:31" itemprop="dateCreated datePublished" datetime="2018-08-23T13:15:31+00:00">2018-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><em>写在前面</em>：之前我粗略的整理过<code>linux</code>在IA32处理器上的系统调用的过程…这篇就当做补充和复习了。</p>
<hr>
<h2 id="与内核通信"><a href="#与内核通信" class="headerlink" title="与内核通信"></a>与内核通信</h2><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层。在Linux中，系统调用是用户空间访问内核的唯一手段：除了异常和陷入外，它们是内核唯一的合法入口。</p>
<h2 id="API、POSIX-和-C库"><a href="#API、POSIX-和-C库" class="headerlink" title="API、POSIX 和 C库"></a>API、POSIX 和 C库</h2><p>一般情况下，应用程序都是直接调用在用户空间实现的<code>API</code>来编程，而不是直接通过系统调用。这些API与系统调用也并非一一对应(甚至不使用系统调用)。举个简单的例子，应用程序调用C库中的<code>printf()</code>，C库中的<code>printf()</code>再调用C库中的<code>write()</code>，而C库中<code>write()</code>才调用内核提供的<code>write()</code>系统调用。</p>
<p>不难想到，通过一套标准来规范 API ，就能带来源码级的移植性。而在Unix世界里，<code>POSIX</code>标准最为流行。</p>
<p>在<code>Linux</code>中，C库实现了Unix系统的主要API，包括标准库规定的函数以及封装的系统调用接口。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>进行系统调用(<code>syscall</code>)，通常可以通过C库中的函数来完成。内核必须提供系统调用需要完成的功能，但是在实现上没有规定。这也是Unix哲学中的“<em>separating mechanism and policy</em>”。</p>
<p>举个例子，<code>getpid()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(getpid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> task_tpid_vnr(current);  <span class="comment">// return current-&gt;tgid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>SYSCALL_DEFINE0</code>是个宏，展开后代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>asmlinkage</code>是gcc的拓展，用于通知编译器仅从栈中提取该函数的参数。所有系统调用都有这个限定词。其次，函数返回<code>long</code>类型，为了保证32位和64位系统的兼容。系统调用在用户空间返回值类型为int，在内核空间返回值类型为long。最后，形如<code>sys_bar()</code>是在Linux中的命名规则。</p>
<h3 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h3><p>Linux中的每个系统调用被赋予一个系统调用号。用户态的进程通过这个号来指明进行哪个系统调用；进程不会提及系统调用的名称。</p>
<p>内核记录了系统调用表中所有已经注册的系统调用的列表，存储在<code>sys_call_table</code>中。</p>
<h3 id="系统调用的性能"><a href="#系统调用的性能" class="headerlink" title="系统调用的性能"></a>系统调用的性能</h3><p>Linux系统调用很快，一个原因是上下文切换快，进出内核被优化地简洁高效，另一个原因是系统调用处理程序和系统调用本身也十分简洁。</p>
<h2 id="系统调用处理程序"><a href="#系统调用处理程序" class="headerlink" title="系统调用处理程序"></a>系统调用处理程序</h2><p>应用程序通过软中断通知内核，告诉内核需要进行系统调用：引发一个异常来促使系统切换到内核态去执行异常处理程序。<code>x86</code>上系统预定义的软中断号是<code>128</code>，通过<code>int $0x80</code>指令触发该中断。这条指令会触发一个异常导致系统切换到内核态并执行第<code>128</code>号异常处理程序。而该程序正是系统调用处理程序，叫<code>system_call()</code>。它与硬件体系结构密切相关。最近，<code>x86</code>处理器增加了一条叫做<code>sysenter</code>的指令。与<code>int</code>指令相比，这条指令提供了更快，更专业的陷入内核进行系统调用的方式。</p>
<h3 id="制定恰当的系统调用"><a href="#制定恰当的系统调用" class="headerlink" title="制定恰当的系统调用"></a>制定恰当的系统调用</h3><p>在<code>x86</code>上系统调用号通过<code>eax</code>寄存器传递给内核。在陷入内核前，用户空间把相应的系统调用号放入<code>eax</code>中。其他体系结构上类似。</p>
<p><code>system_call()</code>通过将给定的系统调用号与<code>NR_syscalls</code>做比较来检查其有效性。如果它大于或等于<code>NR_syscalls</code>，该函数就返回<code>-ENOSYS</code>。否则，执行相应的系统调用：<code>call *sys_call_table(,%rax,8)</code>。</p>
<p>由于系统调用表中的表项是以64位(8字节)类型存放的，所以内核需要将给定的系统调用号乘以8。<code>x86-32</code>系统上，就用4代替8。</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>除了系统调用号外，大部分系统调用还需要一些外部的参数传入。在<code>x86-32</code>系统上，<code>ebx</code>，<code>ecx</code>，<code>edx</code>，<code>esi</code>按照顺序存放前5个参数。需要6个或者6个以上的情况不多见，此时应该用一个单独的寄存器存放指向这些参数在用户空间地址的指针。</p>
<p>给用户空间的返回值也通过寄存器传递。在x86系统上，它存放在<code>eax</code>寄存器中。</p>
<h2 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h2><p>一个Linux系统调用在实现时不需要太关心它的系统调用处理程序的关系，给linux添加一个系统调用相对容易。</p>
<h3 id="实现系统调用"><a href="#实现系统调用" class="headerlink" title="实现系统调用"></a>实现系统调用</h3><p>一个系统调用应该有明确的用途，不提倡通过传递不同的参数来选择完成不同的工作。<code>ioctl()</code>就是一个反面例子。还要求时刻注意可移植性和健壮性。</p>
<h3 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h3><p>系统调用必须验证它们所有的参数是否合法有效。系统调用在内核空间执行，如果任由用户将不合法的输入传递个内核，那么安全性和稳定性将没有保障。</p>
<p>最重要的一种检查就是指针是否有效。内核必须保证：</p>
<ul>
<li>指针指向的内存区域属于用户空间。</li>
<li>指针指向的内存区域在进程的地址空间内。</li>
<li>如果是读，该内存应被标记为可读；如果是写，该内存应被标记为可写；如果是可执行，该内存应被标记为可执行。</li>
</ul>
<p>内核提供了两个方法用于完成必须的检查和内核空间与用户空间数据的来回拷贝。</p>
<ul>
<li><p><code>copy_to_user()</code>，向用户空间写入数据，需要三个参数。第一个是进程空间中的目的内存地址，第二个是内核空间中的源地址，最后一个是字节数。</p>
</li>
<li><p><code>copy-from_user()</code>，从用户空间读数据。它的三个参数和<code>copy_to_user()</code>类似。</p>
</li>
</ul>
<p>如果执行失败，这两个函数返回的都是没能完成拷贝的数据字节数；如果成功，返回0。当出现上述错误，系统调用返回标准<code>-EFAULT</code>。注意，这两个函数都有可能引起阻塞，当缺页的时候。</p>
<p>最后一项检查针对是否有合法权限。调用者可以通过<code>capable()</code>函数来检查是否有权能对制定的资源进行操作。如果返回非0就有权，否则无权。</p>
<h2 id="系统调用上下文"><a href="#系统调用上下文" class="headerlink" title="系统调用上下文"></a>系统调用上下文</h2><p>内核在执行系统调用的时候处于进程上下文，<code>current</code>指针指向当前任务。</p>
<p>在进程上下文中，内核可以休眠并且可以被抢占。当系统调用返回的时候，控制权仍在<code>system_call()</code>中，它最终会负责切换到用户空间，并让用户进程继续执行下去。</p>
<h3 id="绑定一个系统调用的最后一个步骤"><a href="#绑定一个系统调用的最后一个步骤" class="headerlink" title="绑定一个系统调用的最后一个步骤"></a>绑定一个系统调用的最后一个步骤</h3><p>当编写完一个系统调用后，把它注册成一个正式的系统调用：</p>
<ul>
<li>首先，在系统调用表的最后一项加入一个表项。</li>
<li>对于所支持的各种体系结构，系统调用号必须定义于<code>&lt;asm/unistd.h&gt;</code>中。</li>
<li>系统调用必须被编译进内核映像。这只要把它放进<code>kernel/</code>下的一个相关文件中就可以了，如<code>sys.c</code>，它包含了各种各样的系统调用。</li>
</ul>
<h3 id="从用户空间访问系统调用"><a href="#从用户空间访问系统调用" class="headerlink" title="从用户空间访问系统调用"></a>从用户空间访问系统调用</h3><p>通常，系统调用靠C库支持。用户程序通过包含头文件并和C库链接，就可以使用系统调用。但如果你如果仅仅写出了系统调用，glibc并不提供支持。可以通过Linux本身提供的一组宏，直接对系统调用进行访问。这些宏是<code>_syscalln()</code>，n的范围从0到6，代表需要传递给系统调用的参数个数。对于每个宏，都有<code>2+2×n</code>个参数。第一个参数表示返回值类型，第二个参数是系统调用的名称，接着是按照系统调用参数顺序排列的每个参数的类型和名称。</p>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于 long open(const char *filename, int flags, int mode)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_open 5</span></span><br><span class="line">_syscall3(<span class="type">long</span>, open, <span class="type">const</span> <span class="type">char</span> *, filename, <span class="type">int</span>, flags, <span class="type">int</span>, mode)</span><br></pre></td></tr></table></figure>

<p>这组宏会被拓展成内嵌汇编的C函数。</p>
<h2 id="为什么不通过建立系统调用的方式实现"><a href="#为什么不通过建立系统调用的方式实现" class="headerlink" title="为什么不通过建立系统调用的方式实现"></a>为什么不通过建立系统调用的方式实现</h2><p>Linux系统尽量避免没出现一种新的抽象就加入一个新的系统调用，这使得它的系统调用接口十分简洁。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yiyang Chen</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/cyyzero" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"cyyzero","repo":"cyyzero.github.io","client_id":"1185801249b8bbce5127","client_secret":"fbbb24c3e0613419f2505f94baa921f61606bac1","admin_user":"cyyzero","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"d1546d731a9f30cc80127d57142a482b"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
