<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eden</title>
  
  
  <link href="http://cyyzero.github.io/atom.xml" rel="self"/>
  
  <link href="http://cyyzero.github.io/"/>
  <updated>2023-10-29T08:06:58.911Z</updated>
  <id>http://cyyzero.github.io/</id>
  
  <author>
    <name>Yiyang Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>overlayfs挂载选项volatile</title>
    <link href="http://cyyzero.github.io/2023/10/29/Linux/overlayfs_volatile_option/"/>
    <id>http://cyyzero.github.io/2023/10/29/Linux/overlayfs_volatile_option/</id>
    <published>2023-10-29T15:19:23.000Z</published>
    <updated>2023-10-29T08:06:58.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>最近在公司遇到了容器相关的线上问题, 简单来说就是K8s会出现PLEG not healthy的报错. 经过初步的排查, 发现是docker有个goroutine卡在了<code>umount</code>, 同时这个这个groutine会占用某个锁, 导致查询状态的handler里拿不到锁, 最终导致k8s层面的报错.</p><p>通过对umount事件的监控, 以及相关源码代码的阅读, 发现是overlayfs在umount的时候, 会对upper层所在的fs进行一次sync, 导致大量脏页回写. 如果这个机器内存较大, 并且有过频繁的IO, 那么就会脏页较多, overlayfs umount时等待磁盘IO完成而阻塞过久.</p><p>umount的stack trace如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[&lt;0&gt;] wb_wait_for_completion+0x5a/0x90</span><br><span class="line">[&lt;0&gt;] __writeback_inodes_sb_nr+0xa0/0xd0</span><br><span class="line">[&lt;0&gt;] writeback_inodes_sb+0x3d/0x50</span><br><span class="line">[&lt;0&gt;] _sync_filesystem+0x55/0x60</span><br><span class="line">[&lt;0&gt;] sync_filesystem+0x33/0x50</span><br><span class="line">[&lt;0&gt;] ovl_sync_fs+0x61/0xa0 [overlay]</span><br><span class="line">[&lt;0&gt;] _sync_filesystem+0x33/0x60</span><br><span class="line">[&lt;0&gt;] sync_filesystem+0x44/0x50</span><br><span class="line">[&lt;0&gt;] generic_shutdown_super+0x27/0x120</span><br><span class="line">[&lt;0&gt;] kill_anon_super+0x18/0x30</span><br><span class="line">[&lt;0&gt;] deactivate_locked_super+0x3b/0x90</span><br><span class="line">[&lt;0&gt;] deactivate_super+0x42/0x50</span><br><span class="line">[&lt;0&gt;] cleanup_mnt+0x109/0x170</span><br><span class="line">[&lt;0&gt;] _cleanup_mnt+0x12/0x20</span><br><span class="line">[&lt;0&gt;] task_work_run+0x70/0xb0</span><br><span class="line">[&lt;0&gt;] exit_to_user_mode_prepare+0x1b6/0x1c0</span><br><span class="line">[&lt;0&gt;] syscall_exit_to_user_mode+0x27/0x50</span><br><span class="line">[&lt;0&gt;] do_syscall_64+0x69/0xc0</span><br><span class="line">[&lt;0&gt;] entry_SYSCALL_64_after_hwframe+0x61/0xcb</span><br></pre></td></tr></table></figure><p>重点在这个<code>ovl_sync_fs</code>函数, 它会对整个overlayfs的uppser层所在文件系统进行sync操作: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from kernel 5.10</span></span><br><span class="line"><span class="comment">/* Sync real dirty inodes in upper filesystem (if it exists) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ovl_sync_fs</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="type">int</span> wait)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ovl_fs</span> *<span class="title">ofs</span> =</span> sb-&gt;s_fs_info;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">upper_sb</span>;</span></span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ovl_upper_mnt(ofs))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ovl_should_sync(ofs))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Not called for sync(2) call or an emergency sync (SB_I_SKIP_SYNC).</span></span><br><span class="line"><span class="comment">         * All the super blocks will be iterated, including upper_sb.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If this is a syncfs(2) call, then we do need to call</span></span><br><span class="line"><span class="comment">         * sync_filesystem() on upper_sb, but enough if we do it when being</span></span><br><span class="line"><span class="comment">         * called with wait == 1.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!wait)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到upper层所在的fs</span></span><br><span class="line">        upper_sb = ovl_upper_mnt(ofs)-&gt;mnt_sb;</span><br><span class="line"></span><br><span class="line">        down_read(&amp;upper_sb-&gt;s_umount);</span><br><span class="line">        <span class="comment">// 执行sync, 会造成整个fs脏页回写磁盘, 耗时很长</span></span><br><span class="line">        ret = sync_filesystem(upper_sb);</span><br><span class="line">        up_read(&amp;upper_sb-&gt;s_umount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然, 对于k8s的很多场景来说, sync文件系统是多余的操作. k8s每次实例启动都重新挂载rootfs, 实例退出后将rootfs umount并删除(可能描述的不对). 所以最好有办法能够避免overlayfs umount时候的强制刷盘.</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>如果仔细查看<code>ovl_sync_fs</code>函数, 可以发现它会在函数开头执行两个判断, 一次是判断upper层是否存在, 一次是<code>ovl_should_sync</code>判断overlayfs是否应该进行sync. 解决问题的关键可能就在于ovl_should_sync能否绕过sync.</p><h2 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h2><p>ovl_should_sync函数被包含在2020.8.31提的patch里</p><p><a href="https://lore.kernel.org/all/20200722175024.GA608248@redhat.com/">[PATCH v5] overlayfs: Provide a mount option “ volatile” to skip sync - Vivek Goyal</a></p><p>这个patch给overlayfs提供了一个新的挂载选项volatile, 当挂载这个选项后, overlayfs会去掉一些sync操作, 包括针对单独文件的sync以及整个文件系统的sync.</p><p>影响的地方如下: </p><ol><li><p>umount不会再强制对upper层文件系统执行sync, 也就是针对本次问题出现的场景.</p></li><li><p>remount的时候, 也可能对upper层所在文件系统进行sync, 这是2020年加内核主线的patch.<br><a href="https://www.spinics.net/lists/linux-unionfs/msg07682.html">[PATCH] ovl: sync dirty data when remounting to ro mode ‒ Union Filesystem</a><br>这是因为把overlayfs remount成只读之后, 在umount overlayfs时,<code>kill_anon_super</code> -&gt; <code>generic_shutdown_super</code> -&gt; <code>sync_filesystem</code>检查overlayfs为只读时会跳过sync_filesystem. 所以把overlayfs从可写remount成只读的时候, 直接进行一次sync_filesystem, 避免最终umount的时候遗漏sync_filesystem操作. volatile选项会取消这一次sync_filesystem操作.</p></li><li><p>针对单个文件fsync调用, 如果带有volatile挂载选项, 会跳过.</p></li><li><p>当文件copy up到upper层的时候, 也会进行vfs_fsync()操作. 如果带有volatile选项, 会跳过.</p></li><li><p>O_SYNC的场景, 如果有volatile选项, 也会绕过sync退化成overlayfs默认的写行为.</p></li></ol><p><strong>本质上这些sync操作都是为了避免系统crash造成overlayfs磁盘数据丢失. volatile挂载选项和Kubernetes的使用场景十分契合. 如果内核在向overlayfs写入数据时崩溃, kubelet总是会重新创建新的容器, 而不会复用之前的rootfs. 因此，在 kubernetes中, 容器的rootfs是临时的. 在pod中使用 volatile 选项是安全的, 因为我们没有机会重复使用旧的rootfs. 在有状态容器中使用这种配置也是安全的, 因为需要持久化的数据理应写入外部卷, 在运行时不会受到volatile标志的影响.</strong></p><h2 id="contianerd"><a href="#contianerd" class="headerlink" title="contianerd"></a>contianerd</h2><p>当然, 新的挂载选项需要runtime的支持, 才能够在挂载rootfs带上这个选项.</p><p>在contaienrd社区已经有了许多相关讨论:</p><ul><li><a href="https://github.com/containerd/containerd/issues/8698">https://github.com/containerd/containerd/issues/8698</a></li><li><a href="https://github.com/containerd/containerd/issues/6406">https://github.com/containerd/containerd/issues/6406</a></li><li><a href="https://github.com/containerd/containerd/pull/4785">https://github.com/containerd/containerd/pull/4785</a></li><li><a href="https://github.com/containerd/containerd/pull/8402">https://github.com/containerd/containerd/pull/8402</a></li><li><a href="https://github.com/containerd/containerd/pull/8676">https://github.com/containerd/containerd/pull/8676</a></li></ul><p>这个pr <a href="https://github.com/containerd/containerd/pull/8676">[overlay] add configurable mount options to overlay snapshotter by dmcgowan · Pull Request #8676</a> 允许对overlayfs的挂载选项进行设置, 并且被backport到了1.6.24.</p><h2 id="requirements"><a href="#requirements" class="headerlink" title="requirements"></a>requirements</h2><p>总结一下, overlayfs volatile特性, 需要的版本如下:</p><ul><li>Linux kernel &gt;&#x3D; 5.10<br>对应patch: <a href="https://lore.kernel.org/all/20200722175024.GA608248@redhat.com/">[PATCH] ovl: sync dirty data when remounting to ro mode ‒ Union Filesystem</a></li><li>containerd &gt;&#x3D; 1.6.24 or containerd &gt;&#x3D; 1.7.4<br>对应PR: <a href="https://github.com/containerd/containerd/pull/8676">[overlay] add configurable mount options to overlay snapshotter by dmcgowan · Pull Request #8676</a></li></ul><p>containerd配置:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/containerd/config.toml</span></span><br><span class="line"><span class="attr">version</span> = <span class="number">2</span></span><br><span class="line"><span class="section">[plugins]</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.snapshotter.v1.overlayfs&quot;]</span></span><br><span class="line">    <span class="attr">mount_options</span> = [<span class="string">&quot;volatile&quot;</span>]</span><br></pre></td></tr></table></figure><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ol><li><a href="https://lore.kernel.org/all/20200722175024.GA608248@redhat.com/">https:&#x2F;&#x2F;lore.kernel.org&#x2F;all&#x2F;20200722175024.GA608248@redhat.com/</a></li><li><a href="https://github.com/containerd/containerd/pull/8676">https://github.com/containerd/containerd/pull/8676</a></li><li><a href="https://fuweid.com/post/2023-08-sync-containerd-issue/">https://fuweid.com/post/2023-08-sync-containerd-issue/</a></li><li><a href="https://www.redhat.com/sysadmin/container-volatile-overlay-mounts">https://www.redhat.com/sysadmin/container-volatile-overlay-mounts</a></li><li><a href="https://docs.kernel.org/filesystems/overlayfs.html#volatile-mount">https://docs.kernel.org/filesystems/overlayfs.html#volatile-mount</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;最近在公司遇到了容器相关的线上问题, 简单来说就是K8s会出现PLEG not healthy的报错. 经过初步的排查, 发现是docker</summary>
      
    
    
    
    <category term="Linux" scheme="http://cyyzero.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>ext4文件系统默认挂载选项</title>
    <link href="http://cyyzero.github.io/2023/07/29/Linux/Ext4_mount_default_opts/"/>
    <id>http://cyyzero.github.io/2023/07/29/Linux/Ext4_mount_default_opts/</id>
    <published>2023-07-29T17:08:29.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在<a href="https://www.kernel.org/doc/html/v4.19/filesystems/ext4/ext4.html#options">Ext4的官方文档</a>里，可以看到有很多挂载的选项，并且有一些被标记为了默认，比如<code>delalloc</code>。但是通过<code>procfs</code>的<code>/proc/mounts</code>并没有看到这些默认的选项，比如<code>delalloc</code>（有个<code>nodelalloc</code>的disable delalloc选项，这两个是非此即彼的关系，却都没有出现）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/mounts| grep ext4</span><br><span class="line">/dev/sdb / ext4 rw,relatime,discard,errors=remount-ro,data=ordered 0 0</span><br></pre></td></tr></table></figure><p>而对于另一个文件系统相关的文件里，却能够看到这些完整的选项：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/fs/ext4/sdb/options    </span><br><span class="line">rw</span><br><span class="line">bsddf</span><br><span class="line">nogrpid</span><br><span class="line">block_validity</span><br><span class="line">dioread_nolock</span><br><span class="line">discard</span><br><span class="line">delalloc</span><br><span class="line">nowarn_on_error</span><br><span class="line">journal_checksum</span><br><span class="line">barrier</span><br><span class="line">auto_da_alloc</span><br><span class="line">user_xattr</span><br><span class="line">acl</span><br><span class="line">noquota</span><br><span class="line">resuid=0</span><br><span class="line">resgid=0</span><br><span class="line">errors=remount-ro</span><br><span class="line">commit=5</span><br><span class="line">min_batch_time=0</span><br><span class="line">max_batch_time=15000</span><br><span class="line">stripe=0</span><br><span class="line">data=ordered</span><br><span class="line">inode_readahead_blks=32</span><br><span class="line">init_itable=10</span><br><span class="line">max_dir_size_kb=0</span><br></pre></td></tr></table></figure><p>带着这个问题，基于6.1.36内核源码，梳理了文件系统如何通过<code>procfs</code>来展示挂载信息，并且在创建和挂载文件系统时如何处理挂载选项。</p><h2 id="procfs的数据"><a href="#procfs的数据" class="headerlink" title="procfs的数据"></a>procfs的数据</h2><h3 id="proc-pid-mounts"><a href="#proc-pid-mounts" class="headerlink" title="&#x2F;proc&#x2F;{pid}&#x2F;mounts"></a>&#x2F;proc&#x2F;{pid}&#x2F;mounts</h3><p>由于有了mount namespace，系统挂载点可以在各个进程之间相互隔离，不再是全局一致。所以<code>/proc/mounts</code>其实是指向<code>/proc/self/mounts</code>的符号链接。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /proc/mounts</span><br><span class="line">lrwxrwxrwx 1 root root 11 Jul 30 05:31 /proc/mounts -&gt; self/mounts</span><br></pre></td></tr></table></figure><p>展示的函数是<code>show_vfsmnt</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/proc_namespace.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">show_vfsmnt</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_mounts</span> *<span class="title">p</span> =</span> m-&gt;private;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">r</span> =</span> real_mount(mnt);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">mnt_path</span> =</span> &#123; .dentry = mnt-&gt;mnt_root, .mnt = mnt &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> mnt_path.dentry-&gt;d_sb;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sb-&gt;s_op-&gt;show_devname) &#123;</span><br><span class="line">err = sb-&gt;s_op-&gt;show_devname(m, mnt_path.dentry);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mangle(m, r-&gt;mnt_devname ? r-&gt;mnt_devname : <span class="string">&quot;none&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">seq_putc(m, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="comment">/* mountpoints outside of chroot jail will give SEQ_SKIP on this */</span></span><br><span class="line">err = seq_path_root(m, &amp;mnt_path, &amp;p-&gt;root, <span class="string">&quot; \t\n\\&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">seq_putc(m, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">show_type(m, sb);</span><br><span class="line">seq_puts(m, __mnt_is_readonly(mnt) ? <span class="string">&quot; ro&quot;</span> : <span class="string">&quot; rw&quot;</span>);</span><br><span class="line">err = show_sb_opts(m, sb);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">show_mnt_opts(m, mnt);</span><br><span class="line"><span class="keyword">if</span> (sb-&gt;s_op-&gt;show_options)</span><br><span class="line">err = sb-&gt;s_op-&gt;show_options(m, mnt_path.dentry);</span><br><span class="line">seq_puts(m, <span class="string">&quot; 0 0\n&quot;</span>);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中主要有三个函数输出了options，<code>show_sb_opts()</code>和<code>show_mnt_opts()</code>，还有<code>sb-&gt;s_op-&gt;show_options</code>，其中<code>show_sb_opts()</code>和<code>show_mnt_opts</code>打印的是vfs层面通用的一些选项，比较少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/proc_namespace.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">show_sb_opts</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> super_block *sb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_fs_opts</span> <span class="title">fs_opts</span>[] =</span> &#123;</span><br><span class="line">&#123; SB_SYNCHRONOUS, <span class="string">&quot;,sync&quot;</span> &#125;,</span><br><span class="line">&#123; SB_DIRSYNC, <span class="string">&quot;,dirsync&quot;</span> &#125;,</span><br><span class="line">&#123; SB_MANDLOCK, <span class="string">&quot;,mand&quot;</span> &#125;,</span><br><span class="line">&#123; SB_LAZYTIME, <span class="string">&quot;,lazytime&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="number">0</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_fs_opts</span> *<span class="title">fs_infop</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (fs_infop = fs_opts; fs_infop-&gt;flag; fs_infop++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sb-&gt;s_flags &amp; fs_infop-&gt;flag)</span><br><span class="line">seq_puts(m, fs_infop-&gt;str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> security_sb_show_options(m, sb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_mnt_opts</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_fs_opts</span> <span class="title">mnt_opts</span>[] =</span> &#123;</span><br><span class="line">&#123; MNT_NOSUID, <span class="string">&quot;,nosuid&quot;</span> &#125;,</span><br><span class="line">&#123; MNT_NODEV, <span class="string">&quot;,nodev&quot;</span> &#125;,</span><br><span class="line">&#123; MNT_NOEXEC, <span class="string">&quot;,noexec&quot;</span> &#125;,</span><br><span class="line">&#123; MNT_NOATIME, <span class="string">&quot;,noatime&quot;</span> &#125;,</span><br><span class="line">&#123; MNT_NODIRATIME, <span class="string">&quot;,nodiratime&quot;</span> &#125;,</span><br><span class="line">&#123; MNT_RELATIME, <span class="string">&quot;,relatime&quot;</span> &#125;,</span><br><span class="line">&#123; MNT_NOSYMFOLLOW, <span class="string">&quot;,nosymfollow&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="number">0</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_fs_opts</span> *<span class="title">fs_infop</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (fs_infop = mnt_opts; fs_infop-&gt;flag; fs_infop++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mnt-&gt;mnt_flags &amp; fs_infop-&gt;flag)</span><br><span class="line">seq_puts(m, fs_infop-&gt;str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mnt_user_ns(mnt) != &amp;init_user_ns)</span><br><span class="line">seq_puts(m, <span class="string">&quot;,idmapped&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>sb-&gt;s_op-&gt;show_options</code>，对于<code>ext4</code>文件系统来说，是<code>_ext4_show_options</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/ext4/super.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">ext4_sops</span> =</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">.show_options= ext4_show_options,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ext4_show_options</span><span class="params">(<span class="keyword">struct</span> seq_file *seq, <span class="keyword">struct</span> dentry *root)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ext4_show_options(seq, root-&gt;d_sb, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Show an option if</span></span><br><span class="line"><span class="comment"> *  - it&#x27;s set to a non-default value OR</span></span><br><span class="line"><span class="comment"> *  - if the per-sb default is different from the global default</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _ext4_show_options(<span class="keyword">struct</span> seq_file *seq, <span class="keyword">struct</span> super_block *sb,</span><br><span class="line">      <span class="type">int</span> nodefs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_sb_info</span> *<span class="title">sbi</span> =</span> EXT4_SB(sb);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_super_block</span> *<span class="title">es</span> =</span> sbi-&gt;s_es;</span><br><span class="line"><span class="type">int</span> def_errors, def_mount_opt = sbi-&gt;s_def_mount_opt;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mount_opts</span> *<span class="title">m</span>;</span></span><br><span class="line"><span class="type">char</span> sep = nodefs ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEQ_OPTS_PUTS(str) seq_printf(seq, <span class="string">&quot;%c&quot;</span> str, sep)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEQ_OPTS_PRINT(str, arg) seq_printf(seq, <span class="string">&quot;%c&quot;</span> str, sep, arg)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sbi-&gt;s_sb_block != <span class="number">1</span>)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;sb=%llu&quot;</span>, sbi-&gt;s_sb_block);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (m = ext4_mount_opts; m-&gt;token != Opt_err; m++) &#123;</span><br><span class="line"><span class="type">int</span> want_set = m-&gt;flags &amp; MOPT_SET;</span><br><span class="line"><span class="keyword">if</span> (((m-&gt;flags &amp; (MOPT_SET|MOPT_CLEAR)) == <span class="number">0</span>) ||</span><br><span class="line">    (m-&gt;flags &amp; MOPT_CLEAR_ERR) || m-&gt;flags &amp; MOPT_SKIP)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!nodefs &amp;&amp; !(m-&gt;mount_opt &amp; (sbi-&gt;s_mount_opt ^ def_mount_opt)))</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">/* skip if same as the default */</span></span><br><span class="line"><span class="keyword">if</span> ((want_set &amp;&amp;</span><br><span class="line">     (sbi-&gt;s_mount_opt &amp; m-&gt;mount_opt) != m-&gt;mount_opt) ||</span><br><span class="line">    (!want_set &amp;&amp; (sbi-&gt;s_mount_opt &amp; m-&gt;mount_opt)))</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">/* select Opt_noFoo vs Opt_Foo */</span></span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;%s&quot;</span>, token2str(m-&gt;token));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nodefs || !uid_eq(sbi-&gt;s_resuid, make_kuid(&amp;init_user_ns, EXT4_DEF_RESUID)) ||</span><br><span class="line">    le16_to_cpu(es-&gt;s_def_resuid) != EXT4_DEF_RESUID)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;resuid=%u&quot;</span>,</span><br><span class="line">from_kuid_munged(&amp;init_user_ns, sbi-&gt;s_resuid));</span><br><span class="line"><span class="keyword">if</span> (nodefs || !gid_eq(sbi-&gt;s_resgid, make_kgid(&amp;init_user_ns, EXT4_DEF_RESGID)) ||</span><br><span class="line">    le16_to_cpu(es-&gt;s_def_resgid) != EXT4_DEF_RESGID)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;resgid=%u&quot;</span>,</span><br><span class="line">from_kgid_munged(&amp;init_user_ns, sbi-&gt;s_resgid));</span><br><span class="line">def_errors = nodefs ? <span class="number">-1</span> : le16_to_cpu(es-&gt;s_errors);</span><br><span class="line"><span class="keyword">if</span> (test_opt(sb, ERRORS_RO) &amp;&amp; def_errors != EXT4_ERRORS_RO)</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;errors=remount-ro&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (test_opt(sb, ERRORS_CONT) &amp;&amp; def_errors != EXT4_ERRORS_CONTINUE)</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;errors=continue&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (test_opt(sb, ERRORS_PANIC) &amp;&amp; def_errors != EXT4_ERRORS_PANIC)</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;errors=panic&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (nodefs || sbi-&gt;s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;commit=%lu&quot;</span>, sbi-&gt;s_commit_interval / HZ);</span><br><span class="line"><span class="keyword">if</span> (nodefs || sbi-&gt;s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;min_batch_time=%u&quot;</span>, sbi-&gt;s_min_batch_time);</span><br><span class="line"><span class="keyword">if</span> (nodefs || sbi-&gt;s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;max_batch_time=%u&quot;</span>, sbi-&gt;s_max_batch_time);</span><br><span class="line"><span class="keyword">if</span> (sb-&gt;s_flags &amp; SB_I_VERSION)</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;i_version&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (nodefs || sbi-&gt;s_stripe)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;stripe=%lu&quot;</span>, sbi-&gt;s_stripe);</span><br><span class="line"><span class="keyword">if</span> (nodefs || EXT4_MOUNT_DATA_FLAGS &amp;</span><br><span class="line">(sbi-&gt;s_mount_opt ^ def_mount_opt)) &#123;</span><br><span class="line"><span class="keyword">if</span> (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;data=journal&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;data=ordered&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;data=writeback&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nodefs ||</span><br><span class="line">    sbi-&gt;s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;inode_readahead_blks=%u&quot;</span>,</span><br><span class="line">       sbi-&gt;s_inode_readahead_blks);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test_opt(sb, INIT_INODE_TABLE) &amp;&amp; (nodefs ||</span><br><span class="line">       (sbi-&gt;s_li_wait_mult != EXT4_DEF_LI_WAIT_MULT)))</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;init_itable=%u&quot;</span>, sbi-&gt;s_li_wait_mult);</span><br><span class="line"><span class="keyword">if</span> (nodefs || sbi-&gt;s_max_dir_size_kb)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;max_dir_size_kb=%u&quot;</span>, sbi-&gt;s_max_dir_size_kb);</span><br><span class="line"><span class="keyword">if</span> (test_opt(sb, DATA_ERR_ABORT))</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;data_err=abort&quot;</span>);</span><br><span class="line"></span><br><span class="line">fscrypt_show_test_dummy_encryption(seq, sep, sb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sb-&gt;s_flags &amp; SB_INLINECRYPT)</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;inlinecrypt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test_opt(sb, DAX_ALWAYS)) &#123;</span><br><span class="line"><span class="keyword">if</span> (IS_EXT2_SB(sb))</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;dax&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;dax=always&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (test_opt2(sb, DAX_NEVER)) &#123;</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;dax=never&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (test_opt2(sb, DAX_INODE)) &#123;</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;dax=inode&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">ext4_show_quota_options(seq, sb);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="proc-fs-ext4-device-options"><a href="#proc-fs-ext4-device-options" class="headerlink" title="&#x2F;proc&#x2F;fs&#x2F;ext4&#x2F;{device}&#x2F;options"></a>&#x2F;proc&#x2F;fs&#x2F;ext4&#x2F;{device}&#x2F;options</h3><p>在ext4文件系统被挂载的时候，会在<code>__ext4_fill_super()</code>里调用<code>ext4_register_sysfs()</code>来注册procfs的条目：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/ext4/sysfs.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ext4_register_sysfs</span><span class="params">(<span class="keyword">struct</span> super_block *sb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (sbi-&gt;s_proc) &#123;</span><br><span class="line">proc_create_single_data(<span class="string">&quot;options&quot;</span>, S_IRUGO, sbi-&gt;s_proc,</span><br><span class="line">ext4_seq_options_show, sb);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展示数据的函数为<code>ext4_seq_options_show()</code>，最终也是调用了<code>_ext4_show_options()</code>，不过最后一个参数<code>nodefs</code>为1，导致和<code>/proc/&#123;pid&#125;/mounts</code>的输出不一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/ext4/super.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ext4_seq_options_show</span><span class="params">(<span class="keyword">struct</span> seq_file *seq, <span class="type">void</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> seq-&gt;private;</span><br><span class="line"><span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">seq_puts(seq, sb_rdonly(sb) ? <span class="string">&quot;ro&quot;</span> : <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">rc = _ext4_show_options(seq, sb, <span class="number">1</span>);</span><br><span class="line">seq_puts(seq, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，导致差异的点有两个，一个是导致sep为’,’还是’\n’；另一个是nodefs为0的情况下，会省略一些选项的输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _ext4_show_options(<span class="keyword">struct</span> seq_file *seq, <span class="keyword">struct</span> super_block *sb,</span><br><span class="line">      <span class="type">int</span> nodefs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_sb_info</span> *<span class="title">sbi</span> =</span> EXT4_SB(sb);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_super_block</span> *<span class="title">es</span> =</span> sbi-&gt;s_es;</span><br><span class="line"><span class="type">int</span> def_errors, def_mount_opt = sbi-&gt;s_def_mount_opt;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mount_opts</span> *<span class="title">m</span>;</span></span><br><span class="line"><span class="type">char</span> sep = nodefs ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sbi-&gt;s_sb_block != <span class="number">1</span>)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;sb=%llu&quot;</span>, sbi-&gt;s_sb_block);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (m = ext4_mount_opts; m-&gt;token != Opt_err; m++) &#123;</span><br><span class="line"><span class="type">int</span> want_set = m-&gt;flags &amp; MOPT_SET;</span><br><span class="line"><span class="keyword">if</span> (((m-&gt;flags &amp; (MOPT_SET|MOPT_CLEAR)) == <span class="number">0</span>) ||</span><br><span class="line">    m-&gt;flags &amp; MOPT_SKIP)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!nodefs &amp;&amp; !(m-&gt;mount_opt &amp; (sbi-&gt;s_mount_opt ^ def_mount_opt)))</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">/* skip if same as the default */</span></span><br><span class="line"><span class="keyword">if</span> ((want_set &amp;&amp;</span><br><span class="line">     (sbi-&gt;s_mount_opt &amp; m-&gt;mount_opt) != m-&gt;mount_opt) ||</span><br><span class="line">    (!want_set &amp;&amp; (sbi-&gt;s_mount_opt &amp; m-&gt;mount_opt)))</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">/* select Opt_noFoo vs Opt_Foo */</span></span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;%s&quot;</span>, token2str(m-&gt;token));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nodefs || !uid_eq(sbi-&gt;s_resuid, make_kuid(&amp;init_user_ns, EXT4_DEF_RESUID)) ||</span><br><span class="line">    le16_to_cpu(es-&gt;s_def_resuid) != EXT4_DEF_RESUID)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;resuid=%u&quot;</span>,</span><br><span class="line">from_kuid_munged(&amp;init_user_ns, sbi-&gt;s_resuid));</span><br><span class="line"><span class="keyword">if</span> (nodefs || !gid_eq(sbi-&gt;s_resgid, make_kgid(&amp;init_user_ns, EXT4_DEF_RESGID)) ||</span><br><span class="line">    le16_to_cpu(es-&gt;s_def_resgid) != EXT4_DEF_RESGID)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;resgid=%u&quot;</span>,</span><br><span class="line">from_kgid_munged(&amp;init_user_ns, sbi-&gt;s_resgid));</span><br><span class="line">def_errors = nodefs ? <span class="number">-1</span> : le16_to_cpu(es-&gt;s_errors);</span><br><span class="line"><span class="keyword">if</span> (test_opt(sb, ERRORS_RO) &amp;&amp; def_errors != EXT4_ERRORS_RO)</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;errors=remount-ro&quot;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (nodefs || sbi-&gt;s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;commit=%lu&quot;</span>, sbi-&gt;s_commit_interval / HZ);</span><br><span class="line"><span class="keyword">if</span> (nodefs || sbi-&gt;s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;min_batch_time=%u&quot;</span>, sbi-&gt;s_min_batch_time);</span><br><span class="line"><span class="keyword">if</span> (nodefs || sbi-&gt;s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;max_batch_time=%u&quot;</span>, sbi-&gt;s_max_batch_time);</span><br><span class="line"><span class="keyword">if</span> (nodefs || sbi-&gt;s_stripe)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;stripe=%lu&quot;</span>, sbi-&gt;s_stripe);</span><br><span class="line"><span class="keyword">if</span> (nodefs || EXT4_MOUNT_DATA_FLAGS &amp;</span><br><span class="line">(sbi-&gt;s_mount_opt ^ def_mount_opt)) &#123;</span><br><span class="line"><span class="keyword">if</span> (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;data=journal&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;data=ordered&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)</span><br><span class="line">SEQ_OPTS_PUTS(<span class="string">&quot;data=writeback&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nodefs ||</span><br><span class="line">    sbi-&gt;s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;inode_readahead_blks=%u&quot;</span>,</span><br><span class="line">       sbi-&gt;s_inode_readahead_blks);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test_opt(sb, INIT_INODE_TABLE) &amp;&amp; (nodefs ||</span><br><span class="line">       (sbi-&gt;s_li_wait_mult != EXT4_DEF_LI_WAIT_MULT)))</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;init_itable=%u&quot;</span>, sbi-&gt;s_li_wait_mult);</span><br><span class="line"><span class="keyword">if</span> (nodefs || sbi-&gt;s_max_dir_size_kb)</span><br><span class="line">SEQ_OPTS_PRINT(<span class="string">&quot;max_dir_size_kb=%u&quot;</span>, sbi-&gt;s_max_dir_size_kb);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来起来主要就是nodefs为1和0的两种情况导致输出不一致。可以看到这段逻辑，如果是default的options，并且nodefs为0，就跳过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!nodefs &amp;&amp; !(m-&gt;mount_opt &amp; (sbi-&gt;s_mount_opt ^ def_mount_opt)))</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">/* skip if same as the default */</span></span><br></pre></td></tr></table></figure><p>这里default_options应该就是文档里描述的那些。我先入为主的以为这个就是磁盘上super_block的s_default_opts字段，于是通过tune_2fs查看了下，发现并不是。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tune2fs -l /dev/sdb</span><br><span class="line">tune2fs 1.46.5 (30-Dec-2021)</span><br><span class="line">// ...</span><br><span class="line">Default mount options:    user_xattr acl</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>这里只有user_xattr和acl，理论上其他的那些options当nodefs为0时也会输出，比如delalloc。但是却并没有。所以，还得探究下这个<code>sbi-&gt;s_def_mount_opt</code>字段究竟是如何被设置的。</p><h2 id="默认挂载选项"><a href="#默认挂载选项" class="headerlink" title="默认挂载选项"></a>默认挂载选项</h2><p>熟悉linux文件系统的都知道，vfs会有个通用的super block，每个文件系统也会有自己的super block，它们在磁盘和在内存上都会有些许差距。对于ext4来说，它在磁盘上的super block布局为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/ext4/ext4.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure of the super block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_super_block</span> &#123;</span></span><br><span class="line"><span class="comment">/*00*/</span>__le32s_inodes_count;<span class="comment">/* Inodes count */</span></span><br><span class="line">__le32s_blocks_count_lo;<span class="comment">/* Blocks count */</span></span><br><span class="line">__le32s_r_blocks_count_lo;<span class="comment">/* Reserved blocks count */</span></span><br><span class="line">__le32s_free_blocks_count_lo;<span class="comment">/* Free blocks count */</span></span><br><span class="line"><span class="comment">/*10*/</span>__le32s_free_inodes_count;<span class="comment">/* Free inodes count */</span></span><br><span class="line">__le32s_first_data_block;<span class="comment">/* First Data Block */</span></span><br><span class="line">__le32s_log_block_size;<span class="comment">/* Block size */</span></span><br><span class="line">__le32s_log_cluster_size;<span class="comment">/* Allocation cluster size */</span></span><br><span class="line"><span class="comment">/*20*/</span>__le32s_blocks_per_group;<span class="comment">/* # Blocks per group */</span></span><br><span class="line">__le32s_clusters_per_group;<span class="comment">/* # Clusters per group */</span></span><br><span class="line">__le32s_inodes_per_group;<span class="comment">/* # Inodes per group */</span></span><br><span class="line">__le32s_mtime;<span class="comment">/* Mount time */</span></span><br><span class="line"><span class="comment">/*30*/</span>__le32s_wtime;<span class="comment">/* Write time */</span></span><br><span class="line">__le16s_mnt_count;<span class="comment">/* Mount count */</span></span><br><span class="line">__le16s_max_mnt_count;<span class="comment">/* Maximal mount count */</span></span><br><span class="line">__le16s_magic;<span class="comment">/* Magic signature */</span></span><br><span class="line">__le16s_state;<span class="comment">/* File system state */</span></span><br><span class="line">__le16s_errors;<span class="comment">/* Behaviour when detecting errors */</span></span><br><span class="line">__le16s_minor_rev_level;<span class="comment">/* minor revision level */</span></span><br><span class="line"><span class="comment">/*40*/</span>__le32s_lastcheck;<span class="comment">/* time of last check */</span></span><br><span class="line">__le32s_checkinterval;<span class="comment">/* max. time between checks */</span></span><br><span class="line">__le32s_creator_os;<span class="comment">/* OS */</span></span><br><span class="line">__le32s_rev_level;<span class="comment">/* Revision level */</span></span><br><span class="line"><span class="comment">/*50*/</span>__le16s_def_resuid;<span class="comment">/* Default uid for reserved blocks */</span></span><br><span class="line">__le16s_def_resgid;<span class="comment">/* Default gid for reserved blocks */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These fields are for EXT4_DYNAMIC_REV superblocks only.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: the difference between the compatible feature set and</span></span><br><span class="line"><span class="comment"> * the incompatible feature set is that if there is a bit set</span></span><br><span class="line"><span class="comment"> * in the incompatible feature set that the kernel doesn&#x27;t</span></span><br><span class="line"><span class="comment"> * know about, it should refuse to mount the filesystem.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * e2fsck&#x27;s requirements are more strict; if it doesn&#x27;t know</span></span><br><span class="line"><span class="comment"> * about a feature in either the compatible or incompatible</span></span><br><span class="line"><span class="comment"> * feature set, it must abort and not try to meddle with</span></span><br><span class="line"><span class="comment"> * things it doesn&#x27;t understand...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__le32s_first_ino;<span class="comment">/* First non-reserved inode */</span></span><br><span class="line">__le16  s_inode_size;<span class="comment">/* size of inode structure */</span></span><br><span class="line">__le16s_block_group_nr;<span class="comment">/* block group # of this superblock */</span></span><br><span class="line">__le32s_feature_compat;<span class="comment">/* compatible feature set */</span></span><br><span class="line"><span class="comment">/*60*/</span>__le32s_feature_incompat;<span class="comment">/* incompatible feature set */</span></span><br><span class="line">__le32s_feature_ro_compat;<span class="comment">/* readonly-compatible feature set */</span></span><br><span class="line"><span class="comment">/*68*/</span>__u8s_uuid[<span class="number">16</span>];<span class="comment">/* 128-bit uuid for volume */</span></span><br><span class="line"><span class="comment">/*78*/</span><span class="type">char</span>s_volume_name[EXT4_LABEL_MAX];<span class="comment">/* volume name */</span></span><br><span class="line"><span class="comment">/*88*/</span><span class="type">char</span>s_last_mounted[<span class="number">64</span>] __nonstring;<span class="comment">/* directory where last mounted */</span></span><br><span class="line"><span class="comment">/*C8*/</span>__le32s_algorithm_usage_bitmap; <span class="comment">/* For compression */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Performance hints.  Directory preallocation should only</span></span><br><span class="line"><span class="comment"> * happen if the EXT4_FEATURE_COMPAT_DIR_PREALLOC flag is on.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__u8s_prealloc_blocks;<span class="comment">/* Nr of blocks to try to preallocate*/</span></span><br><span class="line">__u8s_prealloc_dir_blocks;<span class="comment">/* Nr to preallocate for dirs */</span></span><br><span class="line">__le16s_reserved_gdt_blocks;<span class="comment">/* Per group desc for online growth */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Journaling support valid if EXT4_FEATURE_COMPAT_HAS_JOURNAL set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*D0*/</span>__u8s_journal_uuid[<span class="number">16</span>];<span class="comment">/* uuid of journal superblock */</span></span><br><span class="line"><span class="comment">/*E0*/</span>__le32s_journal_inum;<span class="comment">/* inode number of journal file */</span></span><br><span class="line">__le32s_journal_dev;<span class="comment">/* device number of journal file */</span></span><br><span class="line">__le32s_last_orphan;<span class="comment">/* start of list of inodes to delete */</span></span><br><span class="line">__le32s_hash_seed[<span class="number">4</span>];<span class="comment">/* HTREE hash seed */</span></span><br><span class="line">__u8s_def_hash_version;<span class="comment">/* Default hash version to use */</span></span><br><span class="line">__u8s_jnl_backup_type;</span><br><span class="line">__le16  s_desc_size;<span class="comment">/* size of group descriptor */</span></span><br><span class="line"><span class="comment">/*100*/</span>__le32s_default_mount_opts;</span><br><span class="line">__le32s_first_meta_bg;<span class="comment">/* First metablock block group */</span></span><br><span class="line">__le32s_mkfs_time;<span class="comment">/* When the filesystem was created */</span></span><br><span class="line">__le32s_jnl_blocks[<span class="number">17</span>];<span class="comment">/* Backup of the journal inode */</span></span><br><span class="line"><span class="comment">/* 64bit support valid if EXT4_FEATURE_COMPAT_64BIT */</span></span><br><span class="line"><span class="comment">/*150*/</span>__le32s_blocks_count_hi;<span class="comment">/* Blocks count */</span></span><br><span class="line">__le32s_r_blocks_count_hi;<span class="comment">/* Reserved blocks count */</span></span><br><span class="line">__le32s_free_blocks_count_hi;<span class="comment">/* Free blocks count */</span></span><br><span class="line">__le16s_min_extra_isize;<span class="comment">/* All inodes have at least # bytes */</span></span><br><span class="line">__le16s_want_extra_isize; <span class="comment">/* New inodes should reserve # bytes */</span></span><br><span class="line">__le32s_flags;<span class="comment">/* Miscellaneous flags */</span></span><br><span class="line">__le16  s_raid_stride;<span class="comment">/* RAID stride */</span></span><br><span class="line">__le16  s_mmp_update_interval;  <span class="comment">/* # seconds to wait in MMP checking */</span></span><br><span class="line">__le64  s_mmp_block;            <span class="comment">/* Block for multi-mount protection */</span></span><br><span class="line">__le32  s_raid_stripe_width;    <span class="comment">/* blocks on all data disks (N*stride)*/</span></span><br><span class="line">__u8s_log_groups_per_flex;  <span class="comment">/* FLEX_BG group size */</span></span><br><span class="line">__u8s_checksum_type;<span class="comment">/* metadata checksum algorithm used */</span></span><br><span class="line">__u8s_encryption_level;<span class="comment">/* versioning level for encryption */</span></span><br><span class="line">__u8s_reserved_pad;<span class="comment">/* Padding to next 32bits */</span></span><br><span class="line">__le64s_kbytes_written;<span class="comment">/* nr of lifetime kilobytes written */</span></span><br><span class="line">__le32s_snapshot_inum;<span class="comment">/* Inode number of active snapshot */</span></span><br><span class="line">__le32s_snapshot_id;<span class="comment">/* sequential ID of active snapshot */</span></span><br><span class="line">__le64s_snapshot_r_blocks_count; <span class="comment">/* reserved blocks for active</span></span><br><span class="line"><span class="comment">      snapshot&#x27;s future use */</span></span><br><span class="line">__le32s_snapshot_list;<span class="comment">/* inode number of the head of the</span></span><br><span class="line"><span class="comment">   on-disk snapshot list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_S_ERR_START offsetof(struct ext4_super_block, s_error_count)</span></span><br><span class="line">__le32s_error_count;<span class="comment">/* number of fs errors */</span></span><br><span class="line">__le32s_first_error_time;<span class="comment">/* first time an error happened */</span></span><br><span class="line">__le32s_first_error_ino;<span class="comment">/* inode involved in first error */</span></span><br><span class="line">__le64s_first_error_block;<span class="comment">/* block involved of first error */</span></span><br><span class="line">__u8s_first_error_func[<span class="number">32</span>] __nonstring;<span class="comment">/* function where the error happened */</span></span><br><span class="line">__le32s_first_error_line;<span class="comment">/* line number where error happened */</span></span><br><span class="line">__le32s_last_error_time;<span class="comment">/* most recent time of an error */</span></span><br><span class="line">__le32s_last_error_ino;<span class="comment">/* inode involved in last error */</span></span><br><span class="line">__le32s_last_error_line;<span class="comment">/* line number where error happened */</span></span><br><span class="line">__le64s_last_error_block;<span class="comment">/* block involved of last error */</span></span><br><span class="line">__u8s_last_error_func[<span class="number">32</span>] __nonstring;<span class="comment">/* function where the error happened */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_S_ERR_END offsetof(struct ext4_super_block, s_mount_opts)</span></span><br><span class="line">__u8s_mount_opts[<span class="number">64</span>];</span><br><span class="line">__le32s_usr_quota_inum;<span class="comment">/* inode for tracking user quota */</span></span><br><span class="line">__le32s_grp_quota_inum;<span class="comment">/* inode for tracking group quota */</span></span><br><span class="line">__le32s_overhead_clusters;<span class="comment">/* overhead blocks/clusters in fs */</span></span><br><span class="line">__le32s_backup_bgs[<span class="number">2</span>];<span class="comment">/* groups with sparse_super2 SBs */</span></span><br><span class="line">__u8s_encrypt_algos[<span class="number">4</span>];<span class="comment">/* Encryption algorithms in use  */</span></span><br><span class="line">__u8s_encrypt_pw_salt[<span class="number">16</span>];<span class="comment">/* Salt used for string2key algorithm */</span></span><br><span class="line">__le32s_lpf_ino;<span class="comment">/* Location of the lost+found inode */</span></span><br><span class="line">__le32s_prj_quota_inum;<span class="comment">/* inode for tracking project quota */</span></span><br><span class="line">__le32s_checksum_seed;<span class="comment">/* crc32c(uuid) if csum_seed set */</span></span><br><span class="line">__u8s_wtime_hi;</span><br><span class="line">__u8s_mtime_hi;</span><br><span class="line">__u8s_mkfs_time_hi;</span><br><span class="line">__u8s_lastcheck_hi;</span><br><span class="line">__u8s_first_error_time_hi;</span><br><span class="line">__u8s_last_error_time_hi;</span><br><span class="line">__u8s_first_error_errcode;</span><br><span class="line">__u8    s_last_error_errcode;</span><br><span class="line">__le16  s_encoding;<span class="comment">/* Filename charset encoding */</span></span><br><span class="line">__le16  s_encoding_flags;<span class="comment">/* Filename charset encoding flags */</span></span><br><span class="line">__le32  s_orphan_file_inum;<span class="comment">/* Inode for tracking orphan inodes */</span></span><br><span class="line">__le32s_reserved[<span class="number">94</span>];<span class="comment">/* Padding to the end of the block */</span></span><br><span class="line">__le32s_checksum;<span class="comment">/* crc32c(superblock) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它会有个字段<code>s_default_mount_opts</code>，其实就是tune2fs工具展示的Default mount options，这个值是在磁盘上永久保存的，一般都是当mkfs创建文件系统的时候写入，也可以通过tune2fs工具来修改。</p><p>它允许的默认值包括如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/ext4/ext4.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Default mount options</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_DEBUG0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_BSDGROUPS0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_XATTR_USER0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_ACL0x0008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_UID160x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_JMODE0x0060</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_JMODE_DATA0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_JMODE_ORDERED0x0040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_JMODE_WBACK0x0060</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_NOBARRIER0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_BLOCK_VALIDITY 0x0200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_DISCARD0x0400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DEFM_NODELALLOC0x0800</span></span><br></pre></td></tr></table></figure><p>mkfs可以通过配置文件来设置创建文件系统后super block里default_mntopts字段的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// /etc/mke2fs.conf</span><br><span class="line">[defaults]</span><br><span class="line">        base_features = sparse_super,large_file,filetype,resize_inode,dir_index,ext_attr</span><br><span class="line">        default_mntopts = acl,user_xattr</span><br><span class="line">        enable_periodic_fsck = 0</span><br><span class="line">        blocksize = 4096</span><br><span class="line">        inode_size = 256</span><br><span class="line">        inode_ratio = 16384</span><br><span class="line"></span><br><span class="line">[fs_types]</span><br><span class="line">        ext3 = &#123;</span><br><span class="line">                features = has_journal</span><br><span class="line">        &#125;</span><br><span class="line">        ext4 = &#123;</span><br><span class="line">                features = has_journal,extent,huge_file,flex_bg,metadata_csum,64bit,dir_nlink,extra_isize</span><br><span class="line">        &#125;</span><br><span class="line">        small = &#123;</span><br><span class="line">                inode_ratio = 4096</span><br><span class="line">        &#125;</span><br><span class="line">        floppy = &#123;</span><br><span class="line">                inode_ratio = 8192</span><br><span class="line">        &#125;</span><br><span class="line">        big = &#123;</span><br><span class="line">                inode_ratio = 32768</span><br><span class="line">        &#125;</span><br><span class="line">        huge = &#123;</span><br><span class="line">                inode_ratio = 65536</span><br><span class="line">        &#125;</span><br><span class="line">        news = &#123;</span><br><span class="line">                inode_ratio = 4096</span><br><span class="line">        &#125;</span><br><span class="line">        largefile = &#123;</span><br><span class="line">                inode_ratio = 1048576</span><br><span class="line">                blocksize = -1</span><br><span class="line">        &#125;</span><br><span class="line">        largefile4 = &#123;</span><br><span class="line">                inode_ratio = 4194304</span><br><span class="line">                blocksize = -1</span><br><span class="line">        &#125;</span><br><span class="line">        hurd = &#123;</span><br><span class="line">             blocksize = 4096</span><br><span class="line">             inode_size = 128</span><br><span class="line">             warn_y2038_dates = 0</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以确定，内存里加载过后的superblock的字段<code>s_def_mount_opt</code>和磁盘上super block的字段<code>s_default_mount_opts</code>实际上并非对应的关系，在内核挂载阶段的内核代码里会对<code>ext4_sb_info -&gt; s_def_mount_opt</code>进行设置。有意思的是，可以在磁盘上的superblock里设置EXT4_DEFM_NODELALLOC，从而改变挂载时默认delalloc的逻辑。</p><p>接下来梳理了一下内核代码关于mount option的设置流程：<code>sys_mount()</code> -&gt; <code>do_mount()</code> -&gt; <code>path_mount()</code> -&gt; <code>do_new_mount()</code> -&gt; <code>vfs_get_tree()</code> -&gt; <code>ext4_get_tree()</code> -&gt; <code>get_tree_bdev()</code> -&gt; <code>ext4_fill_super</code> -&gt; <code>__ext4_fill_super()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/ext4/super.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __ext4_fill_super(<span class="keyword">struct</span> fs_context *fc, <span class="keyword">struct</span> super_block *sb)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_super_block</span> *<span class="title">es</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_sb_info</span> *<span class="title">sbi</span> =</span> EXT4_SB(sb);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex_groups</span> **<span class="title">flex_groups</span>;</span></span><br><span class="line"><span class="type">ext4_fsblk_t</span> block;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_fs_context</span> *<span class="title">ctx</span> =</span> fc-&gt;fs_private;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载sbi-&gt;s_es，es指向磁盘上布局的super block数据</span></span><br><span class="line">err = ext4_load_super(sb, &amp;logical_sb_block, silent);</span><br><span class="line"></span><br><span class="line">es = sbi-&gt;s_es;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析es-&gt;s_default_mount_opts，这也是mkfs时可以设置的挂载options</span></span><br><span class="line"><span class="comment">// 这个字段为字符串</span></span><br><span class="line">ext4_set_def_opts(sb, es);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析es-&gt;s_mount_opts</span></span><br><span class="line">err = parse_apply_sb_mount_options(sb, ctx);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> failed_mount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的赋值很关键，会把上述解析出来的option都列为s_def_mount_opt</span></span><br><span class="line">sbi-&gt;s_def_mount_opt = sbi-&gt;s_mount_opt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里在设置挂载时参数附带的options，不再将其设置为s_def_mount_opt</span></span><br><span class="line">ext4_apply_options(fc, sb);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里也有可能设置sbi-&gt;s_def_mount_opt</span></span><br><span class="line"><span class="keyword">if</span> (!test_opt(sb, NOLOAD) &amp;&amp; ext4_has_feature_journal(sb)) &#123;</span><br><span class="line">err = ext4_load_and_init_journal(sb, es, ctx);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> failed_mount3a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过es-&gt;s_default_mount_opts来设置sbi-&gt;s_mount_opt</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ext4_set_def_opts</span><span class="params">(<span class="keyword">struct</span> super_block *sb,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> ext4_super_block *es)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> def_mount_opts;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set defaults before we parse the mount options */</span></span><br><span class="line">def_mount_opts = le32_to_cpu(es-&gt;s_default_mount_opts);</span><br><span class="line">set_opt(sb, INIT_INODE_TABLE);</span><br><span class="line"><span class="keyword">if</span> (def_mount_opts &amp; EXT4_DEFM_DEBUG)</span><br><span class="line">set_opt(sb, DEBUG);</span><br><span class="line"><span class="keyword">if</span> (def_mount_opts &amp; EXT4_DEFM_BSDGROUPS)</span><br><span class="line">set_opt(sb, GRPID);</span><br><span class="line"><span class="keyword">if</span> (def_mount_opts &amp; EXT4_DEFM_UID16)</span><br><span class="line">set_opt(sb, NO_UID32);</span><br><span class="line"><span class="comment">/* xattr user namespace &amp; acls are now defaulted on */</span></span><br><span class="line">set_opt(sb, XATTR_USER);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXT4_FS_POSIX_ACL</span></span><br><span class="line">set_opt(sb, POSIX_ACL);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (ext4_has_feature_fast_commit(sb))</span><br><span class="line">set_opt2(sb, JOURNAL_FAST_COMMIT);</span><br><span class="line"><span class="comment">/* don&#x27;t forget to enable journal_csum when metadata_csum is enabled. */</span></span><br><span class="line"><span class="keyword">if</span> (ext4_has_metadata_csum(sb))</span><br><span class="line">set_opt(sb, JOURNAL_CHECKSUM);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((def_mount_opts &amp; EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)</span><br><span class="line">set_opt(sb, JOURNAL_DATA);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((def_mount_opts &amp; EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)</span><br><span class="line">set_opt(sb, ORDERED_DATA);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((def_mount_opts &amp; EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)</span><br><span class="line">set_opt(sb, WRITEBACK_DATA);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (le16_to_cpu(es-&gt;s_errors) == EXT4_ERRORS_PANIC)</span><br><span class="line">set_opt(sb, ERRORS_PANIC);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (le16_to_cpu(es-&gt;s_errors) == EXT4_ERRORS_CONTINUE)</span><br><span class="line">set_opt(sb, ERRORS_CONT);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">set_opt(sb, ERRORS_RO);</span><br><span class="line"><span class="comment">/* block_validity enabled by default; disable with noblock_validity */</span></span><br><span class="line">set_opt(sb, BLOCK_VALIDITY);</span><br><span class="line"><span class="keyword">if</span> (def_mount_opts &amp; EXT4_DEFM_DISCARD)</span><br><span class="line">set_opt(sb, DISCARD);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((def_mount_opts &amp; EXT4_DEFM_NOBARRIER) == <span class="number">0</span>)</span><br><span class="line">set_opt(sb, BARRIER);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * enable delayed allocation by default</span></span><br><span class="line"><span class="comment"> * Use -o nodelalloc to turn it off</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!IS_EXT3_SB(sb) &amp;&amp; !IS_EXT2_SB(sb) &amp;&amp;</span><br><span class="line">    ((def_mount_opts &amp; EXT4_DEFM_NODELALLOC) == <span class="number">0</span>))</span><br><span class="line">set_opt(sb, DELALLOC);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sb-&gt;s_blocksize == PAGE_SIZE)</span><br><span class="line">set_opt(sb, DIOREAD_NOLOCK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果之前没有设置过EXT4_MOUNT_JOURNAL_DATA字段，也会将其设置成默认字段</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ext4_load_and_init_journal</span><span class="params">(<span class="keyword">struct</span> super_block *sb,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> ext4_super_block *es,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> ext4_fs_context *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We have now updated the journal if required, so we can</span></span><br><span class="line"><span class="comment"> * validate the data journaling mode. */</span></span><br><span class="line"><span class="keyword">switch</span> (test_opt(sb, DATA_FLAGS)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="comment">/* No mode set, assume a default based on the journal</span></span><br><span class="line"><span class="comment"> * capabilities: ORDERED_DATA if the journal can</span></span><br><span class="line"><span class="comment"> * cope, else JOURNAL_DATA</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (jbd2_journal_check_available_features</span><br><span class="line">    (sbi-&gt;s_journal, <span class="number">0</span>, <span class="number">0</span>, JBD2_FEATURE_INCOMPAT_REVOKE)) &#123;</span><br><span class="line">set_opt(sb, ORDERED_DATA);</span><br><span class="line">sbi-&gt;s_def_mount_opt |= EXT4_MOUNT_ORDERED_DATA;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">set_opt(sb, JOURNAL_DATA);</span><br><span class="line">sbi-&gt;s_def_mount_opt |= EXT4_MOUNT_JOURNAL_DATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EXT4_MOUNT_ORDERED_DATA:</span><br><span class="line"><span class="keyword">case</span> EXT4_MOUNT_WRITEBACK_DATA:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在挂载的过程中，<code>sbi-&gt;s_def_mount_opt</code>和<code>es-&gt;s_mount_opts</code>并非简单的对应关系，ext4会对<code>sbi-&gt;s_def_mount_opt</code>进行额外的设置。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Ext4文件系统的mount option设置来源有几个地方，一是通过mkfs时在磁盘上的superblock写入，二是挂载时的参数。但是这些和内存中文件系统相关的mount options和default mount options都不是简单的对应关系，ext4会根据其他的信息设置options。</p><p>查看ext4挂载选项认准<code>/proc/fs/ext4/&#123;device&#125;/options</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://www.kernel.org/doc/html/v4.19/filesystems/ext4/ext4.</summary>
      
    
    
    
    <category term="Linux" scheme="http://cyyzero.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux访问控制模型和进程凭证</title>
    <link href="http://cyyzero.github.io/2021/09/01/Linux/Linux_uids/"/>
    <id>http://cyyzero.github.io/2021/09/01/Linux/Linux_uids/</id>
    <published>2021-09-01T14:43:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux的访问控制模型"><a href="#Linux的访问控制模型" class="headerlink" title="Linux的访问控制模型"></a>Linux的访问控制模型</h2><p>Linux传统的访问控制模型是DAC（Discretionary Access Control，自主访问控制）。DAC Model是根据自主访问控制策略建立的一种模型，允许合法用户以用户或用户组的身份访问策略规定的客体，同时阻止非授权用户访问客体，某些用户还可以自主地把自己所拥有的客体的访问权限授予其他用户。在Linux中，这里用户和用户组就对应了user和group，客体就代表了文件、文件夹、IPC等共享资源。对于客体，比如文件来说，可以对于不同的主体分别设置rwx权限。当然，对于主体的划分粒度较粗，只能对文件所有者、同组用户、其他用户分别设置，没法针对每个用户单独设立权限。</p><p>ps：SELinux上引入了MAC模型，这里不做深入。</p><h2 id="进程的用户ID凭证"><a href="#进程的用户ID凭证" class="headerlink" title="进程的用户ID凭证"></a>进程的用户ID凭证</h2><p>众所周知，Linux上一切操作都是基于进程来进行，比如常见的在shell里执行命令等。在执行需要权限判断的操作时，进程都会通过某个系统调用陷入内核，由内核来进行权限的判断。那么很自然就能想到，既然Linux的DAC模型基于用户和组做权限控制，那么进程里必然得保存关于用户和组的信息。具体实现上来说，进程都有一套数字来表示它所属于的用户ID和组ID。以下主要讲解用户ID凭证，组ID的原理和实现和用户类似，就不再赘述。这些ID称为进程凭证。对于用户ID来说，具体有三个：</p><ul><li>实际用户ID(real user ID)</li><li>有效用户ID(effective user ID)</li><li>保存的set-user-ID(saved-user-ID)</li></ul><h3 id="需要保存三个uid吗？"><a href="#需要保存三个uid吗？" class="headerlink" title="需要保存三个uid吗？"></a>需要保存三个uid吗？</h3><h4 id="一个ID够吗？"><a href="#一个ID够吗？" class="headerlink" title="一个ID够吗？"></a>一个ID够吗？</h4><p>可能有人会困惑，为什么需要保存三个id。只保存一个启动进程的用户ID可不可行呢？当前用户通过login进程登录之后，保存它的<code>uid</code>。后续再由该用户启动的程序都是login进程的子孙进程，只要让子进程的<code>uid</code>凭证都继承自父进程，<code>uid</code>就此就能保存下来。</p><p>以上的设计在大部分场景下够用。但是有些程序的权限需求比较特殊，得让普通用户执行也有文件所有者的权限。比如说用户的密码储存在<code>/etc/shadow</code>中，普通用户不可读写。但是，<code>passwd</code>程序允许用户修改它们自己的密码。也就是，当用户执行<code>passwd</code>，它们可以突然修改<code>/etc/shadow</code>，而且得识别出启动进程的用户，如何实现？如果按照上述的设计，普通用户执行<code>passwd</code>，进程<code>uid</code>为非0，那必然没有<code>/etc/shadow</code>的读写权限。</p><h4 id="set-uid-两个ID够吗？"><a href="#set-uid-两个ID够吗？" class="headerlink" title="set-uid,两个ID够吗？"></a>set-uid,两个ID够吗？</h4><p>于是，早年的开发者们就想到了，在文件的属性上加了一位做标记，<code>set-user-id</code>位。那么，继续沿用上述的设计，在<code>exec</code>标志<code>set-user-id</code>位的可执行程序时，将进程的<code>uid</code>改成文件所有者，普通用户无法读写<code>/etc/shadow</code>问题就迎刃而解了。但这样引入了了另一个问题，诸如<code>passwd</code>这样的程序无法知道启动进程的用户，都不知道该改哪个用户的密码了。很显然，进程保存一个<code>uid</code>肯定是不够用了，至少得再加一个。一个记录运行程序的用户id，一个记录实际用于权限判断的用户id。实际上，<code>real-uid</code>和<code>effective-uid</code>就是干的这个事情。<code>real-uid</code>为启动进程的用户id，<code>effective-uid</code>为实际用户权限判断的用户id。大部分情况下，<code>real-uid</code>和<code>effective-uid</code>相同。运行设置<code>set-uid</code>的程序，<code>effective-uid</code>会改成程序文件的owner。</p><p>这样的设计也不够好，因为<code>effective-uid</code>的更改变成了一锤子买卖。如果有进程需要在启动的用户和文件owner之间反复横跳怎么办？<code>effective-uid</code>改回<code>real-uid</code>之后文件所属用户id就丢失了（进程得根据执行的文件<code>exe</code>大费周折去文件系统的inode里查所属用户）。</p><h4 id="最小权限原则，三个ID"><a href="#最小权限原则，三个ID" class="headerlink" title="最小权限原则，三个ID"></a>最小权限原则，三个ID</h4><p>这个”反复横跳”的需求也是很有必要的。有个最小权限原则（最早由 Saltzer 和 Schroeder 提出）：</p><blockquote><p>每个程序和系统用户都应该具有完成任务所必需的最小权限集合。<br>限制代码运行所需的安全权限，有一个非常重要的原因，就是降低你的代码在被恶意用户利用时，造成的损失。如果你的代码仅仅使用最小权限来执行，恶意用户就难以使用它造成损失。如果你需要用户使用管理员权限来执行代码，任何代码中的安全缺陷，都会通过利用该缺陷的恶意用户，潜在造成更大的损失。</p></blockquote><p>根据最小权限原则，只有实际进行关键操作的时候获取权限，其余时候应该禁用。比如说对于<code>passwd</code>程序来说，最好就是只有在读写<code>/etc/shadow</code>的时候获取root权限，其余时候（比如说等待用户输入时）放弃特权。</p><h4 id="具体规则"><a href="#具体规则" class="headerlink" title="具体规则"></a>具体规则</h4><p>所以，最后就形成了现今的实现，进程里保存了三个uid。这三个uid初始化的规则如下：</p><ol><li><code>real-uid</code>为启动进程的用户。</li><li>如果是<code>set-uid</code>程序运行的进程，<code>effective-uid</code>为文件的所有者；否则和<code>real-uid</code>相同，为启动进程的用户。</li><li><code>saved-uid</code>由<code>effective-uid</code>复制而来。</li></ol><p>对于普通的非特权用户来说，允许通过一些系统调用让<code>effective-uid</code>在<code>real-uid</code>和<code>saved-uid</code>之间来回变动。进程运行时，权限的检查则都是基于<code>effective uid</code>。对于一个拥有良好安全设计的<code>set-uid</code>程序来说，只有需要使用特殊权限的时候才把<code>effective-uid</code>切换成文件所有者，其余时候都应该为进程启动者。</p><h4 id="系统接口"><a href="#系统接口" class="headerlink" title="系统接口"></a>系统接口</h4><p>Linux上支持改动修改进程凭证的一些系统接口：</p><p><img src="/img/setuid.png" alt="修改进程凭证的一些系统调用"></p><p><strong>参考</strong>：</p><ol><li>《Linux系统编程手册》第9章</li><li><a href="https://wizardforcel.gitbooks.io/syracuse-sec-lecture-notes/content/3.html">https://wizardforcel.gitbooks.io/syracuse-sec-lecture-notes/content/3.html</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux的访问控制模型&quot;&gt;&lt;a href=&quot;#Linux的访问控制模型&quot; class=&quot;headerlink&quot; title=&quot;Linux的访问控制模型&quot;&gt;&lt;/a&gt;Linux的访问控制模型&lt;/h2&gt;&lt;p&gt;Linux传统的访问控制模型是DAC（Discretiona</summary>
      
    
    
    
    <category term="Linux" scheme="http://cyyzero.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>A Tale of Two Systems: Using Containers to Deploy HPC Applications on Supercomputers and Clouds</title>
    <link href="http://cyyzero.github.io/2021/08/19/container/A%20Tale%20of%20Two%20Systems%20Using%20Containers%20to%20Deploy%20HPC%20Applications%20on%20Supercomputers%20and%20Clouds/"/>
    <id>http://cyyzero.github.io/2021/08/19/container/A%20Tale%20of%20Two%20Systems%20Using%20Containers%20to%20Deploy%20HPC%20Applications%20on%20Supercomputers%20and%20Clouds/</id>
    <published>2021-08-19T12:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<p>Younge, Andrew J., et al. “A tale of two systems: Using containers to deploy HPC applications on supercomputers and clouds.” 2017 IEEE International Conference on Cloud Computing Technology and Science (CloudCom). IEEE, 2017.</p><h2 id="container"><a href="#container" class="headerlink" title="container"></a>container</h2><ul><li>Docker</li><li>Shifter</li><li>Charliecloud</li><li>Singularity</li></ul><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><p><img src="/img/devops.png" alt="DevOps"></p><p>部署的工作流：</p><ol><li>在本地电脑上使用docker容器（因为桌面电脑用win和macOS的比较多，docker都支持），将Dockerfile和项目代码保存到git项目中。</li><li>项目推送到远端的仓库，并将容器镜像放进容器注册服务。</li><li>在多个平台上（EC2、cluster、supercomputer）拉取代码，在容器中执行。</li></ol><h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><ul><li><p>镜像环境：</p><ul><li><p>HPCG benchmark</p></li><li><p>Intel MPI Benchmark suite (IMB)</p></li><li><p>base image: Centos 7, both benchmarks were built using the Intel 2017 Parallel Studio, which includes the latest Intel compilers and Intel MPI library.</p><p>拉取镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ajyounge/hpcg-container</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Cray  XC30 supercomputing platform</p><ul><li><p>hardware:</p><blockquote><p>Volta includes 56 compute nodes packaged in a single enclosure, with each node consisting of two Intel Ivy Bridge E5-2695v2 2.4 GHz processors (24 cores total), 64GB of memory, and a Cray Aries network interface.</p></blockquote></li><li><p>shared file system</p><blockquote><p>Shared file system supportis provided by NFS I&#x2F;O servers projected to compute nodes via Cray’s proprietary DVS storage infrastructure.</p></blockquote></li><li><p>OS:Cray Compute Node Linux (CNL ver. 5.2.UP04, 基于SUSE Linux 11), linux kernel v3.0.101</p><pre><code>内核版本过老，需要做出修改才能使用Singularity。具体来说，增加了对loopback设备和EXT3文件系统的支持。</code></pre><ul><li><p>config：</p><blockquote><p>Specifically, we configure Singularity to mount &#x2F;opt&#x2F;cray, as well as &#x2F;var&#x2F;opt&#x2F;cray for each container instance.</p></blockquote><blockquote><p>In order to leverage the Aries interconnect as well as advanced shared memory intra-node communication mechanisms, we dynamically link Cray’s MPI and associated libraries provided in &#x2F;opt&#x2F;cray directly within the container</p></blockquote><p>  链接的动态库包括：</p><ul><li>Cray’s uGNI messaging interface</li><li>XPMEM shared memory subsystem</li><li>Cray PMI runtime libraries</li><li>uDREG registration cache</li><li>application placement scheduler (ALPS)</li><li>configure workload manager</li><li>some Intel Parallel Studio libraries</li></ul></li></ul></li></ul></li><li><p>Amazon EC2: c3.8xlarge</p><ul><li><p>hardware:</p><ul><li>cpu: Intel Xeon “Ivy-Bridge” E5-2680 v2 (2.8 GHz, 8 cores, hyperthread) x 2</li><li>memory: 60GB of RAM</li><li>disk: 2x320 GB SSDs</li><li>network: 10 Gb Ethernet network</li></ul></li><li><p>OS: RHEL7</p><ul><li>config:<br>  使用SR-IOV技术，加载了ixgbevf内核模块。</li></ul></li><li><p>Docker: v1.19</p></li></ul></li></ul><h2 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h2><blockquote><p>Benchmarks are reported as the average of 10 trials for IMB and 3 trials for HPCG, with negligible run-to-runvariance that is therefore not shown.</p></blockquote><ul><li><p>IMB</p><p>  测试网络的带宽和延迟，对应MPI节点通信的性能。对于全静态链接和动态链接的版本做了测试。</p><ul><li><p>PingPong bandwidth</p><p><img src="/img/IMB_pingpong.png" alt="IMB PingPong bandwidth"></p><p>Singularity容器中链接CrayMPI，带宽最高，接近native。表明MPI库的选择会严重影响性能，针对特殊机器做过优化的版本最优。</p></li><li><p>PingPong Latency</p><p><img src="/img/IMB_PingPong_latency.png" alt="IMB PingPong Latency"></p><p>Singularity链接CrayMPI，延迟和native采用动态链接基本一致。静态链接的版本延迟最低。</p></li></ul></li><li><p>HPCG</p><p>  MPI程序的性能</p><p>  <img src="/img/Cray_HPCG.png" alt="HPCG benchmark"></p><p>  可以观察到，随着rank数量增加，Cray相比EC2的性能优势开始体现；Singularity链接CrayMPI的性能接近native；链接IntelMPI的性能甚至不如kvm虚拟机。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Younge, Andrew J., et al. “A tale of two systems: Using containers to deploy HPC applications on supercomputers and clouds.” 2017 IEEE In</summary>
      
    
    
    
    <category term="Container" scheme="http://cyyzero.github.io/categories/Container/"/>
    
    <category term="论文笔记" scheme="http://cyyzero.github.io/categories/Container/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Performance Evaluation of Container-based Virtualization for High Performance Computing Environments</title>
    <link href="http://cyyzero.github.io/2021/08/18/container/Performance%20Evaluation%20of%20Container-based%20Virtualization/"/>
    <id>http://cyyzero.github.io/2021/08/18/container/Performance%20Evaluation%20of%20Container-based%20Virtualization/</id>
    <published>2021-08-18T12:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<p>Xavier, Miguel G., et al. “Performance evaluation of container-based virtualization for high performance computing environments.” 2013 21st Euromicro International Conference on Parallel, Distributed, and Network-Based Processing. IEEE, 2013.</p><h2 id="containers"><a href="#containers" class="headerlink" title="containers"></a>containers</h2><ul><li>LXC(<strong>L</strong>inu<strong>x</strong> <strong>C</strong>ontainer) 2.0.9</li><li>docker 17.03.0-ce, build 60ccb22</li><li>singularity 2.2.1</li></ul><p>singularity相比另外两款容器技术在功能上适当舍弃，比如启动不改变用户、没有使用cgroup等。这些都对性能有积极影响。</p><h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><blockquote><p>CPU model Intel(R) Xeon(R) CPU E5-2683v4  @  2.10GHz(64-core  node);  Memory  164  GB  DDR3-1,866  MHz,  72-bit  wide  bus  at  14.9  GB&#x2F;s  on  P244br  anda HPE Dynamic Smart Array B140i Disk; OS Ubuntu 16.04(64-bit) distribution was installed on the host machine.</p></blockquote><h2 id="benchmarks"><a href="#benchmarks" class="headerlink" title="benchmarks"></a>benchmarks</h2><ul><li><p>执行基本命令 echo hello world</p><p>  <img src="/img/echo-helloworld.png" alt="/bin/echo &quot;hello world&quot; result"></p></li><li><p>HPL</p><p>  用于测试CPU性能。编译环境：GNU C&#x2F;C++ 5.4，OpenMPI 2.0.2。</p><blockquote><p>For  the  HPL  benchmark,  the  performance  results  dependon two main factors: the Basic Linear Algebra Subprogram(BLAS) library,  and  the  problem  size.  We  used  in  our experiments the GotoBLAS library, which is one of the bestportable  solutions,  freely  available  to  scientists.  Searchingfor  the  problem  size  that  can  deliver  peak  performance  isextensive; instead, we used the same problem size 10 times(10 N, 115840 Ns) for performance analysis.</p></blockquote><p>  BLAS库：GotoBLAS， 问题规模：10 N, 115840 Ns</p><p>  <img src="/img/hpl.png" alt="hpl result"></p><blockquote><p>The  LXC  was  not  able  to achieve  native  performance  presenting  an  average  overheadof 7.76%, Docker overhead was 2.89%, this could be probably caused by the default CPU use restrictions set on the daemon which by default each container is allowed to use a node’s CPU for a predefined amount of time. Singularity was able to achieve a better performance than native with 5.42% because is not emulating a full hardware level virtualization(only the mount namespace) paradigm and as the image itself is only a single metadata lookup this can yield in very high performance benefits.</p></blockquote><p>  <strong>TODO:</strong> singularity为什么比裸机还快？docker或者LXC通过调整cgroup的配置能否进一步释放性能？</p></li><li><p>IOzone</p><p>  测试IO。</p><blockquote><p>We  ran  the  benchmark  witha  file  size  of  15GB  and  64KB  for  the  record  size,  under two(2)  scenarios. The  first  scenario  was  a  totally  containedfilesystem  (without  any  bind  or  mount  volume),  and  thesecond scenario was a NFS binding from the local cluster.</p></blockquote><p>  <img src="/img/IOzone-1.png" alt="IOzone read and write"></p><p>  <img src="/img/IOzone-2.png" alt="IOzone random read and write"></p><blockquote><p>Docker advanced multi-layered unificationfilesystem (AUFS)  has  it  drawbacks.  When  an  applicationrunning in a container needs to write a single new value toa file on a AUFS, it must copy on write up the file from theunderlying  image.  The  AUFS  storage  driver  searches  eachimage  layer  for  the  file.  The  search order is from top to bottom. When it is found, the entire file is copied up to thecontainer’s top writable layer. From there, it can be openedand modified.</p></blockquote><p>  Docker读写no-bind普遍比较慢的原因是AUFS。</p><p>  <strong>TODO:</strong> 连续读写和随机读写时，bind和no-bind的性能优劣正好反过来。why？（猜测：可能和文件系统、挂载的硬盘有关）</p></li><li><p>STREAM</p><p>  测试内存带宽。</p><p>  <img src="/img/stream.png" alt="stream"></p><p>  singularity性能最优，因为没有cgroup对资源的限制。</p></li><li><p>MVA-PICH OSU Micro-Benchmarks 5.3.2</p><p>  测试MPI通信的带宽和延迟。</p><p>  <img src="/img/MPI-bandwidth.png" alt="MPI bandwidth"><br>  <img src="/img/MPI-latency.png" alt="MPI latency"></p><blockquote><p>These results can be explained  due  to  different  implementations  of  the  network isolation  of  the  virtualization  systems. While  Singularity container  does  not  implement  virtualized  network  devices,both  Docker  and  LXC  implement  network  namespace  that provides  an  entire  network  subsystem.  COS  network  performance  degradation  is  caused  by  the  extra  complexity  oftransmit and receive packets (e.g. Daemon processes).</p></blockquote></li><li><p>NAMD</p><p>  测试GPU性能</p><ul><li><p>Environment:</p><blockquote><p>The  performance  studies  were  executed  on  a  Dell  Po-werEdge  R720,  with  2*Intel(R)  Xeon(R)  CPU  E5-2603  @1.80GHz  (8  cores)  and  a  NVIDIA  Tesla  K20M.7.  Froma  system  point  of  view,  we  used  Ubuntu  16.04.2  (64-bit),with NVIDIA cuda 8.0 and the NVIDIA driver version375.26.</p></blockquote></li><li><p>version:</p><ul><li>Singularity 2.2.1</li><li>Docker 17.03.0-ce, build 60ccb22</li><li>LXC 2.0.9</li></ul></li><li><p>detail：</p><blockquote><p>We  ran  those  GPU  benchmarks  on  a  Tesla  K20m  with  “NAMD  x8664  multicoreCUDA version 2017-03-16” [on the stmv dataset (1066628 Atoms)],  using  the  8  cores  and  the  GPU  card,  withoutany  specific  additional  configuration,  except  the  use  of  the“gpu4singularity” code  for  Singularity  and  the  “nvidia-docker” tool  for  Docker.</p></blockquote></li><li><p>result:</p><p><img src="/img/NAMD.png" alt="NAMD"></p><p>单位：天&#x2F;纳秒。越低越好。</p></li></ul></li></ul><h3 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h3><p>作者在github上开源了测试运行的脚本。</p><p><a href="https://github.com/ArangoGutierrez/containers-benchs">https://github.com/ArangoGutierrez/containers-benchs</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Xavier, Miguel G., et al. “Performance evaluation of container-based virtualization for high performance computing environments.” 2013 21</summary>
      
    
    
    
    <category term="Container" scheme="http://cyyzero.github.io/categories/Container/"/>
    
    <category term="论文笔记" scheme="http://cyyzero.github.io/categories/Container/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>HPC container runtime performance overhead: At first order, there is none</title>
    <link href="http://cyyzero.github.io/2021/08/17/container/HPC%20container%20runtime%20performance%20overhead/"/>
    <id>http://cyyzero.github.io/2021/08/17/container/HPC%20container%20runtime%20performance%20overhead/</id>
    <published>2021-08-17T12:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<p>Torrez, Alfred, Reid Priedhorsky, and Timothy Randles. “HPC container runtime performance overhead: At first order, there is none.” (2020).</p><h2 id="containters"><a href="#containters" class="headerlink" title="containters"></a>containters</h2><ul><li>Charliecloud</li><li>Shifter</li><li>Singularity</li></ul><h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><p>LANL’s CTS-1 clusters Grizzly (1490 nodes,<br>128 GiB RAM&#x2F;node; HPCG) and Fog (32 nodes, 256 GiB RAM&#x2F;node; SysBench, STREAM, and HPCG)</p><p>分别在三种容器以及裸机环境中进行测试。</p><h2 id="benchmarks"><a href="#benchmarks" class="headerlink" title="benchmarks"></a>benchmarks</h2><ul><li><p>SysBench</p><p>  CPU性能。36路线程计算低于4000万的质数。</p><p>  4个环境下耗时几乎相同。</p></li><li><p>STREAM</p><p>  内存性能。编译选项 STREAM_ARRAY_SIZE&#x3D;2,000,000 –cpu_bind&#x3D;v,core,map_cpu:23。跑了100个单独的线程。</p><blockquote><p>We compiled with STREAM_ARRAY_SIZE set to 2 billion to match the recommended 4× cache and pinned the process to a semi-arbitrary core using the Slurm argument –cpu_bind&#x3D;v,core,map_cpu:23.</p></blockquote><p>  4个环境下测试出的带宽几乎相同</p></li><li><p>HPCG(High Performance Conjugate Gradients)</p><blockquote><p>We used a cube dimension of 104 and a run time of 60 seconds, all 36 cores per node, one MPI rank per core, and one thread per rank.</p></blockquote><p>  <img src="/img/1.png" alt="HPCG"></p></li><li><p>memory usage</p><blockquote><p>To understand node memory usage with STREAM, we computed MemTotal – MemFree from &#x2F;proc&#x2F;meminfo, sampled at 10-second intervals.</p></blockquote><blockquote><p>Bare metal total node usage was a median of 50.8 MiB. Charliecloud added 1200 MiB, Shifter 16 MiB, and Singularity 37 MiB.</p></blockquote><p>  Charliecloudn内存使用多可能是因为存储在tmpfs里的1.2Gib镜像。</p><blockquote><p>For HPCG, we sampled at 10-second intervals the writeable&#x2F;private field of pmap(1), which reports memory consumption of individual processes. Median memory usage for all three container technologies is, to two significant figures, 0.64% lower than bare metal at 1 node, 0.53% lower at 8 nodes, 0.53–0.54% lower at 64 nodes, and 1.2% higher at 512 nodes, a minimal difference.</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Torrez, Alfred, Reid Priedhorsky, and Timothy Randles. “HPC container runtime performance overhead: At first order, there is none.” (2020</summary>
      
    
    
    
    <category term="Container" scheme="http://cyyzero.github.io/categories/Container/"/>
    
    <category term="论文笔记" scheme="http://cyyzero.github.io/categories/Container/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Itanium C++ ABI下member pointer的实现</title>
    <link href="http://cyyzero.github.io/2019/02/19/C++/member_pointer_implemention/"/>
    <id>http://cyyzero.github.io/2019/02/19/C++/member_pointer_implemention/</id>
    <published>2019-02-19T13:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Itanium-C-ABI"><a href="#Itanium-C-ABI" class="headerlink" title="Itanium C++ ABI"></a>Itanium C++ ABI</h2><p><a href="https://itanium-cxx-abi.github.io/cxx-abi/">Itanium C++ ABI</a>是一个用于C++的<a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>。作为ABI，它给出了实现该语言的精确规则，确保程序中单独编译的部分能够成功地互操作。尽管它最初是为Itanium架构开发的，但它不是特定于平台的，可以在任意的C ABI之上进行分层移植。因此，它被用作所有主要架构上的许多主要操作系统的标准C++ ABI，并在许多主要的c++编译器中实现，包括GCC和Clang。</p><p>简单点来说，x64的Linux上，GCC和Clang都是遵循Itanium C++ ABI的。所以今天就针对这个它来探讨一下member pointer的实现。</p><h2 id="pointer-to-data-member"><a href="#pointer-to-data-member" class="headerlink" title="pointer to data member"></a>pointer to data member</h2><blockquote><p>A pointer to data member is an offset from the base address of the class object containing it, represented as a ptrdiff_t. It has the size and alignment attributes of a ptrdiff_t. A NULL pointer is represented as -1.</p></blockquote><p>指向数据成员的指针，实现为在整个类中的偏移量。可以看成是<code>ptrdiff_t</code>类型的数据。</p><p>接下来看个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Test::*ptr2a = &amp;Test::a;</span><br><span class="line">    <span class="type">char</span> Test::*ptr2b = &amp;Test::b;</span><br><span class="line">    <span class="type">double</span> Test::*ptr2c = &amp;Test::c;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; *(std::<span class="type">ptrdiff_t</span>*)(&amp;ptr2a) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *(std::<span class="type">ptrdiff_t</span>*)(&amp;ptr2b) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *(std::<span class="type">ptrdiff_t</span>*)(&amp;ptr2c) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为0,4,8。考虑到对齐，确实为各个成员的偏移量。</p><h2 id="pointer-to-function"><a href="#pointer-to-function" class="headerlink" title="pointer to function"></a>pointer to function</h2><blockquote><p>A pointer to member function is a pair as follows:</p><p>ptr:</p><p>   For a non-virtual function, this field is a simple function pointer. (Under current base Itanium psABI conventions, that is a pointer to a GP&#x2F;function address pair.) For a virtual function, it is 1 plus the virtual table offset (in bytes) of the function, represented as a ptrdiff_t. The value zero represents a NULL pointer, independent of the adjustment field value below.</p><p>adj:</p><p>   The required adjustment to this, represented as a ptrdiff_t.</p></blockquote><p>指向成员函数的指针。分为ptr部分和adj部分。ptr可分为指向非虚函数和虚函数的情况。adj表示对于this的调整，可以看成<code>ptrdiff_t</code>类型。</p><p>ps：关于这个adj是干什么用的我也不是很清楚，猜测有可能和多继承有关系？ &#x3D; &#x3D;。 以后知道了再补充吧，现在先主要讲解ptr。</p><ul><li><p>pointer to non-virtual function</p><p>  对于非虚函数来说，ptr部分就是简单的函数地址。可以通过这个得到成员函数地址，甚至直接调用它：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  Test::func() is called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> ptr2func = &amp;Test::func;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 得到func的地址</span></span><br><span class="line">    <span class="type">uint64_t</span> addr = *(<span class="type">uint64_t</span>*)&amp;ptr2func;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内联汇编，等效于下面一行</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;leaq %0, %%rdi ; callq *%1&quot;</span> : : <span class="string">&quot;m&quot;</span>(t),<span class="string">&quot;r&quot;</span> (addr) : <span class="string">&quot;rdi&quot;</span> )</span></span>;</span><br><span class="line">    <span class="comment">// (t.*ptr2func)();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里将<code>ptr2func</code>定义为成员函数指针，然后提取出它的ptr部分，既函数地址，保存到<code>addr</code>中。然后将t的地址传入<code>rdi</code>寄存器，充当<code>this</code>指针。x64的calling convention中，<code>rdi</code>存储函数调用的第一个参数，所以将<code>this</code>指针作为隐式的第一个参数存进了<code>rdi</code>寄存器。最后通过addr的函数地址，<code>call</code>指令进行调用。最后打印出<code>this</code>，与直接<code>(t.*ptr2func)()</code>效果相同。</p></li><li><p>pointer to virtual function</p><p>  对于虚函数来说，ptr部分为函数在虚表中的偏移量(单位为byte)加1。如果为0，表示为NLLL pointer，虚表中没有这个函数的指针。</p><p>  所以，如果我们知道了虚表的位置(对象的第一个字，就是虚表指针)，结合ptr表示的偏移量，也能得到函数的地址，从而调用它：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  Test::f1() is called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  Test::f2() is called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ptr2f1 = &amp;Test::f1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到虚表的地址</span></span><br><span class="line">    <span class="type">uint8_t</span>* vtable = *(<span class="type">uint8_t</span>**)(&amp;t);</span><br><span class="line">    <span class="comment">// 得到f1函数在虚表中的偏移量</span></span><br><span class="line">    std::<span class="type">ptrdiff_t</span> f1_offset = *(std::<span class="type">ptrdiff_t</span>*)(&amp;ptr2f1) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 得到f1函数的地址</span></span><br><span class="line">    <span class="type">uint64_t</span> f1_addr = *(<span class="type">uint64_t</span>*)(vtable + f1_offset);</span><br><span class="line">    <span class="comment">// 调用它，相面两行等效</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;leaq %0, %%rdi; callq *%1&quot;</span> : : <span class="string">&quot;m&quot;</span> (t), <span class="string">&quot;r&quot;</span> (f1_addr) : <span class="string">&quot;rdi&quot;</span>)</span></span>;</span><br><span class="line">    (t.*ptr2f1)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，我们首先在对象的首字处得到了虚表的地址<code>vtable</code>，然后通过成员函数指针的ptr部分得到了<code>f1</code>函数在虚表中的偏移量<code>f1_offset</code>。然后解引用得到了<code>f1</code>函数的地址，最后调用它。<code>rdi</code>寄存器存储<code>this</code>指针，这点前面已经谈过。最终结果与<code>(t.*ptr2f1)()</code>等价。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Itanium-C-ABI&quot;&gt;&lt;a href=&quot;#Itanium-C-ABI&quot; class=&quot;headerlink&quot; title=&quot;Itanium C++ ABI&quot;&gt;&lt;/a&gt;Itanium C++ ABI&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://itani</summary>
      
    
    
    
    <category term="C++" scheme="http://cyyzero.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>x64上Linux的系统调用</title>
    <link href="http://cyyzero.github.io/2019/02/02/x86/x64_syscall/"/>
    <id>http://cyyzero.github.io/2019/02/02/x86/x64_syscall/</id>
    <published>2019-02-02T13:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<p>x64上Linux的系统调用</p><p><strong>写在前面</strong>：本文希望读者有一定的Linux基础，了解过系统调用和crt的包装函数的区别。可以看我之前写过的关于<a href="https://cyyzero.herokuapp.com/articles/8">IA32上Linux系统调用的简介</a>，以及<a href="https://cyyzero.herokuapp.com/articles/19">《Linux内核设计与实现》一书中对系统调用的笔记</a>。</p><p>众所周知，在IA32上，Linux的系统调用是通过<code>int 0x80</code>中断，访问中断向量表，调用<code>sys_call()</code>。它通过<code>eax</code>传递系统调用号；其他一系列寄存器传递参数，分别存储在<code>ebx</code>，<code>ecx</code>，<code>edx</code>，<code>esi</code>，<code>edi</code>，<code>ebp</code>；返回值存储在<code>eax</code>。</p><p>现今，x86 64体系结构引入了一条专用指令<code>syscall</code>。它不访问中断描述符表，速度更快。它通过<code>rax</code>传递系统调用号；其他一系列寄存器传递参数，分别存储在<code>rdi</code>，<code>rsi</code>，<code>rdx</code>，<code>r10</code>，<code>r8</code>，<code>r9</code>；返回值存储在<code>rax</code>。</p><p>很明显，系统调用的ABI发生了剧烈的改变。进行系统调用的指令，传递系统调用号的寄存器，传递参数的寄存器，返回值的寄存器，甚至系统调用对应的编号，32位与64位都存在着很大的差异。理论上系统调用表都是向后兼容的，每次更新时只能往后添加系统调用号，已有的系统调用号则保持。我在Stack Exchange上找到了一个<a href="https://stackoverflow.com/questions/10281567/why-are-the-system-call-numbers-different-in-amd64-linux/10281881#10281881">回答</a>，解释了从32位到64位系统调用表更改的原因：x86 64体系结构出现时，ABI(传递参数、返回值)是不同的，因此内核开发人员利用这个机会带来了期待已久的更改，为了对高速缓存行使用级别进行优化。比如，常用的<code>sys_read/sys_write/sys_open/sys_close</code>分别位于前四个系统调用号；<code>sys_exit</code>原本很靠前(原本系统调用号为1)，但每个进程都在退出时才调用一次，所以现在是靠后的60作为系统调用号。</p><p>目测是为了兼容，我在内核版本为4.14.0的ubuntu上仍然能通<code>int 0x80</code>进行系统调用，下面是测试的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">section .data</span><br><span class="line">str: db &quot;Hello world&quot;</span><br><span class="line">str_len equ $-str</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">[bits 64]</span><br><span class="line">_start:</span><br><span class="line">    mov eax, 4           ; sys_write的系统调用号</span><br><span class="line">    mov ebx, 1           ; 第一个参数为int fd</span><br><span class="line">    mov ecx, str         ; 第二个参数为char *buf</span><br><span class="line">    mov edx, str_len     ; 第三个参数为size_t count</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">    mov eax, 1           ; sys_exit的系统调用号</span><br><span class="line">    mov ebx, 0           ; 第一个参数为int status</span><br><span class="line">    int 0x80</span><br></pre></td></tr></table></figure><p>不过，x86_64的Linux最好还是通过<code>syscall</code>进行系统调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">section .data</span><br><span class="line">str: db &quot;Hello world&quot;</span><br><span class="line">str_len equ $-str</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">[bits 64]</span><br><span class="line">_start:</span><br><span class="line">    mov eax, 1           ; 代表sys_write</span><br><span class="line">    mov rdi, 1           ; 第一个参数为int fd</span><br><span class="line">    mov rsi, str         ; 第二个参数为char *buf</span><br><span class="line">    mov rdx, str_len     ; 第三个参数为size_t count</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov eax, 60          ; sys_exit的系统调用号</span><br><span class="line">    mov rdi, 0           ; 第一个参数为int status</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;x64上Linux的系统调用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;：本文希望读者有一定的Linux基础，了解过系统调用和crt的包装函数的区别。可以看我之前写过的关于&lt;a href=&quot;https://cyyzero.herokuapp.com/artic</summary>
      
    
    
    
    <category term="x86" scheme="http://cyyzero.github.io/categories/x86/"/>
    
    
  </entry>
  
  <entry>
    <title>记 TLPI 上一个多线程代码例子的bug</title>
    <link href="http://cyyzero.github.io/2018/08/31/Linux/tlpi_thread_bug/"/>
    <id>http://cyyzero.github.io/2018/08/31/Linux/tlpi_thread_bug/</id>
    <published>2018-08-31T13:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<p>ps:<code>TLPI</code> 是 <code>The Linux Programming Interface</code> 一书的缩写。</p><hr><p>今天试着跑 <code>TLPI</code> 第30章上一个程序的时候，老是运行时出bug。程序不是很难，主要是讲解 <code>pthread</code> 条件变量的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> thread_died = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> thread_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> tot_threads = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num_live = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num_unjoined = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TS_ALIVE,</span><br><span class="line">    TS_TERMINATED,</span><br><span class="line">    TS_JOINED</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">tstate</span> <span class="title">state</span>;</span></span><br><span class="line">    <span class="type">int</span> sleep_time;</span><br><span class="line">&#125; *thread;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx = *((*<span class="type">int</span>)arg);</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    sleep(thread[idx].sleep_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %d terminating\n&quot;</span>, idx);</span><br><span class="line"></span><br><span class="line">    s = pthread_mutex_lock(&amp;thread_mutex);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    num_unjoined++;</span><br><span class="line">    thread[idx].state = TS_TERMINATED;</span><br><span class="line"></span><br><span class="line">    s = pthread_mutex_unlock(&amp;thread_mutex);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_cond_signal(&amp;thread_died);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_cond_signal&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s, idx;</span><br><span class="line"></span><br><span class="line">    thread = <span class="built_in">calloc</span>(argc - <span class="number">1</span>, <span class="keyword">sizeof</span>(*thread));</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>)</span><br><span class="line">        errExit(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; argc<span class="number">-1</span>; ++idx)</span><br><span class="line">    &#123;</span><br><span class="line">        thread[idx].sleep_time = getInt(argv[idx+<span class="number">1</span>], GN_NONNEG, <span class="literal">NULL</span>);</span><br><span class="line">        thread[idx].state = TS_ALIVE;</span><br><span class="line">        s = pthread_create(&amp;thread[idx].tid, <span class="literal">NULL</span>, thread_func, &amp;idx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tot_threads = argc - <span class="number">1</span>;</span><br><span class="line">    num_live = tot_threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (num_live &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = pthread_mutex_lock(&amp;thread_mutex);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num_unjoined == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = pthread_cond_wait(&amp;thread_died, &amp;thread_mutex);</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">                errExitEN(s, <span class="string">&quot;pthread_cond_wait&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; tot_threads; ++idx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (thread[idx].state == TS_TERMINATED)</span><br><span class="line">            &#123;</span><br><span class="line">                s = pthread_join(thread[idx].tid, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">                    errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line"></span><br><span class="line">                thread[idx].state = TS_JOINED;</span><br><span class="line">                num_live--;</span><br><span class="line">                num_unjoined--;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Reaped thread %d (num_live=%d)\n&quot;</span>, idx, num_live);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = pthread_mutex_unlock(&amp;thread_mutex);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来我调试的时候，却往往能够正常运行，但运行时候的错误却很一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out 1 2 1</span><br><span class="line">Thread 3 terminating</span><br><span class="line">Thread 1 terminating</span><br><span class="line">Thread 2 terminating</span><br></pre></td></tr></table></figure><p>然后就卡死…</p><p>仔细观察过输出结果，这是每次创建的线程中输出的结果。程序首先通过一个循环创建线程，然后把下标传址给线程作为参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数中</span></span><br><span class="line"><span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; argc<span class="number">-1</span>; ++idx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    s = pthread_create(&amp;thread[idx].tid, <span class="literal">NULL</span>, thread_func, &amp;idx);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在线程中，每次都将对idx解引用，得到下标，并输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个新线程的函数中, arg是传进的参数</span></span><br><span class="line"><span class="type">int</span> idx = *((*<span class="type">int</span>)arg);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Thread %d terminating\n&quot;</span>, idx);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>可能大家也可以看出来了，妥妥的 <em>race condition</em>，多个线程通过指针访问同一个变量，没有进行同步和互斥的工作。有可能新的线程直到循环中的下标自增之后才执行解引用（实际上在我电脑上就是按照这个顺序执行了）。</p><p>比较简单的修改方法就是将<code>int</code>类型的下标直接强制转化成<code>void *</code>的类型的参数传值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在main函数里：</span></span><br><span class="line"><span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; argc<span class="number">-1</span>; ++idx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    s = pthread_create(&amp;thread[idx].tid, <span class="literal">NULL</span>, thread_func, (<span class="type">void</span>*)idx);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新线程的函数里</span></span><br><span class="line"><span class="type">int</span> idx = (<span class="type">int</span>)arg;</span><br></pre></td></tr></table></figure><p>这个改法看似简单，但其实有点问题。因为在C标准里整形和指针类型的强制转化是 <code>implementation-defined</code>。一下摘抄自<a href="https://en.cppreference.com/w/c/language/cast">cppreference</a>：</p><blockquote><p>Any integer can be cast to any pointer type. Except for the null pointer constants such as NULL (which doesn’t need a cast), the result is implementation-defined, may not be correctly aligned, may not point to an object of the referenced type, and may be a trap representation. </p></blockquote><blockquote><p>Any pointer type can be cast to any integer type. The result is implementation-defined, even for null pointer values (they do not necessarily result in the value zero). If the result cannot be represented in the target type, the behavior is undefined (unsigned integers do not implement modulo arithmetic on a cast from pointer) </p></blockquote><p>事实上，在64位x86上，指针类型占8字节，<code>int</code>类型占4字节，用脚趾头都知道它们之间的转化很不安全。</p><p>在 <a href="http://www.man7.org/tlpi/errata/index.html">TLPI 官网上的勘误</a>中也提到了这个错误，上面还给了两种避免指针和整型转化的方法。</p><ul><li><p>一种解决方法是把当前 <code>thread[idx]</code> 地址传过去，这样只需进行不同指针的转化，这是C语言允许的。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = pthread_create(&amp;thread[idx].tid, <span class="literal">NULL</span>, threadFunc, &amp;thread[idx]);</span><br></pre></td></tr></table></figure><p>  然后线程的函数中只需要对传入的地址和首元素地址进行相减就能得到相应的下标：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tinfo</span> *<span class="title">tptr</span> =</span> arg;</span><br><span class="line"><span class="type">int</span> idx = tptr - thread;    <span class="comment">/* Obtain index in &#x27;thread&#x27; array */</span></span><br></pre></td></tr></table></figure></li><li><p>另一个解决方法就是用 <code>uintptr_t</code> 代替 <code>int</code> 类型。<code>unitptr_t</code> 类型是从C99标准开始有的类型，定义在头文件 <code>&lt;stdint.h&gt;</code> 中。它用来表示一个能够容纳指针值的无符号整型。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ps:&lt;code&gt;TLPI&lt;/code&gt; 是 &lt;code&gt;The Linux Programming Interface&lt;/code&gt; 一书的缩写。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;今天试着跑 &lt;code&gt;TLPI&lt;/code&gt; 第30章上一个程序的时候，老是运行时出bug。程序不</summary>
      
    
    
    
    <category term="Linux" scheme="http://cyyzero.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>《Linux内核设计与实现》读书笔记——系统调用</title>
    <link href="http://cyyzero.github.io/2018/08/23/Linux/LKD_syscall/"/>
    <id>http://cyyzero.github.io/2018/08/23/Linux/LKD_syscall/</id>
    <published>2018-08-23T13:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<p><em>写在前面</em>：之前我粗略的整理过<code>linux</code>在IA32处理器上的系统调用的过程…这篇就当做补充和复习了。</p><hr><h2 id="与内核通信"><a href="#与内核通信" class="headerlink" title="与内核通信"></a>与内核通信</h2><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层。在Linux中，系统调用是用户空间访问内核的唯一手段：除了异常和陷入外，它们是内核唯一的合法入口。</p><h2 id="API、POSIX-和-C库"><a href="#API、POSIX-和-C库" class="headerlink" title="API、POSIX 和 C库"></a>API、POSIX 和 C库</h2><p>一般情况下，应用程序都是直接调用在用户空间实现的<code>API</code>来编程，而不是直接通过系统调用。这些API与系统调用也并非一一对应(甚至不使用系统调用)。举个简单的例子，应用程序调用C库中的<code>printf()</code>，C库中的<code>printf()</code>再调用C库中的<code>write()</code>，而C库中<code>write()</code>才调用内核提供的<code>write()</code>系统调用。</p><p>不难想到，通过一套标准来规范 API ，就能带来源码级的移植性。而在Unix世界里，<code>POSIX</code>标准最为流行。</p><p>在<code>Linux</code>中，C库实现了Unix系统的主要API，包括标准库规定的函数以及封装的系统调用接口。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>进行系统调用(<code>syscall</code>)，通常可以通过C库中的函数来完成。内核必须提供系统调用需要完成的功能，但是在实现上没有规定。这也是Unix哲学中的“<em>separating mechanism and policy</em>”。</p><p>举个例子，<code>getpid()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(getpid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> task_tpid_vnr(current);  <span class="comment">// return current-&gt;tgid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>SYSCALL_DEFINE0</code>是个宏，展开后代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure><p>这里的<code>asmlinkage</code>是gcc的拓展，用于通知编译器仅从栈中提取该函数的参数。所有系统调用都有这个限定词。其次，函数返回<code>long</code>类型，为了保证32位和64位系统的兼容。系统调用在用户空间返回值类型为int，在内核空间返回值类型为long。最后，形如<code>sys_bar()</code>是在Linux中的命名规则。</p><h3 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h3><p>Linux中的每个系统调用被赋予一个系统调用号。用户态的进程通过这个号来指明进行哪个系统调用；进程不会提及系统调用的名称。</p><p>内核记录了系统调用表中所有已经注册的系统调用的列表，存储在<code>sys_call_table</code>中。</p><h3 id="系统调用的性能"><a href="#系统调用的性能" class="headerlink" title="系统调用的性能"></a>系统调用的性能</h3><p>Linux系统调用很快，一个原因是上下文切换快，进出内核被优化地简洁高效，另一个原因是系统调用处理程序和系统调用本身也十分简洁。</p><h2 id="系统调用处理程序"><a href="#系统调用处理程序" class="headerlink" title="系统调用处理程序"></a>系统调用处理程序</h2><p>应用程序通过软中断通知内核，告诉内核需要进行系统调用：引发一个异常来促使系统切换到内核态去执行异常处理程序。<code>x86</code>上系统预定义的软中断号是<code>128</code>，通过<code>int $0x80</code>指令触发该中断。这条指令会触发一个异常导致系统切换到内核态并执行第<code>128</code>号异常处理程序。而该程序正是系统调用处理程序，叫<code>system_call()</code>。它与硬件体系结构密切相关。最近，<code>x86</code>处理器增加了一条叫做<code>sysenter</code>的指令。与<code>int</code>指令相比，这条指令提供了更快，更专业的陷入内核进行系统调用的方式。</p><h3 id="制定恰当的系统调用"><a href="#制定恰当的系统调用" class="headerlink" title="制定恰当的系统调用"></a>制定恰当的系统调用</h3><p>在<code>x86</code>上系统调用号通过<code>eax</code>寄存器传递给内核。在陷入内核前，用户空间把相应的系统调用号放入<code>eax</code>中。其他体系结构上类似。</p><p><code>system_call()</code>通过将给定的系统调用号与<code>NR_syscalls</code>做比较来检查其有效性。如果它大于或等于<code>NR_syscalls</code>，该函数就返回<code>-ENOSYS</code>。否则，执行相应的系统调用：<code>call *sys_call_table(,%rax,8)</code>。</p><p>由于系统调用表中的表项是以64位(8字节)类型存放的，所以内核需要将给定的系统调用号乘以8。<code>x86-32</code>系统上，就用4代替8。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>除了系统调用号外，大部分系统调用还需要一些外部的参数传入。在<code>x86-32</code>系统上，<code>ebx</code>，<code>ecx</code>，<code>edx</code>，<code>esi</code>按照顺序存放前5个参数。需要6个或者6个以上的情况不多见，此时应该用一个单独的寄存器存放指向这些参数在用户空间地址的指针。</p><p>给用户空间的返回值也通过寄存器传递。在x86系统上，它存放在<code>eax</code>寄存器中。</p><h2 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h2><p>一个Linux系统调用在实现时不需要太关心它的系统调用处理程序的关系，给linux添加一个系统调用相对容易。</p><h3 id="实现系统调用"><a href="#实现系统调用" class="headerlink" title="实现系统调用"></a>实现系统调用</h3><p>一个系统调用应该有明确的用途，不提倡通过传递不同的参数来选择完成不同的工作。<code>ioctl()</code>就是一个反面例子。还要求时刻注意可移植性和健壮性。</p><h3 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h3><p>系统调用必须验证它们所有的参数是否合法有效。系统调用在内核空间执行，如果任由用户将不合法的输入传递个内核，那么安全性和稳定性将没有保障。</p><p>最重要的一种检查就是指针是否有效。内核必须保证：</p><ul><li>指针指向的内存区域属于用户空间。</li><li>指针指向的内存区域在进程的地址空间内。</li><li>如果是读，该内存应被标记为可读；如果是写，该内存应被标记为可写；如果是可执行，该内存应被标记为可执行。</li></ul><p>内核提供了两个方法用于完成必须的检查和内核空间与用户空间数据的来回拷贝。</p><ul><li><p><code>copy_to_user()</code>，向用户空间写入数据，需要三个参数。第一个是进程空间中的目的内存地址，第二个是内核空间中的源地址，最后一个是字节数。</p></li><li><p><code>copy-from_user()</code>，从用户空间读数据。它的三个参数和<code>copy_to_user()</code>类似。</p></li></ul><p>如果执行失败，这两个函数返回的都是没能完成拷贝的数据字节数；如果成功，返回0。当出现上述错误，系统调用返回标准<code>-EFAULT</code>。注意，这两个函数都有可能引起阻塞，当缺页的时候。</p><p>最后一项检查针对是否有合法权限。调用者可以通过<code>capable()</code>函数来检查是否有权能对制定的资源进行操作。如果返回非0就有权，否则无权。</p><h2 id="系统调用上下文"><a href="#系统调用上下文" class="headerlink" title="系统调用上下文"></a>系统调用上下文</h2><p>内核在执行系统调用的时候处于进程上下文，<code>current</code>指针指向当前任务。</p><p>在进程上下文中，内核可以休眠并且可以被抢占。当系统调用返回的时候，控制权仍在<code>system_call()</code>中，它最终会负责切换到用户空间，并让用户进程继续执行下去。</p><h3 id="绑定一个系统调用的最后一个步骤"><a href="#绑定一个系统调用的最后一个步骤" class="headerlink" title="绑定一个系统调用的最后一个步骤"></a>绑定一个系统调用的最后一个步骤</h3><p>当编写完一个系统调用后，把它注册成一个正式的系统调用：</p><ul><li>首先，在系统调用表的最后一项加入一个表项。</li><li>对于所支持的各种体系结构，系统调用号必须定义于<code>&lt;asm/unistd.h&gt;</code>中。</li><li>系统调用必须被编译进内核映像。这只要把它放进<code>kernel/</code>下的一个相关文件中就可以了，如<code>sys.c</code>，它包含了各种各样的系统调用。</li></ul><h3 id="从用户空间访问系统调用"><a href="#从用户空间访问系统调用" class="headerlink" title="从用户空间访问系统调用"></a>从用户空间访问系统调用</h3><p>通常，系统调用靠C库支持。用户程序通过包含头文件并和C库链接，就可以使用系统调用。但如果你如果仅仅写出了系统调用，glibc并不提供支持。可以通过Linux本身提供的一组宏，直接对系统调用进行访问。这些宏是<code>_syscalln()</code>，n的范围从0到6，代表需要传递给系统调用的参数个数。对于每个宏，都有<code>2+2×n</code>个参数。第一个参数表示返回值类型，第二个参数是系统调用的名称，接着是按照系统调用参数顺序排列的每个参数的类型和名称。</p><p>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于 long open(const char *filename, int flags, int mode)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_open 5</span></span><br><span class="line">_syscall3(<span class="type">long</span>, open, <span class="type">const</span> <span class="type">char</span> *, filename, <span class="type">int</span>, flags, <span class="type">int</span>, mode)</span><br></pre></td></tr></table></figure><p>这组宏会被拓展成内嵌汇编的C函数。</p><h2 id="为什么不通过建立系统调用的方式实现"><a href="#为什么不通过建立系统调用的方式实现" class="headerlink" title="为什么不通过建立系统调用的方式实现"></a>为什么不通过建立系统调用的方式实现</h2><p>Linux系统尽量避免没出现一种新的抽象就加入一个新的系统调用，这使得它的系统调用接口十分简洁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;写在前面&lt;/em&gt;：之前我粗略的整理过&lt;code&gt;linux&lt;/code&gt;在IA32处理器上的系统调用的过程…这篇就当做补充和复习了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;与内核通信&quot;&gt;&lt;a href=&quot;#与内核通信&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="Linux" scheme="http://cyyzero.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>《Linux内核设计与实现》读书笔记——进程调度</title>
    <link href="http://cyyzero.github.io/2018/08/02/Linux/LKD_scheduler/"/>
    <id>http://cyyzero.github.io/2018/08/02/Linux/LKD_scheduler/</id>
    <published>2018-08-02T13:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<p>进程调度程序是确保进程能有效工作的一个内核子系统。</p><h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p>多任务可以分为两类：</p><ul><li>非抢占式多任务(cooperative multitasking)。除非进程自己主动停止运行，否则它会一直执行。进程主动让出自己的操作称为让步(yielding)。</li><li>抢占式多任务(preemtive multitasking)。Linux提供了抢占式的多任务模式。由进程调度程序来决定什么时候停止一个进程的运行。这个强制的挂起动作就叫做抢占(preemption)。进程在被抢占之前能够运行的时间叫做时间片(timeslice)。</li></ul><h2 id="Linux的进程调度"><a href="#Linux的进程调度" class="headerlink" title="Linux的进程调度"></a>Linux的进程调度</h2><p>从1991年的Linux第一版到后来的2.4内核系列，Linux的调度程序都相当简陋，设计近乎原始。在Linux2.5开发系列的内核中，采用了一种叫做<code>O(1)</code>调度程序的新调度程序。就如它的名字，时间复杂度是<code>O(1)</code>。</p><p><code>O(1)</code>调度器在拥有数以十计的多处理器环境下尚能表现出近乎完美的性能和可拓展性，但是对于响应时间敏感的交互进程来说却有一些先天不足。从2.6内核系统开发初期，开发人员引入了新的调度算法。其中最有名的是<em>反转楼梯最后期限调度算法(<code>Rotating Staircase Deadline scheduler</code>)</em>(<code>RSDL</code>)。该算法吸取了队列理论，将公平调度的概念引入了Linux调度程序，并最终在2.6.23内核版本中替代了<code>O(1)</code>调度算法。它被称为完全公平调度算法(CFS)。</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>策略决定调度程序在何时让什么进程运行。</p><h3 id="I-O消耗型和处理器消耗型的进程"><a href="#I-O消耗型和处理器消耗型的进程" class="headerlink" title="I&#x2F;O消耗型和处理器消耗型的进程"></a>I&#x2F;O消耗型和处理器消耗型的进程</h3><p>进程可被分为I&#x2F;O消耗型和处理器消耗型。前者指进程的大部分时间都用来提交或等待I&#x2F;O请求。相反，处理器消耗型则大部分时间都用在执行代码上。当然两者的划分并非泾渭分明。</p><p>调度策略通常就要在两个矛盾的目标中寻找平衡：进程相应迅速和最大系统利用率。</p><h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>Linux采用了两种不同的优先级范围。</p><p>第一种是使用nice值，范围是-20～+19，默认为0。越大的nice值意味着优先级越低。nice值代表时间片的比例。可以通过<code>ps -el</code>查看，<code>NI</code>列表示的就是nice值。</p><p>第二种范围是实时优先级，其范围是可配置的。默认情况下它的变化范围是[0, 99]。与nice值相反，越高的实时优先级代表进程优先级更高。任何实时进程的优先级都高于普通进程，也就是说nice优先级和实时优先级处于互不相交的两个范畴。</p><h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><p>时间片是一个数值，表明进程在被抢占前能持续运行的时间。调度策略需要规定默认的一个时间片。但时间片过长会导致系统对交互的效应表现欠佳，过段会明显增加进程切换带来的处理器耗时。而且I&#x2F;O消耗型和处理器消耗型的矛盾也显示出来：I&#x2F;O消耗型不需要过长时间片，而处理器消耗型则希望越长越好。</p><p>Linux的CFS调度并没有直接分配时间片到进程，而是讲处理器的使用比例划分给了进程。这样一来，进程所获得的处理器时间其实是和系统负载有关。抢占时机也取决于新的可运行程序消耗了多少处理器使用比。</p><h2 id="Linux调度算法"><a href="#Linux调度算法" class="headerlink" title="Linux调度算法"></a>Linux调度算法</h2><h3 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h3><p>Linux调度器是以模块方式提供的，称为调度器类(<code>scheduler classes</code>)，不同类型的进程可以有针对性地选择调度算法。基础的调度器类代码定义在<code>kernel/sched.c</code>文件中，它会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类胜出。</p><p>CFS是一个针对简单进程的调度类，在Linux中称为<code>SCHED_NORMAL</code>。</p><h3 id="Unix系统中的进程调度"><a href="#Unix系统中的进程调度" class="headerlink" title="Unix系统中的进程调度"></a>Unix系统中的进程调度</h3><p>在Unix系统上，优先级以nice值形式输出给用户空间。在现实中会产生许多问题。</p><ul><li><p>若要讲nice值映射到时间片，就必然需要将nice单位值对应到处理器的绝对时间。但这样做会导致进程切换无法最优化执行。举例说明，默认nice值为0分配100ms的时间片，最高nice值为20分配5ms。如果同时运行时间片5ms的进程，则要在10ms间进行一次上下文切换；而运行时间片是100ms的进程，则要在100ms间进行一次上下文切换。</p></li><li><p>相对nice值。假设两个进程nice值分别是0和1，时间片分别是100ms和95ms，区别微乎其微。而两个进程nice值分别为18和19，时间片分别为10ms和5ms，前者是后者的两倍！</p></li><li><p>如果执行nice值到时间片的映射，需要能分配一个绝对时间片，而这个绝对时间片必须能在内核的测试范围内。</p></li><li><p>最后一个问题是关于基于优先级的调度器会为了优化交互任务而唤醒相关进程的问题。</p></li></ul><h3 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h3><p>CFS的做法是允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程，而不再采用分配给每个进程时间片的做法了。CFS在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠nice值来计算时间片。nice值在CFS中被作为进程获得处理器运行比的权重。</p><p>每个进程都按照其权重在其全部可运行进程中所占比例的时间片来运行。CFS为完美多任务中的无限小调度周期的近似值设立了一个目标。这个目标称为目标延迟。假定目标延迟值是20ms，两个同样优先级的可运行任务会分别运行10ms。</p><p>CFS还为每个进程设置了时间片底线，这个底线称为最小粒度。默认情况下是1ms。</p><p>任何进程所获得的处理器时间是由它自己和其他所有可运行进程nice值对应的绝对时差值决定的。nice值对时间片的作用是几何加权。</p><h2 id="Linux调度的实现"><a href="#Linux调度的实现" class="headerlink" title="Linux调度的实现"></a>Linux调度的实现</h2><p>CFS位于<code>kernel/sched_fair.c</code>中。特别关注四个组成部分：</p><ul><li>时间记账</li><li>进程选择</li><li>调度器入口</li><li>睡眠和唤醒</li></ul><h3 id="时间记账"><a href="#时间记账" class="headerlink" title="时间记账"></a>时间记账</h3><p>所有调度器都必须对进程运行时间做记账。</p><h4 id="调度器实体结构"><a href="#调度器实体结构" class="headerlink" title="调度器实体结构"></a>调度器实体结构</h4><p>CFS不再有时间片的概念，但是它也必须维护每个进程运行的时间记账。CFS使用<code>sched_entity</code>来跟踪进程运行记账：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span> <span class="comment">/* for load-balancing */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">run_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">group_node</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> on_rq;</span><br><span class="line"></span><br><span class="line">    u64 exec_start;</span><br><span class="line">    u64 sum_exec_runtime;</span><br><span class="line">    u64 vruntime;</span><br><span class="line">    u64 prev_sum_exec_runtime;</span><br><span class="line"></span><br><span class="line">    u64 nr_migrations;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SCHEDSTATS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_statistics</span> <span class="title">statistics</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="comment">/* rq on which this entity is (to be) queued: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span></span><br><span class="line">    <span class="comment">/* rq &quot;owned&quot; by this entity/group: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">my_q</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sched_entity</code>作为PCB中一个名为<code>se</code>的成员变量。</p><h4 id="虚拟实时"><a href="#虚拟实时" class="headerlink" title="虚拟实时"></a>虚拟实时</h4><p><code>vruntime</code>变量存放进程的虚拟运行时间，该运行时间的计算是经过了所有可运行进程总数的标准化。虚拟时间是以ns为单位的。CFS用<code>vruntime</code>变量来记录一个程序到底运行了多长时间以及它还应该再运行多久。</p><h3 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a>进程选择</h3><p>CFS调度算法的核心：当CFS需要选择下一个运行进程时，它会挑一个具有最小<code>vruntime</code>的进程。接下来就讨论如何选择具有最小<code>vruntime</code>值的进程。</p><p>CFS使用红黑树来组织可运行进程队列，并利用其迅速找到最小<code>vruntime</code>值的进程。</p><h4 id="挑选下一个任务"><a href="#挑选下一个任务" class="headerlink" title="挑选下一个任务"></a>挑选下一个任务</h4><p>先假设，红黑树存储了系统中所有的可运行进程，其中节点的键值是可运行进程的虚拟运行时间。那么树中最左侧的叶子节点，就是所有<code>vruntime</code>最小的那个。</p><h4 id="向树中加入进程"><a href="#向树中加入进程" class="headerlink" title="向树中加入进程"></a>向树中加入进程</h4><p>CFS在进程变为可运行状态(被唤醒)或者通过<code>fork()</code>调用第一次创建进程时，将进程加入<em>rbtree</em>中，并且缓存最右子节点。</p><h4 id="从树中删除进程"><a href="#从树中删除进程" class="headerlink" title="从树中删除进程"></a>从树中删除进程</h4><p>CFS从红黑树中删除进程，删除动作发生在进程堵塞(变为不可运行态)或者终止时(结束运行)。</p><h3 id="调度器入口"><a href="#调度器入口" class="headerlink" title="调度器入口"></a>调度器入口</h3><p>进程调度的主要入口点是函数<code>schedule()</code>。它选择哪个进程可以运行，何时将其投入运行。<code>schedule()</code>会找到一个最高优先级的调度类——后者需要有自己的可运行队列，然后问后者谁才是下一个该运行的进程。</p><h3 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h3><p>休眠(被阻塞)的进程处于一个特殊的不可执行状态。当进程休眠时，内核的操作如下：进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用<code>schedule()</code>选择和执行一个其他进程。唤醒的过程正好相反：进程被设置成可执行状态，然后从可执行队列中移到可执行红黑树中。</p><h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>休眠通过等待队列进行处理。等待队列是由等待某些事件发生的进程组成的简单链表。内核通过<code>wake_queue_head_t</code>来代表等待队列。</p><p>在内核中进行休眠的推荐操作相对复杂：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// q是我们希望休眠的等待队列</span></span><br><span class="line">DEFINE_WAIT(wait);</span><br><span class="line"></span><br><span class="line">add_wait_queue(q, &amp;wait);</span><br><span class="line"><span class="keyword">while</span> (!condition)</span><br><span class="line">&#123;</span><br><span class="line">    prepare_to_wait(&amp;q, &amp;wait, TASK_INTERRUPTIBLE)；</span><br><span class="line">    <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">        <span class="comment">/* 处理信号 */</span></span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br><span class="line">finish_wait(&amp;q, &amp;wait);</span><br></pre></td></tr></table></figure><h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><p>唤醒操作通过函数<code>wake_up()</code>进行。它会唤醒执行的等待队列上的所有进程。</p><h2 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h2><p>这里的上下文切换是指进程间的切换，由定义在<code>kernel/sched.c</code>中的<code>context_switch()</code>函数负责处理。每当一个新的进程被选出来投入运行的时候，<code>schedule()</code>会调用该函数。它完成两个基本的工作：</p><p>-调用声明在<code>asm/mmu_context.h</code>中的<code>switch_mm()</code>，负责把虚拟内存从上一个进程映射切换到新进程中。</p><ul><li>调用声明<code>asm/system.h</code>中的<code>switch_to()</code>，负责从上一个进程的处理器状态切换到新进程的处理器状态。</li></ul><p>内核提供了一个<code>need_resched</code>标志来表明是否需要重新执行一次调度。当某个进程应该被抢占时，<code>scheduler_tick()</code>就会设置这个标志；当一个优先级高的进程进入可执行状态的时候，<code>try_to_wake_up()</code>也会设置这个标志，内核检查该标志，确认其被设置，调用<code>schedule()</code>来切换到一个新的进程。</p><p>在2.2以前的内核版本中，该标志位曾是一个全局变量，2.2~2.4版的内核中它在<code>task_struct</code>中。而在2.6版中，它被移到<code>thread_info</code>结构体里，用一个特别的标志变量中的一位来表示。</p><h3 id="用户抢占"><a href="#用户抢占" class="headerlink" title="用户抢占"></a>用户抢占</h3><p>用户抢占发生在一下情况：</p><ul><li>从系统调用返回用户空间时</li><li>从中断处理程序返回用户空间时</li></ul><p>总而言之，内核即将返回用户空间的时候，如果<code>need_resched</code>标志被置位，会导致<code>schedule()</code>被调用。</p><h3 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h3><p>大部分的Unix变体不支持内核抢占，调度程序没有办法在内核级的任务正在执行的时候重新调度——内核中的任务是以协作的方式调度的，不具备抢占性。</p><p>Linux在2.6版本的内核中，引入了内核抢占。只要重新调度是安全的，内核就可以在任何时候抢占正在执行的任务。它发生在：</p><ul><li>中断处理程序正在运行，并且返回内核空间之前。</li><li>内核代码再一次具有可抢占性的时候。</li><li>如果内核中的任务显示地调用<code>schedule()</code>。</li><li>如果内核中的任务阻塞(这也会导致调用<code>schedule()</code>)。</li></ul><h2 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a>实时调度策略</h2><p>Linux提供了两种实时调度策略：<code>SCHED_FIFO</code>和<code>SCHED_RR</code>。而普通的非实时的调度策略是<code>SCHED_NORMAL</code>。这些实时调度器并不被CFS管理，而是被一个特殊的实时调度器管理。</p><h2 id="与调度相关的系统调用"><a href="#与调度相关的系统调用" class="headerlink" title="与调度相关的系统调用"></a>与调度相关的系统调用</h2><p>主要通过C库提供的<code>nice()</code>和<code>sched_xxxx()</code>系列函数。基本都是和系统调用的简单对应。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;进程调度程序是确保进程能有效工作的一个内核子系统。&lt;/p&gt;
&lt;h2 id=&quot;多任务&quot;&gt;&lt;a href=&quot;#多任务&quot; class=&quot;headerlink&quot; title=&quot;多任务&quot;&gt;&lt;/a&gt;多任务&lt;/h2&gt;&lt;p&gt;多任务可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非抢占式多任务(c</summary>
      
    
    
    
    <category term="Linux" scheme="http://cyyzero.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>《Linux内核设计与实现》读书笔记——进程</title>
    <link href="http://cyyzero.github.io/2018/07/27/Linux/LKD_process/"/>
    <id>http://cyyzero.github.io/2018/07/27/Linux/LKD_process/</id>
    <published>2018-07-27T13:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<p>发现读书不记笔记还是不行，过两天就忘得差不多了…最近在看《Linux内核设计与实现》，决定记些笔记。我可能有讲错的地方，一切以书上的讲解以及<em>Linux 2.6.X</em>源码为准  （逃</p><hr><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程包括执行的代码，数据，打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间以及一个或多个执行线程。实际上，进程就是正在执行的程序代码的实时结果。</p><p>执行线程，简称线程，是进程中活动的独享。每个线程有一个独立的程序计数器、进程栈和一组进程寄存器。Linux对进程和线程并不特别区分，线程只不过是一种特殊的进程。调度的对象是线程。</p><p>熟悉Unix&#x2F;Linux系统编程的童鞋都知道，<code>fork()</code>函数通过复制一个已有的进程来创建一个全新的进程。然后可能会用<code>exec()</code>函数创建新的地址空间，然后把新的程序载入其中。最终通过<code>exit()</code>系统调用退出执行，并把占有的资源释放。父进程可以通过<code>wait4()</code>系统调用查询子进程是否终结。进程退出后被设置为僵死状态，直到父进程调用<code>wait()</code>或者<code>waitid()</code>为止。</p><p>需要注意的是，Linux上实现<code>fork()</code>是用的<code>clone()</code>系统调用。</p><h2 id="进程描述符及任务结构"><a href="#进程描述符及任务结构" class="headerlink" title="进程描述符及任务结构"></a>进程描述符及任务结构</h2><p>内核把进程的列表放在叫做 <code>task list</code> 的双向循环链表中。链表中的每个项目类型为 <code>task_struct</code>，称为进程描述符(process descriptor)的结构。进程描述符中包含一个具体进程的所有信息，包括：打开的文件、进程的地址空间、挂起的信号、进程的状态，还有其他的信息。</p><h3 id="分配进程描述符"><a href="#分配进程描述符" class="headerlink" title="分配进程描述符"></a>分配进程描述符</h3><p>Linux 通过 <code>slab</code> 分配器分配 <code>task_struct</code> 结构，能达到对象复用和缓存着色(cache coloring)的目的。在内核栈的栈底(当然，这是对于向下增长的栈来说)创建爱你一个新的结构 <code>struct thread_info</code>，</p><p>在X86上，<code>thread_info</code>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span>        <span class="comment">/* main task structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span> *<span class="title">exec_domain</span>;</span> <span class="comment">/* execution domain */</span></span><br><span class="line">    __u32 flags;                     <span class="comment">/* low level flags */</span></span><br><span class="line">    __u32 status;                    <span class="comment">/* thread synchronous flags */</span></span><br><span class="line">    __u32 cpu;                       <span class="comment">/* current CPU */</span></span><br><span class="line">    <span class="type">int</span> preempt_count;               <span class="comment">/* 0 =&gt; preemptable,</span></span><br><span class="line"><span class="comment">                                        &lt;0 =&gt; BUG */</span></span><br><span class="line">    <span class="type">mm_segment_t</span> addr_limit;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> <span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="type">void</span> __user *sysenter_return;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> previous_esp;      <span class="comment">/* ESP of the previous stack in</span></span><br><span class="line"><span class="comment">                                        case of nested (IRQ) stacks</span></span><br><span class="line"><span class="comment">                                     */</span></span><br><span class="line">    __u8 supervisor_stack[<span class="number">0</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> uaccess_err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>struct task_struct *task</code> 是指向该任务实际 <code>task_struct</code> 的指针。</p><h3 id="进程描述符的存放"><a href="#进程描述符的存放" class="headerlink" title="进程描述符的存放"></a>进程描述符的存放</h3><p>内核通过一个唯一的 <code>PID</code> 来标识每个进程。PID是一个数字，为 <code>pid_t</code> 类型。</p><p>在内核中，访问任务通常需要通过 <code>current</code> 宏获得指向其 <code>task_struct</code> 的指针。<code>current</code> 针对专门的硬件体系结构有不同的定义。在X86上，<code>current</code> 把栈指针的后13个有效位屏蔽掉，用来计算出 <code>thread_info</code> 的偏移。该操作是通过 <code>current_thread_info()</code> 函数来完成的。然后从得到的 <code>thread_info</code> 的 <code>task</code> 域中提取并返回 <code>task_struct</code> 的地址： <code>current_thread_info()-&gt;task</code>。</p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>进程描述符中的 <code>state</code> 域描述了进程的当前状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Task state bitmask. NOTE! These bits are also</span></span><br><span class="line"><span class="comment"> * encoded in fs/proc/array.c: get_task_state().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We have two separate sets of flags: task-&gt;state</span></span><br><span class="line"><span class="comment"> * is about runnability, while task-&gt;exit_state are</span></span><br><span class="line"><span class="comment"> * about the task exiting. Confusing, but this way</span></span><br><span class="line"><span class="comment"> * modifying one set can&#x27;t modify the other one by</span></span><br><span class="line"><span class="comment"> * mistake.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING         0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_INTERRUPTIBLE   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_STOPPED       4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_TRACED        8</span></span><br><span class="line"><span class="comment">/* in tsk-&gt;exit_state */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_ZOMBIE         16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_DEAD           32</span></span><br><span class="line"><span class="comment">/* in tsk-&gt;state again */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_DEAD           64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKEKILL      128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKING        256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STATE_MAX     512</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>state</code>的状态有五个：</p><ul><li>TASK_RUNNING（运行）： 进程是可执行的。它正在执行，或者在运行队列中等待执行。</li><li>TASK_INTERRUPTIBLE（可中断）： 进程正在睡眠，也就是被阻塞，等待某些条件达成。一旦这些条件达成，内核就会把进程的状态设为运行。处于此状态的进程也会因为接收到信号而提前被唤醒并素食准备投入运行。</li><li>TASK_UNINTERRUPTIBLE（不可中断）：除了就算是接收信号也不会被唤醒或准备投入运行外，这个状态与可打断状态相同。</li><li>__TASK_STOPPED（停止）：进程停止执行。通常发生在接收到SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU等信号的时候。</li><li>__TASK_TRACED：被其他进程跟踪的进程。</li></ul><h3 id="设置当前进程状态"><a href="#设置当前进程状态" class="headerlink" title="设置当前进程状态"></a>设置当前进程状态</h3><p>一般通过 <code>set_task_state(task, state)</code> 这个函数。<code>set_current_state(state)</code> 和 <code>set_task_state(current, state)</code> 含义是等同的。</p><h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><p>可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行。当执行了系统调用或者出发了某个异常，它就陷入了内核空间。此时，我们称内核“代表进程执行”并处于进程上下文中。此时 <code>current</code> 宏是有效的。</p><h3 id="进程家族树"><a href="#进程家族树" class="headerlink" title="进程家族树"></a>进程家族树</h3><p>Linux中进程有明显的继承关系，所有的进程都是 PID 为 1 的 <code>init</code> 进程的后代。内核在启动的最后阶段启动 <code>init</code> 进程。该进程读取系统的初始化脚本(initscript)并执行其他的相关程序。</p><p>每个进程都有一个父进程，零个或多个子进程。每个 <code>task_struct</code> 都包含一个指向其父进程叫做 <code>parent</code> 的指针，还包含一个称为 <code>children</code> 的子进程链表。</p><p>对于当前进程，可以通过下面的代码获得其父进程的进程描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">my_parent</span> =</span> current-&gt;parent;</span><br></pre></td></tr></table></figure><p>同样，也可以按下面的方式依次访问子进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each(<span class="built_in">list</span>, &amp;current-&gt;children)</span><br><span class="line">&#123;</span><br><span class="line">    task = list_entry(<span class="built_in">list</span>, <span class="keyword">struct</span> task_struct, sibling);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init</code> 进程的描述符是作为 <code>init_task</code> 静态分配的。向上遍历的方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="keyword">for</span> (task = current; task != &amp;init_task; task = task-&gt;parent)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>可以通过这个树型结构，从任何一个进程出发，查找任意指定的其他进程。但很多时候，只需要通过简单的遍历，因为任务队列本来就是一个双向的循环链表。</p><p>对于给定的进程，获取链表的下一个进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_entry(task-&gt;tasks.next, <span class="keyword">struct</span> task_struct, tasks)</span><br></pre></td></tr></table></figure><p>获取前一个进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_entry(task-&gt;tasks.prev, <span class="keyword">struct</span> task_struct, tasks)</span><br></pre></td></tr></table></figure><p><code>for_each_process(task)</code> 宏提供了依次访问整个任务队列的能力。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"></span><br><span class="line">for_each_process(task)</span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s[%d]\n&quot;</span>, task-&gt;comm, task-&gt;pid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>Unix 通过<code>fork()</code>拷贝当前进程创建一个子进程，然后通过<code>exec()</code>函数负责读取可执行文件并将其载入地址空间开始运行。</p><h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><p>Linux的<code>fork()</code>采用写时拷贝（copy-on-write）页实现。写时拷贝是一种推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父进程和子进程共享一个拷贝。只有在需要写入的时候，数据才会被复制。这种技术使得地址空间上页的拷贝被推迟到实际发生写入的时候才进行。<code>fork()</code>的实际开销就是赋值父进程的页表以及给子进程创建唯一的进程描述符。</p><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p>Linux通过<code>clone()</code>系统调用实现<code>fork()</code>。这个调用通过一系列的参数标志来指明父子进程需要共享的资源。<code>fork()</code>、 <code>vfork()</code>、 <code>__clone()</code>库函数都根据各自需要的参数去调用<code>clone()</code>，然后由<code>clone()</code>去调用<code>do_fork()</code>。</p><p><code>do_fork()</code> 完成了创建进程中的大部分工作。该函数调用<code>copy_process()</code>函数，然后让进程开始运行。</p><p><code>copy_process()</code>完成的工作：</p><ul><li><p>调用<code>dup_task_struct()</code>为新进程创建一个内核栈、<code>thread_info</code>结构和<code>task_struct</code>。这些值与当前进程值相同。</p></li><li><p>检查并确保新创建子进程后，当前用户所拥有的进程数没有超出给它分配的资源的限制。</p></li><li><p>子进程着手使自己与父进程区别开来。<code>task_struct</code>内的许多成员都清0或者设置为初始值。大多数据仍然未修改。</p></li><li><p>子进程的状态被设置为<code>TASK_UNINTERRUPTIBLE</code>，以保证不会投入运行。</p></li><li><p>调用<code>copy_flags()</code>以更新<code>task_struct</code>的<code>flags</code>成员。</p></li><li><p>调用<code>alloc_pid</code>为新进程分配一个有效的PID。</p></li><li><p>根据传给<code>clone</code>的参数标志，<code>copy_process()</code>拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。</p></li><li><p>最后返回一个指向子进程的指针。</p></li></ul><p>回到<code>do_fork()</code>函数，如果<code>copy_process()</code>函数返回成功，新创建的子进程被唤醒并让其投入运行。</p><h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h3><p>除了不拷贝父进程的页表项外，<code>vfork()</code>和<code>fork()</code>的功能相同。子进程作为父进程的一个单独的线程再它的地址空间里运行，父进程被阻塞，直到子进程退出或执行<code>exec()</code>。子进程不能向地址空间写入。由于<code>fork()</code>是写时复制并明确子进程先执行，所以<code>vfork()</code>的好处就只限于不拷贝父进程的页表项了。</p><h2 id="线程在Linux中的实现"><a href="#线程在Linux中的实现" class="headerlink" title="线程在Linux中的实现"></a>线程在Linux中的实现</h2><p>Linux从内核的角度讲，没有线程的概念。线程被视作一个与其他进程共享某些资源的的进程。每个线程都有一个属于自己的<code>task_struct</code>，所以在内核中，它看起来就像一个普通的进程，只是和其他task会共享某些资源，比如地址空间。</p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>线程的创建和普通进程的创建类似，只不过在调用<code>clone()</code>的时候参数需要传递一些参数标志来指明需要共享的资源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>新创建的task和他的父亲共享地址空间、文件系统资源、文件描述符和信号处理程序。换言之，新创建的task是父进程的一个线程。</p><p>对应的，<code>fork()</code>的实现是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(SIGCHLD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>vfork()</code>的实现是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VFORK | CLONE_VM | SIGCHLD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>内核经常需要在后台执行一些操作。这种任务可以通过内核线程(kernel thread)完成————独立运行在内核空间的标准进程。和普通进程的区别在于没有独立的地址空间。</p><h2 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h2><p>当一个进程结束时，内核会释放它占有的资源并给父进程发送信号。</p><p>进程的终止有可能是自身引起的，比如调用<code>exit()</code>系统调用，既可能显示调用，也可能隐式地从某个程序的主函数返回；也可能是被动地终结，比如进程接收到既不能处理又不能忽略的信号或异常。</p><p>大部分任务需要靠<code>do_exit()</code>来完成。至此进程不可运行，并处于<code>EIXT_ZOMBIE</code>退出状态，它所占有的所有内存就是内核栈、<code>thread_info</code>结构和<code>task_struct</code>结构。此时进程存在的唯一目的就是向它的父进程提供信息。父进程检索到信息或者通知内核那是无关的信息后，进程所持有的剩余内核被释放，归还给系统使用。</p><h3 id="删除进程描述符"><a href="#删除进程描述符" class="headerlink" title="删除进程描述符"></a>删除进程描述符</h3><p><code>wait()</code>这一族的函数都是通过唯一的一个系统调用<code>wait4()</code>来实现的。它的标准动作是挂起调用它的进程，直到其中一个子进程退出，此函数会返回该子进程的PID。</p><p>最终释放进程描述符时，<code>release_task()</code>会被调用：</p><ul><li>它调用<code>__exit_signal()</code>，该函数调用<code>__unhash_process()</code>,后者又调用<code>detach_pid()</code>从<code>pidhash</code>上删除该进程，同时从任务列表中删除该进程。</li><li><code>__exit_signal()</code>释放目前僵死进程所使用的所有剩余资源，并进行最终统计和记录。</li><li>如果这个进程是进程组最后一个进程，并且领头进程已经死亡，那么通知僵死的领头进程的父进程。</li><li>调用<code>put_task_struct()</code>释放掉进程内核栈和<code>thread_info</code>结构所占的页，并释放<code>task_struct</code>所占的slab高速缓存</li></ul><p>至此，进程描述符和所有的进程独享的资源就被全部释放掉了。</p><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父亲，否则这些子进程就变成了孤儿进程，在退出时永远处于僵死状态。解决方法就是给子进程在当前进程组内找一个线程作为父亲；如果不行，就让<code>init</code>做它们的父进程。在<code>do_exit()</code>会调用<code>exit_notify()</code>，该函数会调用<code>forget_original_parent()</code>，而后者会调用<code>find_new_reaper()</code>来执行寻找父进程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;发现读书不记笔记还是不行，过两天就忘得差不多了…最近在看《Linux内核设计与实现》，决定记些笔记。我可能有讲错的地方，一切以书上的讲解以及&lt;em&gt;Linux 2.6.X&lt;/em&gt;源码为准  （逃&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; cla</summary>
      
    
    
    
    <category term="Linux" scheme="http://cyyzero.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>扭曲的INT_MIN</title>
    <link href="http://cyyzero.github.io/2018/07/24/C/strange_INT_MIN/"/>
    <id>http://cyyzero.github.io/2018/07/24/C/strange_INT_MIN/</id>
    <published>2018-07-24T13:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<p>这个问题是在CSAPP上看到的，详情可以看<a href="http://101.96.10.63/csapp.cs.cmu.edu/public/waside/waside-tmin.pdf">这个</a>。</p><p>简单来说，问题就是：在用补码表示有符号整型的机器上，C语言中的整型的最大值和最小值的表示方法不同。接下来就以32位int为例子讲解这个问题。</p><p>int的最大值INT_MAX和int的最小值INT_MIN，是这么定义的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_MIN (-INT_MAX – 1)</span></span><br></pre></td></tr></table></figure><p>熟悉补码的童鞋应该都知道，32位的数据，能表示的最大的整数的位级表示是<code>0x7FFFFFFF</code>，即<code>2147483647</code>，最小的整数的位级表示是<code>0x80000000</code>，即<code>-2147483648</code>。那么是为什么不能直接<code>#define INT_MIN -2147483648</code>或者<code>#define INT_MIN 0x80000000</code>?</p><p>CSAPP上是这么来说的，我觉得总结的很好：</p><blockquote><p>不幸的是，补码表示的不对称性和C语言转换规则之间这种奇怪的交互，迫使我们使用奇怪的方式来写Tmin。虽然理解这个问题需要我们钻研C语言标准中一些隐晦的角落，但是它也能帮助我们理解整数数据类型和表示的一些细微之处。</p></blockquote><p>接下来以我自己的理解来阐述一下原因。</p><p>首先，C语言里有整数常量（<code>integer constant</code>），让整型数值直接在表达式中使用。比如说<code>int a = 10</code>这里出现的<code>10</code>，就是个整型常量。整型常量除了默认的十进制，可以在开头加<code>0</code>表示八进制，比如<code>010</code>就是表示的八进制数字<code>10</code>；还可以在开头加<code>0x</code>或者<code>0X</code>表示十六进制，比如说<code>0xFF</code>就表示十六进制数字<code>FF</code>。</p><p>而且<code>integer constant</code>可以添加后缀。可选的后缀有<code>u</code>或者<code>U</code>，<code>l</code>或者<code>L</code>，<code>ll</code>或者<code>LL</code>。带<code>u</code>和带<code>l</code>的后缀可以进行组合（而且不用分先后顺序）。于是这样就有了6种后缀方式：</p><ul><li>无后缀</li><li><code>u</code> 或者 <code>U</code></li><li><code>l</code> 或者 <code>L</code></li><li><code>ll</code> 或者 <code>LL</code></li><li>既有 <code>l/L</code>又有 <code>u/U</code></li><li>既有 <code>ll/LL</code> 又有 <code>u/U</code></li></ul><p><code>integer constant</code> 有自己的类型。而决定每个 <code>integer constant</code> 类型的规则有点复杂。上面提到的3种进制方式和6种后缀方式一共带来了18种组合，每个组合都会有一个由若干个整数类型组成的候选列表，会依次匹配，第一个能容纳这个数值的类型就是这个 <code>integer constant</code> 的类型。<a href="https://en.cppreference.com/w/c/language/integer_constant">完整的表格可以上cppreference上看</a>。</p><p>现在再来看<code>INT_MIN</code>。如果<code>#define INT_MIN -2147483648</code>，由于没有负整数常量，那么首先来判断<code>2147483648</code>的类型。它属于无后缀的十进制，从C99开始，候选列表为：</p><ul><li>int</li><li>long int</li><li>long long int</li></ul><p>而在int是32位补码表示的机器上，int最大为 <code>2147483647</code>， <code>2147483648</code>会被当成<code>long int</code>类型或者<code>long long int</code>类型，具体情况由 <a href="https://en.cppreference.com/w/c/language/arithmetic_types">data models</a> 来定。总而言之，就无法用 <code>-2147483648</code> 来表示最小的int值了。</p><p><code>#define INT_MIN 0x80000000</code>也是类似的情况。首先来判断 <code>0x80000000</code>的类型。它属于无后缀的十六进制，候选列表为：</p><ul><li>int</li><li>unsigned int</li><li>long int</li><li>unsigned long int</li><li>unsigned long long int</li></ul><p>在 int 是32位补码表示的机器上，int最大为 <code>2147483647</code>，即 <code>0x7FFFFFFF</code>，小于 <code>0x80000000</code>。所以也不能用 int 来表示 <code>0x80000000</code>,自然就无法用 <code>0x80000000</code> 来表示最小的int值了。</p><p>在网上看到的一句话总结，我觉得说的挺有道理：虽然 <code>-2147483648</code> 这个数值能够用int类型来表示，但在C语言中却没法写出对应这个数值的int类型常量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个问题是在CSAPP上看到的，详情可以看&lt;a href=&quot;http://101.96.10.63/csapp.cs.cmu.edu/public/waside/waside-tmin.pdf&quot;&gt;这个&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;简单来说，问题就是：在用补码表示有符号整型的机器</summary>
      
    
    
    
    <category term="C" scheme="http://cyyzero.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>x86体系结构中各种“地址”的概念</title>
    <link href="http://cyyzero.github.io/2018/05/25/x86/x86_address_defination/"/>
    <id>http://cyyzero.github.io/2018/05/25/x86/x86_address_defination/</id>
    <published>2018-05-25T13:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.883Z</updated>
    
    <content type="html"><![CDATA[<p>之前看CSAPP的时候，看到虚拟地址和物理地址的概念，对CPU的内存映射、地址空间这些有了粗略的印象。后来看了些关于X86的体系结构的内容，感觉相关的概念还是复杂了很多，所以特地整理一下。 (再次证明CSAPP还是当成入门书来看比较合适 ((逃</p><hr><p>在具体介绍这些概念之前，还是简单的总结一下X86的实模式和保护模式在内存管理上的区别。</p><p>X86的实模式(real mode)始于当年的8086芯片。现在的X86芯片刚启动时也默认先进入实模式。保护模式内存管理比较简单，寻址就是 段地址 + 段内偏移。8086提供了四个16位段寄存器用于保存段地址，分别是CS，DS，ES，SS，段内偏移量也是16位。但是地址线却有20位，也就是说物理地址是20位。所以英特尔公司就设计了一种很巧妙的方法，计算物理地址的时候段基址左移4位，再和偏移地址相加，这就得到了20位的物理地址。</p><p>80286处理器首次提出了保护模式的概念，但本文说的保护模式是指IA-32的保护模式。保护模式提供的内存管理机制大概分成了两个部分：分段和分页。分段能够隔离单独的代码模块、数据模块和栈模块，让彼此互不干扰(地址空间分离)。分页提供了虚拟内存的机制，让程序的各个部分能够根据执行环境的需要被映射到物理内存。值得一提的是，分段不能关闭，但是分页是可关闭的。</p><p>但是对于几乎所有操作系统来说，其实并没有用到保护模式提供的分段机制。一般都是将所有内存当成一个段来处理，这就是所谓的平坦模式(flat mode)。</p><h2 id="物理地址-physical-address"><a href="#物理地址-physical-address" class="headerlink" title="物理地址 physical address"></a>物理地址 physical address</h2><p>物理地址的概念很好理解，就是物理内存真正的地址。CPU最终对于内存的访问就得通过给总线物理地址的信号。</p><p>在X86的保护模式下，得到物理地址的方法就是16位的<code>段基址</code>左移4位加上16位的 <code>段内偏移地址</code>，最终得到的就是20位物理地址。</p><p>在IA-32的保护模式下，物理地址也是类似的概念，但是扩充到了32位，寻址4GBytes。从Pentium Pro处理器开始，IA-32架构地址扩充到了 2^36 Gbytes。在开启分页的情况下，虚拟地址通过MMU和页表的映射后引发缺页中断或者直接得到物理地址。</p><h2 id="有效地址-effective-address"><a href="#有效地址-effective-address" class="headerlink" title="有效地址 effective address"></a>有效地址 effective address</h2><p>有效地址就是段内偏移地址，不论是实模式还是保护模式都是如此。</p><h2 id="逻辑地址-logical-address"><a href="#逻辑地址-logical-address" class="headerlink" title="逻辑地址 logical address"></a>逻辑地址 logical address</h2><p>在实模式下，逻辑地址包括16位段地址和16位偏移地址。</p><p>在保护模式下，逻辑地址包括16位的段选择子和32位的偏移地址。</p><p>至于段选择子是什么，我在英特尔手册上摘抄了一段：</p><blockquote><p>A segment selector is a 16-bit identifier for a segment (see Figure 3-6). It does not point directly to the segment,but instead points to the segment descriptor that defines the segment.</p></blockquote><p>简单来说，段选择子就是一个16位的索引，它不直接指向段，而是指向段描述符。每个段都需要一个段描述符，为了放这些段描述符，在内存中开辟了一些空间，构成一个段描述符表。</p><p>也不细讲了，再从手册上摘抄些资料看看凑合吧：</p><blockquote><p>A logical address consists of a segment selector and an offset. The segment selector is a unique identifier for a segment. Among other things it provides an offset into a descriptor table (such as the global descriptor table, GDT) to a data structure called a segment descriptor. Each segment has a segment descriptor, which specifies the size of the segment, the access rights and privilege level for the segment, the segment type, and the location of the first byte of the segment in the linear address space (called the base address of the segment). The offset part of the logical address is added to the base address for the segment to locate a byte within the segment. The base address plus the offset thus forms a linear address in the processor’s linear address space.</p></blockquote><h2 id="线性地址-linear-address"><a href="#线性地址-linear-address" class="headerlink" title="线性地址 linear address"></a>线性地址 linear address</h2><p>在保护模式下，处理器能把每个逻辑地址转换成一个线性地址。线性地址是32位。具体转换方式如下：</p><ul><li>通过段选择子中的偏移定位到 GDT 或者 LDT 中的段描述符，读进处理器。</li><li>检查段描述符中的各种标志位是否访问本段，然后确认32位的偏移是在段的限制内。</li><li>从段描述符中得到段的基址，然后和逻辑地址的32位的偏移相加，就得到了线性地址。</li></ul><p>如果没有开启分页，那这个线性地址就已经是物理地址。如果开启了分页，那得到的线性地址就是虚拟地址。</p><h2 id="虚拟地址-physical-address"><a href="#虚拟地址-physical-address" class="headerlink" title="虚拟地址 physical address"></a>虚拟地址 physical address</h2><p>从上面对线性地址的描述可以看到，如果开启了分页，那线性地址就是虚拟地址，CPU通过页表的映射可以得到物理地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前看CSAPP的时候，看到虚拟地址和物理地址的概念，对CPU的内存映射、地址空间这些有了粗略的印象。后来看了些关于X86的体系结构的内容，感觉相关的概念还是复杂了很多，所以特地整理一下。 (再次证明CSAPP还是当成入门书来看比较合适 ((逃&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在具</summary>
      
    
    
    
    <category term="x86" scheme="http://cyyzero.github.io/categories/x86/"/>
    
    
  </entry>
  
  <entry>
    <title>SFINAE概念的介绍</title>
    <link href="http://cyyzero.github.io/2018/05/20/C++/C++_sfinae/"/>
    <id>http://cyyzero.github.io/2018/05/20/C++/C++_sfinae/</id>
    <published>2018-05-20T13:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>前段时间看 <code>std::unique_ptr</code> 的实现，发现里面用到了好多用到<code>std::enable_if</code> 的地方，查了下才知道这涉及到C++ 里 <em>SFINAE</em> 的规则，还有定义成员类型的时候也在注释里提到了利用 <em>SFINAE</em> ，所以特地查阅资料记录下。</p><h1 id="SFINAE-定义"><a href="#SFINAE-定义" class="headerlink" title="SFINAE 定义"></a>SFINAE 定义</h1><p><em>SFINAE</em> 表示 <em>Substitution Failure Is Not An Error</em> (替换失败不是错误)。这里的 <em>Substitution</em>　（替换）是个什么概念呢？</p><p>先来了解一下模板实参替换的概念：</p><blockquote><p>已指定、推导出或从默认模板实参获得所有模板实参时，函数参数列表中每次模板形参的使用都会被替换成对应的模板实参。</p></blockquote><blockquote><p>替换发生于:<br>-所有用于函数类型中的类型（包含返回类型和所有参数的类型）<br>-所有用于模板形参声明中的所有类型<br>-所有用于函数类型中的表达式<br>-所有用于模板形参声明中的表达式 </p></blockquote><p>（ps：后两种替换都是从C++11起）</p><p>听起来很拗口，总之就是模板形参会被替换成实参。</p><p>举个简单的例子就能懂了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">         <span class="keyword">typename</span> U = <span class="keyword">typename</span> T::type&gt;    <span class="comment">// 第二种替换</span></span><br><span class="line">T&amp;                                         <span class="comment">// 第一种替换</span></span><br><span class="line"><span class="built_in">fun</span>(T)                                     <span class="comment">// 第一种替换</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不替换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>粗略的了解了替换之后，就能明白 <em>SFINAE</em> 大概什么意思了：模板形参替换推导类型失败时，从重载集抛弃特化，而非导致编译失败。其实还是挺好理解的，举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                <span class="comment">// 重载版本1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">typename</span> T::type)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                <span class="comment">// 重载版本2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>&lt;test&gt;(<span class="number">0</span>);                   <span class="comment">// 调用1</span></span><br><span class="line">    <span class="built_in">fun</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>);                    <span class="comment">// 调用2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于调用1，它模板参数为test，替换就已经开始了。</p><ul><li>重载版本1，替换后它变成了类似 <code>void fun(int)</code>；</li><li>重载版本2，替换后它变成了类似 <code>void fun(test)</code>。</li></ul><p>两者都是在重载集中的。根据函数重载匹配规则，匹配到前者。可以看到，这里其实并没有用到 <em>SFINAE</em>。</p><p>对于调用2，它模板参数为int</p><ul><li><p>重载版本1， 替换后它变成了类似 <code>void fun(int::type)</code>，很显然，这个替换是failure（失败）。所以它从重载集被中删除。</p></li><li><p>重载版本2，替换后它变成了类似 <code>void fun(int)</code>。</p></li></ul><p>所以调用版本2。</p><p>说道底，<em>Substitution Failure</em> 的含义就是：替换的实参写入时，带来了无效(invalid)的类型或表达式(参考上面提到的替换的四种情况)为 ill-formed 。（就像上面例子里出现的类似 <code>int::type</code>）。我查了下C++标准草案，发现里面并没有提到 <em>SFINAE</em> 的概念，只提到了替换后的类型或表达式为无效的话，模板类型推导就失败了。而且标准还特地强调了，当且仅当替换后的无效(invalid)类型和表达式是在函数类型和它的模板类型参数的立即上下文(immediate context)时，才导致类型推断失败。如果替换后的类型或者表达式会引发副作用(实例化某模板特化、生成某隐式定义的成员函数等)的话，就认为它并不是在 immediate context 中，会引发程序为 ill-formed。所以说，我猜正是因为只是模板类型推断失败，就不会引发错误（error）。</p><p>上面这段说的很拗口，我也没办法。<a href="http://en.cppreference.com/w/cpp/language/sfinae">cppreference</a>和C++标准草案n上上说的也很拗口。而且cppreference上的描述还有很多奇怪的地方，一会而 Substitution Failure， 一会又冒出个 <em>SFINAE error</em> ，后来看了草案才知道 <em>SFINAE error</em> 就是让类型推断失败的情况。我把这段摘录下来，可以结合<a href="http://en.cppreference.com/w/cpp/language/sfinae">cppreference</a>上的描述一起看下：</p><blockquote><p>If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression is one that would be ill-formed, with a diagnostic required, if written using the substituted arguments. [ Note: If no diagnostic is required, the program is still ill-formed. Access checking is done as part of the substitution process. — end note ] Only invalid types and expressions in the immediate context of the function type and its template parameter types can result in a deduction failure. [ Note: The substitution into types and expressions can result in effects such as the instantiation of class template specializations and&#x2F;or function template specializations, the generation of implicitly-defined functions, etc. Such effects are not in the “immediate context” and can result in the program being ill-formed. — end note ]</p></blockquote><p>草案上还明确规定了什么情况下会让模板参数推断失败。<a href="http://en.cppreference.com/w/cpp/language/sfinae">cppreference</a>上也介绍了，只不过正如上面所提到的，说法改了下，变成了 <em>SFINAE error</em> 出现的情况。相当于是对于标准的提炼和总结。</p><p>最后再提一下，如果 SFINAE 完美工作，但最终还是匹配不到某个函数，那显然也会造成编译失败。</p><h1 id="SFINAE-应用例子"><a href="#SFINAE-应用例子" class="headerlink" title="SFINAE 应用例子"></a>SFINAE 应用例子</h1><h2 id="std-enable-if"><a href="#std-enable-if" class="headerlink" title="std::enable_if"></a>std::enable_if</h2><p>这差不多算是很经典的利用 SFINAE 的例子了。直接上源代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Primary template.</span></span><br><span class="line"><span class="comment">/// Define a member typedef @c type only if a boolean constant is true.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span>, <span class="keyword">typename</span> _Tp = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> enable_if </span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial specialization for true.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">enable_if</span>&lt;<span class="literal">true</span>, _Tp&gt;</span><br><span class="line">&#123; <span class="keyword">typedef</span> _Tp type; &#125;;</span><br></pre></td></tr></table></figure><p>根据 SFINAE 规则，<code>std::enable_if&lt;true, someType&gt;</code>的时候，它提供了成员类型 <code>type</code>； <code>std::enable_if&lt;false, someType&gt;</code>的时候，它无成员类型 <code>type</code>。而且由于它有了个默认模板参数 <code>_TP = void</code>，所以 <code>std::enable_if&lt;true&gt;</code> 提供了成员类型 <code>type</code> 为 void，当然，<code>std::enable_if&lt;false&gt;</code> 仍然无类型成员 <code>type</code>。 </p><p><code>std::enable_if</code>对不同类型特性提供分离的函数重载与特化的便利方法。它可用作额外的函数参数、返回类型、或类模板或函数模板形参。来看个使用它的例子。<code>std::unique_ptr</code>所使用的默认的删除器 <code>std::default_delete</code>，它有一个重载版本的构造函数标准规定是这样的：从另一 <code>std::default_delete</code> 构造 <code>std::default_delete</code> 对象。此构造函数仅若 U* 可隐式转换为 T* 才参与重载决议。大概函数原型就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">default_delete&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">default_delete</span><span class="params">( <span class="type">const</span> default_delete&lt;U&gt;&amp; d )</span> <span class="keyword">noexcept</span></span>;     <span class="comment">//仅若 U* 可隐式转换为 T* 才参与重载决议。T是 default_delete 能删除的类型</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 <code>std::enable_if</code>，再配合 <em>type_traits</em> 头文件提供的用于判断两种类型是否能转化的函数 <code>std::is_convertible</code>，完成这样的需求就很容易了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">default_delete &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> = </span><br><span class="line">        <span class="keyword">typename</span> std::enable_if&lt;std::is_convertible&lt;U*, T*&gt;::value&gt;::type&gt;</span><br><span class="line">    <span class="built_in">default_delete</span>(<span class="type">const</span> default_delete&lt;Up&gt;&amp;) <span class="keyword">noexcept</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>U*</code> 能够转化成 <code>T*</code> 的时候，<code>std::is_convertible&lt;U*, T*&gt;::value</code> 为 <code>true</code> ，<code>std::enable_if&lt;std::is_convertible&lt;U*, T*&gt;::value&gt;::type</code> 为void，模板参数能正常推断；反之，当 <code>U*</code> 不能够转化成 <code>T*</code> 的时候，<code>std::is_convertible&lt;U*, T*&gt;::value</code> 为 <code>false</code> ，<code>std::enable_if&lt;std::is_convertible&lt;U*, T*&gt;::value&gt;::type</code> 为 ill-formed 。模板参数推断失败，显然无法实例化这个函数，也无法加入重载集。达到了 <em>仅若 U</em> 可隐式转换为 T* 才参与重载决议* 的要求。</p><h2 id="确定-std-unique-ptr-成员类型-pointer"><a href="#确定-std-unique-ptr-成员类型-pointer" class="headerlink" title="确定 std::unique_ptr 成员类型 pointer"></a>确定 std::unique_ptr 成员类型 pointer</h2><p>这个也是阅读<code>std::unique_ptr</code>源码学习到的。感觉这个用法也很巧妙。首先需求是这样的，<code>std::unique_ptr</code> 有一个成员类型 pointer，若该类型存在则为 <code>std::remove_reference&lt;Deleter&gt;::type::pointer</code> （其中 Deleter 是unique_ptr 的第二个模板参数，用于表示删除器的类型），否则为 T* 。必须满足可空指针 (NullablePointer) 。</p><p>是这么实现的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter = default_delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Use SINFAE to determine whether std::remove_reference&lt;Deleter&gt;::type::pointer exits</span></span><br><span class="line">    <span class="keyword">class</span> _Pointer</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">using</span> _Del = <span class="keyword">typename</span> std::remove_reference&lt;Deleter&gt;::type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">        <span class="type">static</span> <span class="keyword">typename</span> U::pointer __test(<span class="keyword">typename</span> U::pointer*);       <span class="comment">// 重载版本1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">        <span class="type">static</span> T* __test(...);                                         <span class="comment">// 重载版本2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> type = <span class="keyword">decltype</span>(__test&lt;_Del&gt;(<span class="number">0</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _pointer::type pointer;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果<code>std::remove_reference&lt;Deleter&gt;::type</code>有类型成员 <code>pointer</code> ，<code>__test&lt;_Del&gt;(0)</code>优先调用重载版本1，从而 <code>decltype(__test&lt;_Del&gt;(0))</code> 为重载版本1的返回值，即<code>std::remove_reference&lt;Deleter&gt;::type::pointer</code>；否则，只能调用重载版本2，<code>decltype(__test&lt;_Del&gt;(0))</code> 为重载版本2的返回值，即<code>T*</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;前段时间看 &lt;code&gt;std::unique_ptr&lt;/code&gt; 的实现，发现里面用到了好多用到&lt;code&gt;std::enable_if</summary>
      
    
    
    
    <category term="C++" scheme="http://cyyzero.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>do{...}while(0)在宏定义中的应用</title>
    <link href="http://cyyzero.github.io/2018/04/22/C/do_while(0)/"/>
    <id>http://cyyzero.github.io/2018/04/22/C/do_while(0)/</id>
    <published>2018-04-22T13:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<p>今天在看linux内核中链表操作的接口的时候，碰到这样一个宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// INIT_LIST_HEAD宏用于运行时初始化链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_LIST_HEAD(ptr) do &#123; \</span></span><br><span class="line"><span class="meta">    (ptr)-&gt;next = (ptr); (ptr)-&gt;prev = (ptr); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><p>不太明白这里的<code>do&#123;...&#125;while(0)</code>是个什么操作，看起来似乎没有什么用——因为这里<code>while(0)</code>显然并没有起到循环的效果。后来查了下资料(<a href="https://kernelnewbies.org/FAQ/DoWhile0">网址在这</a>)，才知道在Linux内核和其它一些著名的C库中有许多使用do{…}while(0)的宏定义，也大概明白了这么写的作用。</p><ul><li><p>第一个理由：空的 <em>statement</em> 会让编译器发出警告，所以会看到有些宏定义是这样的： <code>#define FOO do&#123; &#125;while(0)</code> 。（暂时没看到这样的宏 &#x3D; &#x3D;。  先记录一下</p></li><li><p>第二个理由：它提供了一个 block 用于声明局部变量。可能你会想到不使用 <code>do&#123;...&#125;while(0)</code> 而简单地使用一对大括号 <code>&#123;...&#125;</code> 。这样有缺陷，具体看下一条。</p></li><li><p>第三个理由：让你能够声明复杂的宏定义。想象一下一个宏定义如下：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FOO(x) \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;arg is %d\n&quot;</span>, x); \</span></span><br><span class="line"><span class="meta">        do_something_useful(x);</span></span><br></pre></td></tr></table></figure><p>  现在这么使用它：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (blah == <span class="number">2</span>)</span><br><span class="line">    FOO(blah);</span><br></pre></td></tr></table></figure><p>  宏本质上就是文本替换，所以它实际上：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (blah == <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg is %d\n&quot;</span>, blah);</span><br><span class="line">do_something_useful(blah);              <span class="comment">// 不论 blah为何止，都会执行这条</span></span><br></pre></td></tr></table></figure><p>  所以显然，这可能带来用于预期之外的效果。而如果用了 <code>do&#123;...&#125;while(0)</code> ，就会是这样的：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (blah == <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arg is %d\n&quot;</span>, blah);</span><br><span class="line">        do_something_useful(blah);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"><span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>  可能有人会想，既然需要一个 block ，那么加个大括号不就好了？好的，假如说有这样一个宏定义：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换两个值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> exch(x, y) &#123; int tmp; tmp = x; x = y; y = tmp; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &gt; y)</span><br><span class="line">    exch(x, y);            <span class="comment">// 看起来似乎没问题</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    do_something();</span><br></pre></td></tr></table></figure><p>  很显然，这个相当于这样：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br><span class="line">;                       <span class="comment">// 注意这里！！</span></span><br><span class="line"><span class="keyword">else</span>                    <span class="comment">// 语法错误</span></span><br><span class="line">    do_something();</span><br></pre></td></tr></table></figure><p>  问题就出现在那个 <code>;</code> 。当然，你可以选择当初写下 <code>each(x, y)</code> 的时候在这行末尾不加分号，但是(我觉得)这实在显得太奇怪了。</p><p>  用了 <code>do&#123;...&#125; while (0)</code> 就没有这个问题：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; y)</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        tmp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = tmp;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);           <span class="comment">// Ok</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    do_something();</span><br></pre></td></tr></table></figure></li></ul><p>总结：Linux和其它代码库里的宏都用 <code>do&#123;...&#125;while (0)</code> 来包围执行逻辑，因为它能确保宏的行为总是相同的，而不管在调用代码中使用了多少分号和大括号。</p><p>（一点吐槽：感觉就是给C语言的宏擦屁股的？还有就是 <code>if/else</code> 即使只有一条语句也加大括号真是个好习惯 &#x3D; &#x3D;。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天在看linux内核中链表操作的接口的时候，碰到这样一个宏定义：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</summary>
      
    
    
    
    <category term="C" scheme="http://cyyzero.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective Modern C++读书笔记(四)</title>
    <link href="http://cyyzero.github.io/2018/04/20/C++/effective_modern_cpp_4/"/>
    <id>http://cyyzero.github.io/2018/04/20/C++/effective_modern_cpp_4/</id>
    <published>2018-04-20T13:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h1><p>首先来明确一下三个概念：</p><ul><li><p>lambda 表达式只是一个表达式。它是源码的一部分。</p></li><li><p><em>closure</em> 是由lambda创造的运行期对象。根据捕获的模式，<em>closure</em> 持有被捕获对象的副本或者引用。</p></li><li><p><em>closure class</em> 是给 <em>closure</em> 实例化的。每个 <em>lambda</em> 会让编译器生成一个独一无二的 <em>closure class</em> 。<em>lambda</em> 内的声明将变成它 <em>closure class</em> 内的成员函数的可执行指令。</p></li></ul><hr><h2 id="Item-31"><a href="#Item-31" class="headerlink" title="Item 31"></a>Item 31</h2><ul><li><p>在C++11里有两种默认的捕获模式： <em>by-reference</em> 和 <em>by-value</em> 。默认的 <em>by-reference</em> 捕获可以导致空悬引用。比如说这个 <em>closure</em> (或者它的副本)比捕获的引用的对象的声明周期长。 (这也应该是处理引用本就应该小心的地方)。应该不使用默认捕获，捕获的时候添上引用的对象。这样可以让程序员注意到引用的对象，从而对它的生命周期有了考量。或者直接就通过传值来捕获。但如果传值的对象是 <em>raw pointer</em> ，那又得考虑是否会出现空悬指针的问题。</p></li><li><p>有种情况 <em>by-value</em> 捕获会造成意想不到的悬垂指针。看个例子：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt;&gt; filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> divisor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [=](<span class="type">int</span> value)&#123; <span class="keyword">return</span> value % divisor&#125; == <span class="number">0</span>; &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里看似 <em>by-value</em> 捕获了divisor，但是却并非如此。首先，divisor是类内 <em>non-static 数据成员</em> ，是不能被捕获的。但是这段代码却可以编译过。原因就在与 <em>this</em> 指针。类的 <em>non-static</em> 函数体中隐含了一个 <em>this</em> 指针，它是个纯右值(prvalue)表达式，表示调用这个函数的对象的地址。所以其实捕获的是 <em>this</em> 指针，而lambda表达式中的 <code>divisor</code> 其实也是 <code>this-&gt;divisor</code> 。</p><p>  所以既然是 <em>by-value</em> 捕获的 <em>this</em> 指针，那么就有可能出现空悬指针。为了避免这种情况，还是老实地在 <code>addFilters</code> 函数体内用一个 local 变量作为 <em>divisor</em> 的副本，然后 <em>by-value</em> 捕获这个副本。</p></li><li><p>还有就是要注意，静态存储周期的对象都是可以直接在lambda 表达式中使用的，而且<em>不能捕获</em> 。所以在lambda表达式中用默认 <em>by-value</em> 捕获，就会让人产生错觉。但实际上什么都没捕获。</p></li></ul><hr><h2 id="Item-32"><a href="#Item-32" class="headerlink" title="Item 32"></a>Item 32</h2><ul><li><p>C++14 提供了 <em>init capture</em> 这种新的捕获方式。具体来说就是在捕获列表中可以通过 <code>=</code> 的方式，等号左边是从 <em>lambda</em> 表达式生成的闭包类的数据成员，右边是表达式，用于初始化左边。可以明显看出，<code>=</code>左边和右边的作用域也不同。所以，通过这种语法，让“移动”捕获成为了可能，而非 C++11 那样只能传值和传引用捕获。</p></li><li><p>不过在C++11中也是可以模拟出“移动”捕获的。</p><ul><li><p>lambda 表达式可以看成定义一个函数类并构造它的对象。所以没有什么是直接定义一个类不能解决的。类中自然可以通过移动的方式初始化数据成员。</p></li><li><p>通过 <code>std::bind</code> 来模拟。可以看个例子：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line"><span class="comment">// In C++14</span></span><br><span class="line"><span class="keyword">auto</span> func = [data = std::<span class="built_in">move</span>(data)]()&#123; <span class="comment">/*uses of data*/</span> &#125;;</span><br><span class="line"><span class="comment">// 以下是等价的版本</span></span><br><span class="line"><span class="comment">// In C++11</span></span><br><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>(</span><br><span class="line">    [](<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; data)</span><br><span class="line">    &#123; <span class="comment">/*uses of data*/</span> &#125;,</span><br><span class="line">    std::<span class="built_in">move</span>(data)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>  <code>std::bind</code>构造的对象持有所有参数的副本。当参数是左值，就拷贝构造；当参数是右值，就移动构造。所以参数<code>data</code>通过移动构造传进了 bind 对象内(姑且称之为d)，然后每次调用 <code>func</code> 的 <code>operator()</code> 的时候，都会调用那个 <em>lambda</em> 表达式的 <code>operator()</code> 。而参数就是 bind 对象内的data对象的副本。由于 <em>lambda</em> 没有加 <code>multable</code>，闭包类内的 <code>operator()</code>是 <code>const</code> 限定的的。而 bind 对象的data的副本却不是const的。为了防止它被修改，所以参数加了<code>const</code>。但其实这样也可以：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func =</span><br><span class="line">    std::<span class="built_in">bind</span>(</span><br><span class="line">        [](std::vector&lt;<span class="type">double</span>&gt;&amp; data) <span class="keyword">mutable</span></span><br><span class="line">        &#123; <span class="comment">/* uses of data */</span> &#125;,</span><br><span class="line">        std::<span class="built_in">move</span>(data)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="Item-33"><a href="#Item-33" class="headerlink" title="Item 33"></a>Item 33</h2><p>C++14 引入了 <em>generic lambdas</em> 的特性。具体来说就是 <em>lambda</em> 表达式的参数列表的类型是 <code>auto</code> 。这个特性的实现也很直观：生成的闭包类的 <code>operator()</code> 函数是个模板。所以，随着来的 <em>universal reference</em> 和完美转发都可以实现了。完美转发的关键还是在对引用折叠和 <code>std::forward</code> 函数实现的理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; param)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">func</span>(std::forward&lt;<span class="keyword">decltype</span>(param)&gt;(param));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp;... params)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">func</span>(std::forward&lt;<span class="keyword">decltype</span>(param)&gt;(params)...);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="Item-34"><a href="#Item-34" class="headerlink" title="Item 34"></a>Item 34</h2><p>用 <em>lambda</em> 表达式与 <code>std::bind</code> 相比有些优势，如下：</p><ul><li><p><em>lambda</em> 表达式比较清晰。(这里书中给的代码有误，最后再详细讲)</p></li><li><p><em>lambda</em> 表达式内可以调用重载的函数，但是<code>std::bind</code>第一个参数是重载函数的话得明确调用的版本(通过<code>static_cast</code>)。而且由于使用的指针，还会减少它被内联优化的可能性。</p></li><li><p><code>std::bind</code> 默认是将参数拷贝的。想要保存参数的引用，必须要用<code>std::ref</code>。比如：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> compressRateB = std::<span class="built_in">bind</span>(compress, std::<span class="built_in">ref</span>(w), _1);       <span class="comment">// compressRateB acts as if it holds a reference to w, rather than a copy</span></span><br></pre></td></tr></table></figure><p>  这点就很不如 <em>lambda</em> 表达式直观。</p></li></ul><p>在 C++14 中，<em>lambda</em> 表达式已经十分优秀，再也没有使用 <code>std::bind</code> 的理由了。但是在 C++11 中，<code>std::bind</code> 在以下情况下还是很有用的：</p><ul><li><em>Move capture</em> 。C++11 <em>lambda</em> 表达式没有提供通过移动捕获的方式，但是能通过 <code>std::bind</code> 模拟出来。但 C++14 开始， <em>lambda</em> 表达式通过 <em>init capture</em> 已经能够实现这个。</li><li><em>Polymorphic function objects</em> 。<code>std::bind</code>绑定一个模板函数的时候，它能完美转发任何参数。但是 C++14 开始，<em>lambda</em> 表达式可以通过 <code>auto</code> 实现泛型。</li></ul><p>ps：这章里的代码竟然还有错误的地方，琢磨半天&#x3D; &#x3D;。 最后在 <a href="https://stackoverflow.com/questions/42207520/why-nested-bind-can-defer-evaluation-of-the-expression"><em>StackOverflow</em> 上查到了正确的写法</a>。</p><p>先还原一下问题的引入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;          <span class="comment">// needed for use of &quot;_1&quot;</span></span><br><span class="line"><span class="keyword">auto</span> setSoundL = [](Sound s) &#123;</span><br><span class="line">    <span class="built_in">setAlarm</span>(steady_clock::<span class="built_in">now</span>()) + <span class="number">1</span>h,</span><br><span class="line">             s,</span><br><span class="line">             <span class="number">30</span>s);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>(setAlarm,</span><br><span class="line">                           steady_clock::<span class="built_in">now</span>() + <span class="number">1</span>h,</span><br><span class="line">                           _1,</span><br><span class="line">                           <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><p>可以看到 <code>setSoundL</code> 和 <code>setSoundB</code> 看似完成相同的功能，但是实际上却并非如此。因为 在调用 <code>setSoundL</code> 时会调用<code>setAlarm</code>函数。显然，此时才会<code>now</code> 函数。而对于 <code>setSoundB</code> 来说，它在生成的时候就已经被调用了 <code>now()</code> 函数。然后每次调用它的时候，并不会再对 <code>now()</code> 调用。所以可以看到，在语义上双方已经不同了。解决方法也很简单，将后者对 <code>now</code> 函数的调用推迟到它自身被调用的时候。</p><p>书上给出的修改是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了一系列的 using</span></span><br><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>(setAlarm,</span><br><span class="line">                           std::<span class="built_in">bind</span>(std::plus&lt;&gt;(), steady_clock::<span class="built_in">now</span>(), <span class="number">1</span>h),       <span class="comment">// 在 C++14 中，标准操作模板的模板参数声明通常可以被省略。注意， C++ 11 并不支持这么写。</span></span><br><span class="line">                           <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><p>但这显然也不能达成目标，<code>now</code> 函数还是会在 <code>setSoundB</code> 生成的时候就调用。不难想到，<code>std::bind</code>第一个参数，即可调用对象，是不会提前被调用的。所以应该这么改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了一系列的 using</span></span><br><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>(setAlarm,</span><br><span class="line">                           std::<span class="built_in">bind</span>(std::plus&lt;&gt;(), std::<span class="built_in">bind</span>(steady_clock::<span class="built_in">now</span>()), <span class="number">1</span>h),</span><br><span class="line">                           <span class="number">30</span>s);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lambda-表达式&quot;&gt;&lt;a href=&quot;#lambda-表达式&quot; class=&quot;headerlink&quot; title=&quot;lambda 表达式&quot;&gt;&lt;/a&gt;lambda 表达式&lt;/h1&gt;&lt;p&gt;首先来明确一下三个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;lambda 表达</summary>
      
    
    
    
    <category term="C++" scheme="http://cyyzero.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective Modern C++读书笔记(三)</title>
    <link href="http://cyyzero.github.io/2018/03/01/C++/effective_modern_cpp_3/"/>
    <id>http://cyyzero.github.io/2018/03/01/C++/effective_modern_cpp_3/</id>
    <published>2018-03-01T13:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="右值引用，移动语义和完美转发"><a href="#右值引用，移动语义和完美转发" class="headerlink" title="右值引用，移动语义和完美转发"></a>右值引用，移动语义和完美转发</h1><ul><li><p>*移动语义(Move semantics)*往往可以用来替代copy操作，减小开销。而且还要某些对象(比如<code>std::unique_ptr</code>, <code>std::futrue</code>, <code>std::thread</code>)只允许move，禁止copy。可是在某些情况下，它的开销并不一定比copy小。</p></li><li><p>*完美转发(Perfect forwarding)*可以让模板接受参数，然后转发给其它函数，保持参数的类型不变。在某些时候，它也并不是完美的。</p></li></ul><p>而*右值引用(Rvalue reference)*就是使上述两个看似不相干的特性连接起来的胶水。它是支撑着移动语义和完美转的潜在语言机制。</p><hr><h2 id="Item-23"><a href="#Item-23" class="headerlink" title="Item 23"></a>Item 23</h2><p><code>std::move</code>不移动任何东西。<code>std::forward</code>不转发任何东西。在运行期间，不产生可执行的代码，不产升任何字节。它们只是是执行类型转换的函数模板(function templates)。</p><h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><ul><li><p><code>std::mvoe</code>无条件地将它的参数转化成右值。可以看下一个接近标准库的简单实现</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  并且在c–14中，,<code>std::move</code>还能实现得更精炼：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由于<code>std::move</code>只做了将参数转化成右值的工作，甚至有人建议将它的名字改成<code>ralue_cast</code>。当然，右值是可移动的，所以将<code>std::move</code>用于一个对象，可以告诉编译器这个对象是可被移动的。可能这就是命名为<code>std::move</code>的原因。</p></li><li><p><code>std::mvoe</code>并不一定真正能引发移动操作。举个例子：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="type">const</span> std::string text)</span></span></span><br><span class="line"><span class="function">    : value(std::move(text)) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  你可能预想<code>value(std::move(text))</code>讲引发<code>std::string</code>的移动构造函数。但是，这里却发生了copy。原因在于<code>text</code>是个const对象。<code>std::move</code>作用于const对象时，返回值是个const限定的右值。而std::string构造函数的签名却大概是如下这样的：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;                          <span class="comment">// typedef for std::basic_string&lt;char&gt;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::<span class="built_in">string</span>(<span class="type">const</span> string&amp; rhs);     <span class="comment">// copy ctor</span></span><br><span class="line">    std::<span class="built_in">string</span>(string&amp;&amp; rhs);          <span class="comment">// move ctor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...Other code</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  <code>const std::string</code>的右值不能传给<code>rvalue reference to a non-const std::string</code>(即不会调用移动构造函数)，却可以传给<code>lvalue-reference-to-const</code>(即会调用拷贝构造函数)。因为移动一个对象会改变它的某些值，所以c–不允许<code>const</code>对象传给可能会改变它们值的函数。</p><p>  所以，有两个教训：</p><ul><li>如果你想要移动某个对象，不要将它声明为const。否则实际将会引发copy操作。</li><li><code>std::move</code>不移动任何东西。它只是保证它转化的对象将会有资格被移动，即被转化成右值。</li></ul></li></ul><h3 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h3><ul><li><p><code>std::forward</code>的转化只在某些特定情况下工作。它最常用的场景是在<code>universal reference</code>作为参数的函数模板(function template)中，用于将参数传给另一个函数。比如说：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> Widget&amp; lvalArg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; rvalArg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndProcess</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(<span class="string">&quot;Calling &#x27;process&#x27;&quot;</span>, now);</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget W;</span><br><span class="line"><span class="built_in">logAndProcess</span>(w);               <span class="comment">// (1) call with lvalue</span></span><br><span class="line"><span class="built_in">logAndProcess</span>(std::<span class="built_in">move</span>(w));    <span class="comment">// (2) call with rvalue</span></span><br></pre></td></tr></table></figure><p>  试想一下，如果没有<code>std::forward</code>会如何。param会被推断成左值或者右值的引用(详情见第一章)。但是，无论如何，param本身都是一个左值，所以调用process的参数匹配的时候，都会调用参数是lvalue reference的重载版本。<em>我们需要一个机制，只有当传给<code>param</code>的对象是右值的时候，将<code>param</code>从rvalue reference(是左值)转换右值。</em>事实上，这就是上述提到的希望<code>std::forward</code>工作的特定情况。</p><p>  BTW，你可能会奇怪<code>std::forward</code>如何区分传给它的对象被初始化之前的类型。秘密就藏在模板参数T里面。后面Item 28会详细讲。</p><p>  事实上，某些时候，我们可以用<code>std::forward</code>来代替<code>std::move</code>：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs)</span><br><span class="line">    : <span class="built_in">s</span>(std::<span class="built_in">move</span>(rhs.s)) &#123; &#125;</span><br><span class="line"><span class="comment">// 等价于下面这么写</span></span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs)</span><br><span class="line">    : <span class="built_in">s</span>(std::forward&lt;std::string&gt;(rhs)) &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  注意到<code>std::forward</code>的模板参数是<code>std::string</code>,这可以让它的返回值是右值。但是这么写很不方便。所以还是用<code>std::move</code>来得好。</p></li></ul><hr><h2 id="Item-24"><a href="#Item-24" class="headerlink" title="Item 24"></a>Item 24</h2><ul><li><p><code>univsersialcv reference</code>可以绑定到任意类型，const或volatile限定的rvalue或lvalue。通常有两个运用的地方，并且都伴随着类型推断：</p><ul><li><p>模板中：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;          <span class="comment">// param is a universal reference</span></span><br></pre></td></tr></table></figure></li><li><p>auto 表达式</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = val1;         <span class="comment">// var2 is a universal reference</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果加了const，就会绑定到rvalue reference</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;           <span class="comment">// param is a rvalue reference</span></span><br></pre></td></tr></table></figure></li><li><p>不要在模板里看到<code>T&amp;&amp;</code>就以为是<code>universal reference</code>。比如在vector中：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);                 <span class="comment">// x is a reference to rvalue</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span>;     <span class="comment">// args are universial references</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C++14的lambda表达式可以声明 <code>auto&amp;&amp;</code> 参数：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> timeFuncInvocation = </span><br><span class="line">    [](<span class="keyword">auto</span>&amp;&amp; func, <span class="keyword">auto</span>&amp;&amp;... params)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//start timer;</span></span><br><span class="line">        std::forward&lt;<span class="keyword">decltype</span>(func)&gt;(func)(</span><br><span class="line">            std::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params)...</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">//stop timer and record elapased time</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>universal reference</code>只是一层抽象，背后的原理是 <code>reference collapsing</code>(引用折叠)。</p></li></ul><hr><h2 id="Item-25"><a href="#Item-25" class="headerlink" title="Item 25"></a>Item 25</h2><ul><li><p>合理运用<code>universal reference</code>可以有许多好处。考虑下以下两端代码：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With universial reference</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name = std::forward&lt;T&gt;(newName);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ... Other codes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// With two override functions</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(std::string&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> = newName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ... Other codes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  前者就比后者好一些。首先，后者增加了源代码的编写以及要维护的代码量。其次，它可能更加低效。比如说：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.<span class="built_in">setname</span>(<span class="string">&quot;cyyzero&quot;</span>);</span><br></pre></td></tr></table></figure><p>  使用<code>universal reference</code>版本，那么它被转发给<code>std::string</code>,并且只调用 <code>std::string</code> 的一次赋值函数。而对于两个重载版本的<code>setName</code>，将会创建一个临时的<code>std::string</code>对象，然后临时对象移动，最后析构。Last but not least，对于后者不仅源代码体积膨胀和执行期的效率低下，而且它是一种可拓展性很差的设计。可能需要重载的数量会很多。</p></li><li><p>在某些情况下，你想要用绑定到 <em>rvalue reference</em> 或者 <em>universal reference</em> 的值多次，那么在最后一次才用<code>std::move</code>或者<code>std::forward</code>.</p></li><li><p>RVO， 即<code>return value optimization</code>，是指编译器对于返回值需要copy 的情况进行了优化，让copy避免。通常<em>当local对象和返回值类型相同，并且这个local对象被返回</em>，则会进行RVO优化。如果不符合消除拷贝的条件，返回值会被视为右值。所以对于<code>return std::move(ret);</code>这样试图对返回局部变量进行优化的情况，属于画蛇添足。它不会帮到编译器，还可能阻碍了优化(因为所返回对象的类型变成了rvalue reference)。</p></li><li><p>对于返回值是传值，但返回的对象是左值或者右值引用的情况，那么把 <code>std::move</code> 用在右值引用上， <code>std::forward</code> 用在 <em>universal reference</em> 上。</p></li></ul><hr><h2 id="Item-26"><a href="#Item-26" class="headerlink" title="Item 26"></a>Item 26</h2><ul><li><p>对参数是 <em>universal reference</em> 的模板函数的重载，将会导致几乎都只调用参数是 <em>universal reference</em> 的版本。</p></li><li><p>完美转发的构造函数一般会导致很多问题，因为对于参数是<code>non-const lvalue</code>的拷贝构造，和它的继承类调用它的拷贝或移动构造函数的时候，都会调用它。</p></li><li><p>总而言之，尽量别对参数是<em>universal reference</em>的函数重载。</p></li></ul><hr><h2 id="Item-27"><a href="#Item-27" class="headerlink" title="Item 27"></a>Item 27</h2><p>对于上述的问题，有一些办法可以解决。</p><ul><li><p>放弃重载。定义多个不同的函数。</p></li><li><p>通过<code>const T&amp;</code>传参数。缺陷就在于效率可能会降低（因为不能move）。但是有时候选择放弃效率带来代码的简单，不失为一种方案。</p></li><li><p>传值。这可能是反直觉的，因为传值意味着拷贝对象，很多时候都会带来很大的开销。但是知道需要拷贝的时候，就可以考虑传值，然后再将副本move。</p></li><li><p>用<em>Tag dispath</em>（标签分派）。函数A参数设置为<em>universal reference</em>，然后通过对参数类型的分类，分派给其他函数。举个例子：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; names;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">nameFromIdx</span><span class="params">(<span class="type">int</span> idx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(<span class="type">int</span> idx, std::true_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logAndAdd</span>(<span class="built_in">nameFromIdx</span>(idx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(T&amp;&amp; name, std::false_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrno::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logAndAddImpl</span>(</span><br><span class="line">        std::forward&lt;T&gt;(name), </span><br><span class="line">        std::is_integral&lt;<span class="keyword">typename</span> std::remove_referene&lt;T&gt;::type&gt;()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>约束接收universal reference作为参数的模板。这是后需要用到<code>std::enable_if</code>。它的工作原理基于SFINAE。配合type traits，可以出色地完成工作：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span></span><br><span class="line">    &lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if</span><br><span class="line">        &lt;</span><br><span class="line">            !std::is_base_of</span><br><span class="line">            &lt;</span><br><span class="line">                Person,</span><br><span class="line">                <span class="keyword">typename</span> std::decay&lt;T&gt;::type</span><br><span class="line">            &gt;::type</span><br><span class="line">            &amp;&amp;</span><br><span class="line">            !std::is_integeral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;::value</span><br><span class="line">        &gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="built_in">Person</span>(T&amp;&amp; t)</span><br><span class="line">        :<span class="built_in">name</span>(std::forward&lt;T&gt;(t)) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> Idx)</span><br><span class="line">        :<span class="built_in">name</span>(<span class="built_in">nameFromIdx</span>(Idx)) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  不太好理解的地方：<code>std::enable_if</code>,<code>std::is_base_of</code>,<code>std::decay</code>,<code>std::is_integeral</code>.</p></li><li><p>权衡。使用universal reference通常能减小开销，但是随之而来的也有许多劣势。一来有些参数不能玩么转发。二来有时候完美转发后的出错信息可读性差。比如说上面的例子，传给Person的参数不能构造<code>std::string</code>，此时的报错将很感人。所以最好用<code>static_assert</code>确定它时候符合要求。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span></span><br><span class="line">    &lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if</span><br><span class="line">        &lt;</span><br><span class="line">            !std::is_base_of</span><br><span class="line">            &lt;</span><br><span class="line">                Person,</span><br><span class="line">                <span class="keyword">typename</span> std::decay&lt;T&gt;::type</span><br><span class="line">            &gt;::type</span><br><span class="line">            &amp;&amp;</span><br><span class="line">            !std::is_integeral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;::value</span><br><span class="line">        &gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="built_in">Person</span>(T&amp;&amp; t)</span><br><span class="line">        :<span class="built_in">name</span>(std::forward&lt;T&gt;(t))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">static_assert</span></span><br><span class="line">            (</span><br><span class="line">                std::is_constructible&lt;std::string, T&gt;::value,</span><br><span class="line">                <span class="string">&quot;Parameter n can;t be usedd to construct a std::string&quot;</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="Item-28"><a href="#Item-28" class="headerlink" title="Item 28"></a>Item 28</h2><p>C++禁止声明引用的引用。但是编译器可能在特定上下文，以及模板实例化的时候遇到它们。这时候，引用折叠(<em>reference collapsing</em>)就派上用场了。引用折叠大概的规则就是：<em>如果有一个是左值引用，结果就是左值引用。否则(即都是右值引用)，结果为右值引用</em>。</p><ul><li>T&amp;&amp; &amp;&amp; &#x3D;&gt; T&amp;&amp;</li><li>T&amp;&amp; &amp;  &#x3D;&gt; T&amp;</li><li>T&amp; &amp;&amp;  &#x3D;&gt; T&amp;</li><li>T&amp; &amp;   &#x3D;&gt; T&amp;</li></ul><p>引用折叠主要在四种情况中出现：</p><ul><li><p>模板实例化。其实主要就是参数是<em>universal reference</em>的函数模板实例化的时候。<em>universal reference</em>配上<code>std::forward</code>，主要就是引用折叠的规则才使得完美转发成为可能。比如说有个完美转发的例子：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//std::forward的简单实现</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_refrence&lt;T&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">someFunc</span>(forward&lt;T&gt;(fParam));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回Widget对象的工厂函数</span></span><br><span class="line"><span class="function">Widget <span class="title">getWidget</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="built_in">f</span>(w);                <span class="comment">// 情况(1)</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="built_in">getWidget</span>());      <span class="comment">// 情况(2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  对于情况(1)，f函数和forward函数会被推断成这样：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp; &amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">someFunc</span>(forward&lt;Widget&amp;&gt;(fParam));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget&amp; &amp;&amp; <span class="title">forward</span><span class="params">(Widget &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  正是由于引用折叠的存在，它事实上是这样的：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">someFunc</span>(forward&lt;Widget&amp;&gt;(fParam));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget&amp; <span class="title">forward</span><span class="params">(Widget &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <em>函数返回左值引用，返回值是个左值</em>。所以 forward 返回值是 Widget 左值。于是完美转发成功。</p><p>  对于情况(2)， f 函数和 forward 函数会被推断成这样：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">someFunc</span>(forward&lt;Widget&gt;(fParam));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  *函数返回右值引用，返回值是 xvalue (一种右值)*。所以forward的返回值是 Widget 右值。完美转发也成功了。</p><p>  ps：一开始我对于在f函数体内somefunc函数匹配规则不太理解，不太理解引用作为参数模板怎么推断。后来查了下，<em>从函数调用推导模板参数 P 的时候，若 P 是引用类型，则用 P 所引用的类型推导</em>。那么一切问题都迎刃而解了。</p></li><li><p>auto类型推导的时候。这个也不难想到，因为 auto 推导规则和模板类型推导差不多(见 Item 3)。还是来看一些例子：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; wi = w;</span><br><span class="line"><span class="comment">// 等价于 Widget&amp; &amp;&amp; w1 = w;   =&gt;     Widget &amp;w1 = w;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; w2 = <span class="built_in">getWidget</span>();</span><br><span class="line"><span class="comment">// 等价于 Widget&amp;&amp; w2 = getWidget();</span></span><br></pre></td></tr></table></figure></li><li><p><em>typedef</em> 和 <em>alias declarations</em>。在模板中声明等价类型的时候，也经常运用引用折叠。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;&amp; RvalueRefToT;     <span class="comment">// RvalueRefToT类型可能和预期的右值引用不太一样，由于T类型未知，如果发生引种折叠，它还可能是左值引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>decltype</em>。当使用<em>decltype</em>配合引用的时候，也可可能发生引用折叠。</p></li></ul><p>最后总结:<code>universal reference</code>能工作就是依靠两点，一是类型推导能区分左值和右值，二是引用折叠的作用。</p><hr><h2 id="Item-29"><a href="#Item-29" class="headerlink" title="Item 29"></a>Item 29</h2><ul><li><p>有时候，移动不一定比拷贝快。举个例子：</p><ul><li><code>std::array</code>。<code>std::array</code> 的数据不会存放在堆上，基本就是内置数组类型的简单封装。所以移动也是O(n)复杂度。</li><li>很多 <code>std::string</code> 的实现都采用了 *small string optimization(SSO)*。比较短的字符串可能不会在存在堆上。这样移动的话效率也不会比拷贝高。</li></ul></li><li><p>有些时候，为了保证老代码在C++98下的强异常安全，如果有移动操作但移动操作没有声明 <code>noexcept</code>，编译器也会选择采用拷贝操作。</p></li></ul><hr><h2 id="Item-30"><a href="#Item-30" class="headerlink" title="Item 30"></a>Item 30</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(T&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;T&gt;(params)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个很简答的完美转发的例子。但是实际上，它有时候并非如“完美”。在以下情况中完美转发会失败：</p><ul><li>编译器无法推断类型。</li><li>推断的类型并非预期。这可能会造成编译失败，或者匹配重载函数的其他版本。</li></ul><p>当参数比较特殊的收就很容易出错。举一些例子：</p><ul><li><p><em>Branced initializers</em> 。假设 <em>f</em> 声明为如下：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);             <span class="comment">// Ok, 列表隐式转化为向量</span></span><br><span class="line"><span class="built_in">fwd</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);           <span class="comment">// 编译失败</span></span><br></pre></td></tr></table></figure><p>  这是因为如果直接调用 <em>f</em> ，编译器将会对实参和形参类型匹配，但必要的时候会进行隐式转化。而通过 <em>fwd</em> 调用的时候，标准规定不能推断表达式 <code>&#123;1,2,3&#125;</code> 的类型(<code>std::initializer_list</code> 是 “<em>non-deduced context</em>”)。只有fwd的参数被声明为 <code>std::initializer_list</code>的时候，才可以这么传参数。而 <code>auto</code> 就不受这个限制了，可以这么写：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> il = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">fwd</span>(il);              <span class="comment">// It works.</span></span><br></pre></td></tr></table></figure></li><li><p>0 或者 <em>NULL</em>。很可能会被腿短成int类型，而非空指针。所以用 <code>nullptr</code> 代替它们。</p></li><li><p>只有声明的 static const 成员变量。建议写上定义(不要重复初始化)。否则可能会在参数是引用的函数传参时链接失败。</p></li><li><p>重载函数的名字或者模板的名字。这通常对于 <em>f</em> 参数是函数指针的时候，给 <em>f</em> 传重载函数的函数名，编译器会选择签名相同函数传指针过去。而对于 <em>fwd</em> ，来说，如果给它的参数是重载函数或者模板的名字，就无法推断，编译出错。解决的办法就是先定义一个函数指针，然后再作为参数传递给 <em>fwd</em> 。</p></li><li><p>位域(<em>Bitfields</em>)。因为位域的成员是无法引用的，所以将它作为参数传递给 <em>fwd</em> 就会出问题。(原因在于位域的成员可能是任意的bit，比如说一个32位int类型的第3到第5个bit，这就无法寻址)。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;右值引用，移动语义和完美转发&quot;&gt;&lt;a href=&quot;#右值引用，移动语义和完美转发&quot; class=&quot;headerlink&quot; title=&quot;右值引用，移动语义和完美转发&quot;&gt;&lt;/a&gt;右值引用，移动语义和完美转发&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;*移动语义(Move se</summary>
      
    
    
    
    <category term="C++" scheme="http://cyyzero.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective Modern C++读书笔记(二)</title>
    <link href="http://cyyzero.github.io/2018/02/12/C++/effective_modern_cpp_2/"/>
    <id>http://cyyzero.github.io/2018/02/12/C++/effective_modern_cpp_2/</id>
    <published>2018-02-12T13:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>首先，raw pointer有着诸多缺陷</p><ul><li>指向对象的不明确(单个对象or数组？)</li><li>析构方式的不明确(<code>delete</code>，<code>delete[]</code>还是一个特殊的析构机制，比如调用某个函数)</li><li>析构的时机、次数容易出错</li><li>容易出现dangling pointer</li></ul><p>所以，c++11有了智能指针。</p><hr><h2 id="Item-18"><a href="#Item-18" class="headerlink" title="Item 18"></a>Item 18</h2><ul><li><p>资源紧缺的机器上也可以用<code>std::unique_ptr</code>，因为当它使用默认或者stateless lambda作为删除器的时候，和raw pointer大小一样。而且对于很多操作(比如解引用)，它们执行相同的指令。</p></li><li><p><code>std::unique_ptr</code>体现了独占所有权(exclusive ownership)的语义。只能move，不能copy。</p></li><li><p>对于层级继承关系来说，可以用工厂函数返回<code>std::unique_ptr</code>。并且调用方可以用<code>std::shared_ptr</code>来接收工厂函数的返回值。</p></li><li><p><code>std::unique_ptr</code>有两种形式，一个是单独的对象(<code>std::unique_ptr&lt;T&gt;</code>)，另一个是数组(<code>std::unique_ptr&lt;T[]&gt;</code>)。不过对于后者来说，c++中已经有了足够多足够好的替代品(比如说<code>std::array</code>、<code>std::vector</code>、<code>std::string</code>)。最好在使用返回一个裸指针的C-like API的时候才使用std::unique_ptr&lt;T[]&gt;。</p></li></ul><hr><h2 id="Item-19"><a href="#Item-19" class="headerlink" title="Item 19"></a>Item 19</h2><ul><li><p><code>std::shared_ptr</code>性能影响:</p><ul><li>大小是raw pointer的两倍。因为还有一个指向control block的raw pointer。</li><li>引用计数的内存是动态分配的。</li><li>引用计数增加和减少是原子操作。可能会降低速度。</li><li>control block用到了虚函数。</li></ul></li><li><p><code>std::shared_ptr</code>的移动操作比拷贝操作快。因为移动操作会直接让源std::shared_ptr置null，这意味着旧的std::shared_ptr引用计数不用操作。</p></li><li><p>对于<code>std::unique_ptr</code>来说，删除器是它类型的一部分；而对于<code>std::shared_ptr</code>来说却不是。而且改变<code>std::shared_ptr</code>的删除器不会改变它的大小(因为分配在堆上)。</p></li><li><p>std::shared_ptr<T>包含两个部分：Ptr to T和Ptr to Control Block。</p><ul><li><p>Ptr to T指向Ｔ Object;</p></li><li><p>Ptr to Control Block指向：</p><ul><li>Reference Count</li><li>Weak Count</li><li>Other Data(e.g.,custon deleter,allocto,etc)</li></ul></li></ul></li><li><p>一些关于control block的规则：</p><ul><li><code>std::make_shared</code>总是会创建一个control block。</li><li>当一个<code>std::shared_ｐtr</code>用unique_ptr或者auto_ptr构造的时候，也会创建一个control block。</li><li>用一个raw pointer构造<code>std::shared_ptr</code>的时候，也会创建一个control block。</li></ul></li><li><p>基于以上的规则，用同一个raw pointer构造多个<code>std::shared_ptr</code>是未定义行为。会有多个control block，导致对象被多次析构。</p></li><li><p><code>std::shared_ptr</code>不同于<code>std::unique_ptr</code>，不能很好地工作于数组。没有<code>std::shared_ptr&lt;T[]&gt;</code>的版本。所以默认删除器用的<code>delete</code>，而且没有重载<code>oparetor[]</code>。而且对于单个对象，<code>std::shared_ptr</code>允许从派生类向基类的转化；当作用在数组上时，可能会有奇怪的行为。所以尽量用<code>std::array</code>或者<code>std::vector</code>代替build-in array。</p></li></ul><hr><h2 id="Item-20"><a href="#Item-20" class="headerlink" title="Item 20"></a>Item 20</h2><ul><li><p><code>std::weak_ptr</code>不能解引用。所以一般还得用<code>std::shared_ptr</code>。</p><ul><li><p>一种形式</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从前有一个wpw是std::weak_ptr</span></span><br><span class="line">std::shared_ptr&lt;Widget&gt; spw1 = wpw.<span class="built_in">lock</span>();  <span class="comment">//如果wpw悬垂，spw1是空指针。</span></span><br><span class="line"><span class="keyword">auto</span> spw2 = wpw.<span class="built_in">lock</span>();                     <span class="comment">//同上。</span></span><br><span class="line"><span class="comment">//其他操作</span></span><br></pre></td></tr></table></figure></li><li><p>另一种形式</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw3</span><span class="params">(wpw)</span></span>;  <span class="comment">//如果wpw悬垂，抛出std::bad_weak_ptr异常</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用<code>std::weak_ptr</code>的例子：</p><ul><li><p>由于某个类构造开销比较大，所以设计了cache factory function，将不同的对象构造并缓存，返回<code>std::shared_ptr</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">const</span> Widget&gt; <span class="title">fastLoadWidget</span><span class="params">(WidgetId id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> std::unordered_map&lt;WidgetID, std::weak_ptr&lt;<span class="type">const</span> Widget&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> objPtr = cache[id].<span class="built_in">lock</span>();     <span class="comment">//objPtr是指向缓存对象的std::shared_Ptr(当然，对象无缓存就是null了)</span></span><br><span class="line">    <span class="keyword">if</span> (!objPtr)</span><br><span class="line">    &#123;                                  <span class="comment">//如果没缓存，</span></span><br><span class="line">        objPtr = <span class="built_in">loadWidget</span>(id);       <span class="comment">//构造它</span></span><br><span class="line">        cache[id] = objPtr;            <span class="comment">//缓存它</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>观察者设计模式(Observer design pattern)中，subject(状态会变化的对象)通常有一个成员是指向observer(观察者，观察subject的变化)的指针。这个指针对于控制observer的生命周期不感兴趣(即不需要std::shared_ptr)，但是需要确定指向的observer是否已经被析构，所以用<code>std::weak_ptr</code>。</p></li><li><p>三个对象A，B，C。A和C通过std::shared_ptr指向B，即共享B的所有权。B需要有一个指针也指向A。有三个选择：</p><ul><li><em>Raw pointer</em>。如果A被析构，就悬垂了。</li><li><em>std::shared_ptr</em>。A和B都用std::shared_ptr指向对方，这个嵌套会导致A和B都不会被析构。</li><li><em>std::weak_ptr</em>。这是个最佳选择，不会有上述的问题。</li></ul><p>  ps：用std::weak_ptr阻止<code>std::shared_ptr</code>循环的方法不是很常见。对于有严格分层的数据机构，比如说树来说，子节点属于父节点，父节点析构，子节点也应该被析构。父节点指向子节点用<code>std::unique_ptr</code>，子节点指向父节点用raw pointer。因为子节点总是会随着父节点被析构，不会出现子节点指向的父节点悬垂的情况。</p></li></ul></li><li><p><code>std::weak_ptr</code>和<code>std::shared_ptr</code>大小相同。<code>std::weak_ptr</code>不参与对象的所有权，因此不会影响指向对象的reference count。</p></li></ul><hr><h2 id="Item-21"><a href="#Item-21" class="headerlink" title="Item 21"></a>Item 21</h2><ul><li><p>有三个make函数，作用都是完美转发参数然后构造某个对象，并让智能指针指向它。分别是</p><ul><li><p><code>std::make_unique</code>.c++14才加入了标准库。不过自己也可以写个类似很简单的实现</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">        std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Ts&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">        &#125;</span><br><span class="line">        ````</span><br><span class="line">    * `std::make_shared`。和`std::make_unique`大同小异。</span><br><span class="line">    * `std::allocate_shared`。和`std::make_shared`作用几乎相同。但是它的第一个参数是一个allocator对象。</span><br><span class="line"></span><br><span class="line">* 用make函数的好处</span><br><span class="line"></span><br><span class="line">    * 一是不用重复类型</span><br><span class="line"></span><br><span class="line">        ```<span class="function">cpp</span></span><br><span class="line"><span class="function">        <span class="keyword">auto</span> <span class="title">upw1</span><span class="params">(std::make_unique&lt;Widget&gt;())</span></span>;    <span class="comment">//with make func</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;Widget&gt; <span class="title">upw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>; <span class="comment">//without make func</span></span><br></pre></td></tr></table></figure></li><li><p>而是异常安全。考虑以下这个代码：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从前有两个函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; spw, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">computePriority</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">computePriority</span>());</span><br></pre></td></tr></table></figure><p>  将会导致可能的内存泄露。因为上述最后一行代码的参数完成操作需要：</p><ul><li>new Widget，即一个Widget对象被创建在堆上。</li><li>std::shared_ptr<Widget>被构造。</li><li>computePriority必须执行一次。</li></ul><p>  构造<code>std::shared_ptr&lt;Widget&gt;</code>肯定会发生在<code>new Widget</code>之后，毕竟后者作为前者的参数。但是<code>computePriority</code>函数执行的时间不确定。编译器可能会让<code>computePriority</code>正好在<code>new Widget</code>之后被调用。如果在运行期间，<code>computePriority</code>函数抛出异常，那么就内存泄漏了。所以应该用make函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个函数同上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; spw, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">computePriority</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">make_shared</span>&lt;Widget&gt;(), computePriority);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>用make函数性能上也可能会更好。考虑一下代码</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br></pre></td></tr></table></figure><p>  它总共分配了两次空间。一次是<code>new Widget</code>，另一个是构造<code>std::shared_ptr&lt;Widget&gt;</code>时，分配cotrol block。</p><p>  而对于make函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = std::<span class="built_in">make_shared</span>&lt;Widget&gt;();</span><br></pre></td></tr></table></figure><p>  只需要申请一次空间。因为会一次分配能容纳Widget对象和control block大小之和的空间，然后在分别初始化它们。不仅如此，根据cpu cache局部性，以后缓存命中率还可能更高。</p></li><li><p>不过make函数也有一些局限性：</p><ul><li><p>不能指定删除器。而直接用智能指针的构造函数却可以。</p></li><li><p>当你小要用花括号作为对象构造函数的时候，不能用make函数。或者这么用：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create std::initalizer_list</span></span><br><span class="line"><span class="keyword">auto</span> initList = &#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="comment">//createstd::vector using std::initializer_list ctor</span></span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(initList);</span><br></pre></td></tr></table></figure><p>  对于<code>std::unique_ptr</code>，它的make函数有以上缺点。但是对于<code>std::shared_ptr</code>和它的make函数来说，还有另外两个缺点(都是极端情况</p></li><li><p>如果一个对象的类型有自定义版本的operator new和operator delete，那么使用make函数来创建他们通常是一个糟糕的想法。</p></li><li><p>上面也提到过，当使用make函数的时候，会一次分配能容纳Widget对象和control block大小之和的空间。而control block有reference count和weak count。只要weak count大于0，引用快就必须存在。那么显然，会有对象所占的内存无法及时释放的情况出现：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReallyBigType</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">auto</span> pBigObj = std::<span class="built_in">make_shared</span>&lt;ReallyBigType&gt;();      <span class="comment">//通过make_shared创建一个很大的对象</span></span><br><span class="line"></span><br><span class="line">...                                                    <span class="comment">//创建若干个指向此对象的std::shared_ptr和std::weak_ptr并使用它们</span></span><br><span class="line"></span><br><span class="line">...                                                    <span class="comment">//最后一个指向此对象的std::shared_ptr在这被销毁。但是std::weak_ptr仍然保持</span></span><br><span class="line"></span><br><span class="line">...                                                    <span class="comment">//在这期间，先前创建的大对象所占的内存仍然没有被回收</span></span><br><span class="line"></span><br><span class="line">...                                                    <span class="comment">//最后一个指向此对象的std::weak_ptr在这被销毁。对象和control所占的内存才被释放。</span></span><br></pre></td></tr></table></figure><p>  这种情形直接用new反而更好。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReallyBigType</span>&#123;...&#125;;                                       <span class="comment">//和之前一样</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;ReallyBigType&gt; <span class="title">pBigObj</span><span class="params">(<span class="keyword">new</span> ReallyBigType)</span></span>;      <span class="comment">//通过new创建一个很大的对象</span></span><br><span class="line"></span><br><span class="line">...                                                             <span class="comment">//和之前一样，创建若干个指向此对象的std::shared_ptr和std::weak_ptr并使用它们</span></span><br><span class="line"></span><br><span class="line">...                                                             <span class="comment">//最后一个指向此对象的std::shared_ptr在这被销毁。但是std::weak_ptr仍然保持。为对象分配的空间已经被释放</span></span><br><span class="line"></span><br><span class="line">...                                                             <span class="comment">//在这期间，只有control block的空间还没释放</span></span><br><span class="line"></span><br><span class="line">...                                                             <span class="comment">//最后一个指向此对象的std::weak_ptr在这被销毁。control block所占的内存才被释放。</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="Item-22"><a href="#Item-22" class="headerlink" title="Item 22"></a>Item 22</h2><p><em>Pimpl(“pointer to implementation”) Idiom</em>是医用用来缩短编译时间的技术。用一个指向某个class(or struct)的指针来代替具体的成员对象。举个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in header &quot;widget.h&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;            <span class="comment">//Gadget是用户自定义的类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次Gadget.h改变，都得重新编译。所以运用<code>Pimpl Idiom</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//still in header &quot;widget.h&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;   <span class="comment">// declare implementation struct</span></span><br><span class="line">    Impl *pImpl;   <span class="comment">// and pointer to it</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次Gadget.h改变，Widget不受影响。<br>不过学了智能指针，你可能互相到把raw pointer换成std::unique_ptr。就想下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in &quot;widget.h&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in &quot;widget.cpp&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gadget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>()</span><br><span class="line">: <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure><p>可能注意到了，由于用智能指针管理资源，似乎用编译器生成的析构函数就能正常工作了的样子。编译没问题。不过，当你写下<code>WIdget w;</code>，想要使用它的时候，却会编译出错。</p><p>问题出在试图析构w，生成代码的时候。此时，析构函数将会被调用。根据编译器生成特殊成员函数的规则(详情见Item 17)，编译器试图生成一个析构函数。这个生成的析构函数会调用plmpl(一个使用默认删除器的std::unique_ptr)的析构函数。在这个指针的析构函数中，将会直接用<code>delete</code>作用于一个raw pointer。要注意到，在这时，Impl还是个不完全类型。但是，由于在实现在实现作用，默认deleter通常会用c++11的static_assert来确保指针指向完整类型。所以当编译器生成析构函数的时候，它就碰到了一个失败的static_assert。</p><p>要解决这个问题也很简单，做到在析构的时候Impl是完整类型就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in file &quot;widget.h&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ~<span class="built_in">Widget</span>();                          <span class="comment">// 只声明</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in file &quot;widget.cpp&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gadget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123; </span><br><span class="line">    std::string name; </span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() </span><br><span class="line">: <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;())</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()                       <span class="comment">// ~Widget的定义</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>如果想要强调编译器生成的析构函数就可以工作(声明它的唯一理由就是为了在Widget的实现中生成)，你也可以这么干:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget::~<span class="built_in">Widget</span>() = <span class="keyword">default</span>;  <span class="comment">//same effect as above</span></span><br></pre></td></tr></table></figure><p>处于同样的考量，还能加上move和copy操作。完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in file &quot;widget.h&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ~<span class="built_in">Widget</span>();                          <span class="comment">// 只声明</span></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(Widget&amp;&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in file &quot;widget.cpp&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gadget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123; </span><br><span class="line">    std::string name; </span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() </span><br><span class="line">: <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;())</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>() = <span class="keyword">default</span>;</span><br><span class="line">Widget::<span class="built_in">Widget</span>(Widget&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">: <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;(*rhs.pImpl));</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    *pImpl = *rhs,pImpl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果Pimpl采用<code>std::unique_ptr</code>，即使编译器生成的函数能工作，也需要明确的把比声明和实现分开来。</p><p>但是如果采用<code>std::shared_ptr</code>，上述的建议就不需要了。直接用编译器生成的函数就能够工作。</p><p>造成不同的根本原因是它们支持custom deleter的不同方式。</p><ul><li>对于<code>std::unique_ptr</code>，deleter是类型的一部分，使得编译器能够生成更小的运行期数据结构和更快的运行期代码。这个带来的后果就是，当编译器生成特殊函数的时候，指向的类型必须完整。</li><li>对于<code>std::shared_ptr</code>，deleter不是类型的一部分，使得需要更大的运行期数据结构和更慢的代码。但是当编译器产生特殊函数的时候，指向的类型不需要是完整的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;智能指针&quot;&gt;&lt;a href=&quot;#智能指针&quot; class=&quot;headerlink&quot; title=&quot;智能指针&quot;&gt;&lt;/a&gt;智能指针&lt;/h1&gt;&lt;p&gt;首先，raw pointer有着诸多缺陷&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指向对象的不明确(单个对象or数组？)&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="C++" scheme="http://cyyzero.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective Modern C++读书笔记(一)</title>
    <link href="http://cyyzero.github.io/2018/02/12/C++/effective_modern_cpp_1/"/>
    <id>http://cyyzero.github.io/2018/02/12/C++/effective_modern_cpp_1/</id>
    <published>2018-02-12T12:15:31.000Z</published>
    <updated>2023-10-29T07:13:44.879Z</updated>
    
    <content type="html"><![CDATA[<p>ps:第一本看的英文原版…希望这个寒假能看完吧</p><h1 id="Item-1-5"><a href="#Item-1-5" class="headerlink" title="Item 1-5"></a>Item 1-5</h1><ul><li>（建议直接看书，个人认为很重要</li></ul><h1 id="Item-6"><a href="#Item-6" class="headerlink" title="Item 6"></a>Item 6</h1><ul><li>警惕<code>auto</code>被类型推导为某个意想不到的proxy class（ie. vector<bool>::operator[]）</li></ul><h1 id="Item-7"><a href="#Item-7" class="headerlink" title="Item 7"></a>Item 7</h1><ul><li><p>大括号可以用来完成uniform initialization，且不会发生隐式narrowing conversion.</p></li><li><p>一般来说，<code>Object o&#123;xxx&#125;;</code>会优先匹配参数是std::initializer_list的构造函数</p></li><li><p>类内非静态成员不能用()初始化</p></li><li><p><code>auto t = &#123;xxx&#125;;</code>, t类型被推断为std::initializer_list</p></li><li><p>一组对比</p><ul><li><code>Object o();</code> &#x3D;&gt; Error</li><li><code>Object o&#123;&#125;;</code> &#x3D;&gt; OK</li></ul></li><li><p>另一组对比</p><ul><li><code>Object o&#123;&#125;;</code>调用默认构造函数</li><li><code>Object o&#123; &#123;&#125;&#125;;</code>或者<code>Object o( &#123;&#125;);</code>调用参数为空的std::initializer_list的构造函数</li></ul></li></ul><h1 id="Item-8"><a href="#Item-8" class="headerlink" title="Item 8"></a>Item 8</h1><ul><li>0，NULL和nullptr三者，用nullptr表示空指针(之前单独总结过，不多说了)（逃</li></ul><h1 id="Item-9"><a href="#Item-9" class="headerlink" title="Item 9"></a>Item 9</h1><ul><li><p>With a alias template:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                          <span class="comment">// MyAllocList&lt;T&gt;</span></span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;; <span class="comment">// is synonym for</span></span><br><span class="line">                                              <span class="comment">// std::list&lt;T,</span></span><br><span class="line">                                              <span class="comment">//     MyAlloc&lt;T&gt;&gt;</span></span><br><span class="line"></span><br><span class="line">MyAllocList&lt;Widget&gt; lw;                       <span class="comment">// client code</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">MyAllocList&lt;T&gt; list;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>And with a typedef:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// MyAllocList&lt;T&gt;::type</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAllocList</span> &#123;</span><br><span class="line"><span class="comment">// is synonym for</span></span><br><span class="line"><span class="keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type; <span class="comment">// std::list&lt;T,</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//MyAlloc&lt;T&gt;&gt;</span></span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw;</span><br><span class="line"><span class="comment">// client code</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="comment">// Widget&lt;T&gt; contains</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// a MyAllocList&lt;T&gt;</span></span><br><span class="line"><span class="keyword">typename</span> MyAllocList&lt;T&gt;::type list;</span><br><span class="line"><span class="comment">// as a data member</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>c++14运用alias template的一点改进</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::remove_const&lt;T&gt;::type</span><br><span class="line">std::<span class="type">remove_const_t</span>&lt;T&gt;</span><br><span class="line"><span class="comment">// C++11: const T → T</span></span><br><span class="line"><span class="comment">// C++14 equivalent</span></span><br><span class="line">std::remove_reference&lt;T&gt;::type</span><br><span class="line">std::<span class="type">remove_reference_t</span>&lt;T&gt;</span><br><span class="line"><span class="comment">// C++11: T&amp;/T&amp;&amp; → T</span></span><br><span class="line"><span class="comment">// C++14 equivalent</span></span><br><span class="line">std::add_lvalue_reference&lt;T&gt;::type</span><br><span class="line"><span class="comment">// C++11: T → T&amp;</span></span><br><span class="line">std::<span class="type">add_lvalue_reference_t</span>&lt;T&gt;</span><br><span class="line"><span class="comment">// C++14 equivalent</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="Item10"><a href="#Item10" class="headerlink" title="Item10"></a>Item10</h1><ul><li><p>一般来说，用scoped enums代替unscoped enums。</p><ul><li>scoped emums带来了namespace pollution。</li><li>unscoped enums的成员会隐式转化成整数类型。scoped enums则不会（但可以显式转化）。（这个带来了一点好处。见下</li></ul></li><li><p>tuple和unscoped enum搭配更佳， 免去记住所有参数序列。否则就得…</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">toUType</span><span class="params">(E enumerator)</span> noexecpt</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;<span class="built_in">toUType</span>(UserInFoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure></li></ul><h1 id="Item-11"><a href="#Item-11" class="headerlink" title="Item 11"></a>Item 11</h1><ul><li><p>c++11前常常将成员函数声明放在private区域而不实现，以防止编译器自动生成。现在有了<code>=delete</code></p></li><li><p><code>=delete</code>不光能用于成员函数。还能通过讲“重载函数”声明为<code>=delete</code>防止函数的参数被隐式转换。</p></li><li><p><code>=delete</code>还能用于阻止template instantiation。</p></li></ul><h1 id="Item-12"><a href="#Item-12" class="headerlink" title="Item 12"></a>Item 12</h1><ul><li><p>override虚函数的时候加上 <code>override</code>关键词。</p></li><li><p>member function reference qualifiers能区分<code>*this</code>的类别（类似于以前的const</p></li></ul><h1 id="Item-13"><a href="#Item-13" class="headerlink" title="Item 13"></a>Item 13</h1><ul><li><p>在c++98的时候，容器的非const对象无法直接获得const_iterator，一般通过强制转化，或者用绑定到一个reference-to-const。</p></li><li><p>在c++98，const_iterator不能用于在插入或者删除的函数指示位置。</p></li><li><p>c++11提供了<code>begin</code>和<code>end</code>函数（包括许多容器的成员函数和非成员函数的通用版本）。但是c++14才提供了（这里指的是non-member版本）<code>cbegin</code>, <code>cend</code>, <code>rbegin</code>, <code>rend</code>和<code>crend</code>。有个用c++11实现<code>cbegin</code>的例子。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">C</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cbegin</span><span class="params">(<span class="type">const</span> C&amp; container)</span>-&gt;<span class="title">decltype</span><span class="params">(std::begin(container))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">retrurn <span class="title">std::begin</span><span class="params">(container)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Item-14"><a href="#Item-14" class="headerlink" title="Item 14"></a>Item 14</h1><ul><li><p>exception-neutral函数(指这类函数：它本身不抛出异常，但是它调用的函数可能会抛出异常)不能加noexcept</p></li><li><p>典型地，move operations，swap，memory deallocation函数， destructor都默认noexcept</p></li></ul><h1 id="Item-15"><a href="#Item-15" class="headerlink" title="Item 15"></a>Item 15</h1><ul><li><p>constexpr对象是编译期常量。(不过准确的说，应该<code>translation</code>期间的常量，包括编译<code>compile</code>和链接<code>link</code>)</p></li><li><p>对于constexpr函数来说，有两种情况。这意味着不需要对运行期和编译期执行的函数进行重载</p><ul><li><p>如果所有参数都是编译期常量，函数将在编译期就得到结果。</p></li><li><p>当一个或多个参数不是编译期常量的时候，就和普通函数一样，在运行期执行。</p></li></ul></li><li><p>constexpr是函数接口的一部分，不能随意去除</p></li></ul><h1 id="Item-16"><a href="#Item-16" class="headerlink" title="Item 16"></a>Item 16</h1><ul><li>对于某个需要同步的对象来说，用std::atomic就够了。但是对于多个对象作为一个整体需要同步的时候，往往需要用到mutex。</li></ul><h1 id="Item-17"><a href="#Item-17" class="headerlink" title="Item 17"></a>Item 17</h1><ul><li><p>c++11开始，特殊成员函数有</p><ul><li>defualt constructor 默认构造函数</li><li>destructor 析构函数</li><li>copy constructor 拷贝构造函数</li><li>copy assignment operator 拷贝赋值函数</li><li>move constructor 移动构造函数</li><li>move assignment operator 移动赋值函数</li></ul></li><li><p>对于后两个移动操作有关的函数(构造和赋值)来说，编译器默认生成的版本的行为是对所有非static成员调用执行对应(构造或赋值)的移动操作。对于带有继承的类来说，还会对基类进行对应的移动操作。但是，遇到不支持移动操作的对象，所以会用copy来替代move操作。</p></li><li><p>完成上述操作的核心是将std::move用于相应的对象(即非static成员或者基类部分)，然后根据函数重载规则，会调用相应的copy和move函数。</p></li><li><p>这两个移动操作不是相互独立的。如果声明了其中一个，编译器将不会自动生成另一个。</p></li><li><p>声明了拷贝操作(拷贝构造函数和拷贝赋值函数),那么编译器将不会生成移动操作的版本。反之亦然。</p></li><li><p>c++98开始就有个<code>Rule of Three</code>，即析构函数，拷贝构造函数，拷贝赋值函数三者自定义了任意一个，那一般来说其他两个也得自定义，编译器生成的很可能是错误的行为。</p></li><li><p>总结：下面三个条件都成立，则移动操作将会被编译器生成：</p><ul><li>没有声明拷贝操作</li><li>没有声明移动操作</li><li>没有声明析构函数</li></ul></li><li><p>想让编译器生成可以显示地用<code>=default</code>。尽量别依赖编译器隐式生成的规则，一是能规避复杂规则带来的bug，二是让代码意图明显。</p></li><li><p>成员函数模板不会影响编译器生成这些特殊成员函数。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ps:第一本看的英文原版…希望这个寒假能看完吧&lt;/p&gt;
&lt;h1 id=&quot;Item-1-5&quot;&gt;&lt;a href=&quot;#Item-1-5&quot; class=&quot;headerlink&quot; title=&quot;Item 1-5&quot;&gt;&lt;/a&gt;Item 1-5&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;（建议直接看书，个</summary>
      
    
    
    
    <category term="C++" scheme="http://cyyzero.github.io/categories/C/"/>
    
    
  </entry>
  
</feed>
