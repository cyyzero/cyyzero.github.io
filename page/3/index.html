<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"cyyzero.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Eden">
<meta property="og:url" content="http://cyyzero.github.io/page/3/index.html">
<meta property="og:site_name" content="Eden">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yiyang Chen">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://cyyzero.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Eden</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Eden" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Eden</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yiyang Chen"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Yiyang Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cyyzero" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cyyzero" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cyyzero@qq.com" title="E-Mail → mailto:cyyzero@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/9748477/cyyzero" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;9748477&#x2F;cyyzero" rel="noopener me" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2018/01/29/Linux/Linux_syscall/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/29/Linux/Linux_syscall/" class="post-title-link" itemprop="url">当我们谈论系统调用时，我们在谈论什么</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-29 12:15:31" itemprop="dateCreated datePublished" datetime="2018-01-29T12:15:31+00:00">2018-01-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ps:句式“当我们谈论XX时我们在谈论什么”引用自美国作家卡佛(Ramond Carver)的作品《当我们谈论爱情时我们谈论什么》(What We Talk About When We Talk About Love)。当然，我又标题党了，应该换成<strong>浅析IA32 Linux 系统调用过程</strong>比较合适。</p>
<p>当说到Linux下的系统调用(<strong>System Call</strong>)的时候，程序员都不会陌生。但一般都会联想到fork()，execve()等这些函数。这就是很多人(包括以前我自己)的误区所在了。</p>
<p>诸如fork() 这些，是c语言函数库(linux下常见如glibc)实现的<strong>外壳(wrapper)函数</strong>，由它们来引发真正的系统调用。从C语言编程的角度来看，调用C语言函数库的外壳函数等同于发起系统调用。也就是说，当我们在代码中使用诸如fork()这类函数时，意味着调用外壳函数，然后由外壳函数去调用系统调用(可能有点绕)。</p>
<p>区分了狭义上的外壳(wrapper)函数和系统调用后，就能进入本文的主题了:<strong>IA32上Linux系统调用的过程</strong>。(因为其他的不懂…</p>
<hr>
<p>首先描述两个概念，**中断(interruption)<strong>和</strong>异常(execption)**。从<a target="_blank" rel="noopener" href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf">Intel的手册</a>上找的简单介绍。</p>
<blockquote>
<p>The processor provides two mechanisms for interrupting program execution, interrupts and exceptions: </p>
</blockquote>
<blockquote>
<p>• An interrupt  is an asynchronous event that is typically triggered by an I&#x2F;O device.</p>
</blockquote>
<blockquote>
<p>• An exception is a synchronous event that is generated when the processor detects one or more predefined conditions while executing an instruction. The IA-32 architecture specifies three classes of exceptions: faults, traps, and aborts. </p>
</blockquote>
<p>简单地说，中断和异常是处理器提供的中断程序执行的机制，能引起X86挂起当前指令流的执行并相应事件。在这两种情况下处理器都会保存当前进程的上下文，并将转至一个预先定义的子程序来执行特殊的服务。</p>
<p>虽说中断和异常概念上有所区别，但在IA32上处理它们却是用了相同的方式。系统为每种类型的中断和异常分配了唯一的一个无符号整型作为一个向量(vector)，即可以理解为索引。然后内核维护的一张叫做<strong>中断描述符表</strong>(interrupt descriptor table， 一般简称为<strong>IDT</strong>)的结构，表中每一项都是某个中断或者异常对应的处理程序的入口地址。然后每次发生了某个中断和异常，就能通过它的向量，就在IDT中找到相应的处理程序并调用。</p>
<p>具体到汇编语言，就是通过INT指令来实现。INT(interrupt的缩写)指令的作用是引发中断和异常的处理程序，格式形如INT n。</p>
<p>从<a target="_blank" rel="noopener" href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf">Intel的手册</a>上找的INT指令的简单介绍。</p>
<blockquote>
<p>The INT n instruction generates a call to the interrupt or exception handler specified with the destination operand The destination operand specifies a vector from 0 to 255, encoded as an 8-bit unsigned intermediate value. Each vector provides an index to a gate descriptor in the IDT. The first 32 vectors are reserved by Intel for system use. Some of these vectors are used for internally generated exceptions.</p>
</blockquote>
<p>大意就是INT n用来调用特定的中断或者异常的处理程序。n取值从0x00-0xFF(8位无符号整型)。N就作为上述提到的向量。举一些简单的例子，比如说0x1表示除法上溢或者被零除，0x12表示栈故障(越界或者栈段不存在)，0x14表示缺页…</p>
<p>当调用处理程序时，系统栈保存处理器的状态。下列事件将发生:</p>
<ul>
<li>若转移涉及特权指令改变，则当前栈段寄存器和当前拓展的栈指针(esp)寄存器的内容被压入栈。</li>
<li>EFLAGS寄存器的当前值压入栈。</li>
<li>中断(IF)和自陷(TF)两个标志被清除。这就禁止了INTR中断，自陷或单步中断。</li>
<li>当前代码段(CS)寄存器和当前指令指针寄存器(IP或者EIP)寄存器被压入栈。</li>
<li>若中断向量伴随错误代码，则错误代码也入栈。</li>
<li>读取中断向量表对应项的内容，将其装入CS和IP(或EIP)寄存器。控制转移到终端服务子程序继续执行。</li>
</ul>
<p>为从中断返回，中断服务程序执行一条IRET指令。这使得所有保存在栈上的值被取回，并由中断点恢复执行。</p>
<hr>
<p>铺垫了这么久，又回到了系统调用。没猜错，IA32的Linux上系统调用就是通过INT 0x80调用的。</p>
<p>下面讲一下具体过程：</p>
<p>响应中断0x80，内核调用system_call()。可以再展开说一下，这里通过各个寄存器用于传递参数，EAX寄存器用于表示系统调用的接口号，比如EAX&#x3D;1用于退出进程(exit)；EAX&#x3D;2表示创建进程(fork)；EAX&#x3D;3表示读取文件或者IO(read)等，每个系统调用都对应内核源代码中的一个函数，他们都是以“sys_”开头的，比如说exit调用对应于内核中的sys_exit函数。你没猜错，和IDT一样，系统也维护着一张系统调用表，通过类似*sys_call_table(0,%eax,4)，的跳转，可以通过eax所记录的系统调用号调用对应的系统调用函数。如果系统调用带有函数参数(一般也是通过寄存器传递)，那么还会检查参数的有效性。随后，该函数会执行必要的任务。接着，将状态返回sys_call()函数。从内核栈中恢复各寄存器值，并将系统调用返回结果置于栈中。最后返回外壳函数，中断结束。</p>
<p>至此，系统调用算是结束了，但是我们调用的外壳(wrapper)函数还没算完。它还有个扫尾工作。如果返回值表明调用有错误，外壳(wrapper)函数就会设置全局变量errno。最后，外壳(wrapper)函数会返回到调用它的地方，并返回一个整型，以表明系统调用是否成功。</p>
<p>终于调用结束，大功告成了…</p>
<p>(取好几本书内容的子集东拼西凑写出来的…真是艰难</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2017/11/13/C++/C++_ub_everywhere/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/11/13/C++/C++_ub_everywhere/" class="post-title-link" itemprop="url">C++的ub还真是无处不在啊</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-11-13 12:15:31" itemprop="dateCreated datePublished" datetime="2017-11-13T12:15:31+00:00">2017-11-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>如何交换两个整型变量?最简单的就是引入第三个变量,然后完成三次赋值达到交换的目的。<br>然后，也有一些不使用第三个变量达到这个目的的方法。我所知道的有两个，一个是通过位运算的异或（原理是对于任意位模式<code>ｘ^x = 0</code>,在此不展开），还有一个就是通过以下的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">swap_ingeter</span>(T&amp; x, T&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">	x = x+y;</span><br><span class="line">	y = x-y;</span><br><span class="line">	x = x-y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>肯定有人一眼就看出了这个方法的问题：<code>x+y</code>有可能会溢出。</p>
<p>一般程序猿看到溢出就头疼，感觉肯定潜藏着bug，然而事实真是如此吗？这正是本篇文章的想要探讨的问题：<strong>这种方法最终结果还能保证交换结果正确吗？</strong></p>
<p>大家都知道，在计算机的世界中，一切的整型最后都是用二进制来表示。对于有符号整型和无符号整型来说，有着不同的编码规则。现在几乎所有的机器都是用补码(<strong>two’s complement</strong>)来表示有符号数。</p>
<p>所以，对于一个n位的二进制，当它表示一个无符号整型的时候，第i(i取1<del>n)位的权重就是<code>2^(i-1)</code>。当它表示一个有符号整型的时候，第n位的权重是<code>-2^(n-1)</code>，第i(i取1</del>k-1)位的权重是<code>2^(i-1)</code>。</p>
<p>至于用补码来表示有符号数的一个重要的原因，就是可以在cpu的<code>ALU</code>计算时不用区分有符号和无符号整型，用同一套加法器就能解决。弄不明白为什么也没关系，只要记住结论：<strong>有符号整型和无符号整型在cpu上的运算规律相同，即二进制数逐位相加（如果是减法，如<code>A - B</code>，则转换成<code>A + B的补码</code>），最高位进位舍弃</strong>。</p>
<p>所以，这些运算最后都能看成是两个无符号二进制数的加法。每次结果对<code>2^k</code>取模。最高位进位被舍弃，既截断。</p>
<p>这在数学上有定义，模数加法形成了一个阿贝尔群。阿贝尔群的性质就是<strong>可交换</strong>和<strong>可结合</strong>。看到可交换和可结合，相信大家心里已经有点数了：用上面那个方法交换变量理论上应该是可行的。</p>
<p>我把交换的过程运算详细列出来。</p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
</tr>
</thead>
<tbody><tr>
<td>x+y</td>
<td>y</td>
</tr>
<tr>
<td>x+y</td>
<td>x+y-y</td>
</tr>
<tr>
<td>x+y-x-y+y</td>
<td>x+y-y</td>
</tr>
</tbody></table>
<p>可以看到根据取模加法<strong>可交换可结合</strong>的特点<code>x</code>最后的结果是<code>x+y-x-y+y=y</code>，<code>y</code>最后的结果<code>x+y-y=x</code>。</p>
<p>到这里似乎完事大吉,但是心头隐隐有些不安。而且某次在某个群里讨论这个话题的时候也被dalao喷过：-（  所以感觉这个还和语言的标准有关。后来查了下c++对于有符号数无符号数，以及溢出的资料，果然如此…</p>
<p>对于无符号整型来说：</p>
<p>C++11,§6.9.1</p>
<blockquote>
<p>Unsigned integers, declared unsigned, shall obey the laws of <strong>arithmetic modulo 2^n</strong> where n is the number of bits in the value representation of that particular size of integer</p>
</blockquote>
<p>标准是明确规定<strong>无符号整型运算结果会以<code>2^n</code>取模</strong>，即使溢出了运算结果也是明确数学定义的（mathematically defined）。也就构成了模数加法，可交换可结合。</p>
<p>而对于有符号整型，C++甚至至今(截止到C++17)都没有明确规定过用补码来表示有符号整型，可选的还有<code>one&#39;s complement</code>或者<code>sign-and-magnitude</code>。不过C++11倒是在<code>cstdint</code>头文件里规定了几个用补码表示的类型。</p>
<p>C++11, §21.4.1:</p>
<blockquote>
<p>The header defines all types and macros the same as the C standard library header &lt;stdint.h&gt;.<br>See also: ISO C 7.20.</p>
</blockquote>
<p>好吧，一切按照c的来：</p>
<p>C11, §7.20.1.1:</p>
<blockquote>
<p>The typedef name intN_t designates a signed integer type with width N, no padding bits, and a <strong>two’s complement representation</strong>. Thus, int8_t denotes such a signed integer type with a width of exactly 8 bits.</p>
</blockquote>
<p>可以看到，C++11在<code>cstdint</code>头文件中沿用了C11对于<code>stdint.h</code>的规定，形如<code>intN_t</code>的类型用补码表示。那么对于<code>intN_t</code>类型来说，用文章开头所说的方法能保证一定交换成功吗？</p>
<p>很遗憾，答案仍然是否。因为标准没有明确规定像无符号整型那样，溢出之后对结果取模。也就是说，有符号类型溢出仍然是<code>undefined behavior</code>。所以方法交换的结果也是未定义。</p>
<p>最后的结论：在C++中，无符号整型用上述方法可以交换变量，而有符号整型交换后结果未定义。</p>
<p>ps：不过现在大部分PC机都是x86体系结构的，有符号整型这么交换也是可以的…毕竟cpu运算结果就是那样 orz</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2017/11/04/C++/NULL_VS_nullptr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/11/04/C++/NULL_VS_nullptr/" class="post-title-link" itemprop="url">nullptr vs NULL</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-11-04 00:11:31" itemprop="dateCreated datePublished" datetime="2017-11-04T00:11:31+00:00">2017-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>大家都知道,在C语言中,NULL被用来表示空指针常量(null pointer constant),用来与任何指向真实对象的指针区分.</p>
<p>c99标准里这么描述:</p>
<blockquote>
<p>3 An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant.55) If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function.</p>
</blockquote>
<p>而且NULL属于implementation defined,所以编译器一般都把NULL宏定义为常量0(或者0L)或者 (void*)0…</p>
<p>因为c语言允许void* 指针向其他指针类型隐式转化(比如说很常用的malloc函数的返回值就是void* ),所以可以通过NULL给任意类型的指针赋null pointer constant.</p>
<p>但是在c++中就有不同了.c++不支持void* 隐式转化为其他指针类型,NULL宏定义成(void*)0就没什么意义. 于是,c++中NULL一般宏定义为0. </p>
<p>但是这么以来,问题就出现了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;arg: pointer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;arg: int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *p  = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">f</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译出错:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test.cpp:<span class="number">14</span>:<span class="number">8</span>: error: call of overloaded ‘<span class="built_in">f</span>(<span class="literal">NULL</span>)’ <span class="function">is ambiguous</span></span><br><span class="line"><span class="function">  <span class="title">f</span><span class="params">(<span class="literal">NULL</span>)</span></span>;</span><br><span class="line">        ^</span><br><span class="line">test.cpp:<span class="number">2</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>*)</span></span></span><br><span class="line"><span class="function"> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> *)</span></span></span><br><span class="line"><span class="function">      ^</span></span><br><span class="line"><span class="function">test.cpp:<span class="number">7</span>:<span class="number">6</span>: note: candidate: void f(int)</span></span><br><span class="line"><span class="function"> void f(int )</span></span><br><span class="line"><span class="function">      ^</span></span><br></pre></td></tr></table></figure>
<p>因为函数调用的时候两个重载版本都会匹配.</p>
<p>还有就是模板推断参数类型的时候,也会由于NULL而把指针类型推断成int(当然,如果宏定义是0L就推断成long long),造成编译错误.</p>
<p>当然,随着c++11版本的出现,引入了一个新的关键字nullptr,c++终于有了正式的null pointer constant.</p>
<blockquote>
<p>The keyword nullptr denotes the pointer literal. It is a prvalue of type std::nullptr_t. There exist implicit conversions from nullptr to null pointer value of any pointer type and any pointer to member type. Similar conversions exist for any null pointer constant, which includes values of type std::nullptr_t as well as the macro NULL. </p>
</blockquote>
<p>大概意思就是nullptr类型是std::nullptr_t(大概可以理解成true和false之于bool类型的关系),是个纯右值(prvalue).nullptr可以隐式转化成任意指针类型的空指针值(null pointer value).</p>
<p>再来看一个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span> A&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fwd</span><span class="params">(F f, A a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span>* i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Function g called\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(<span class="literal">NULL</span>);           <span class="comment">// Fine</span></span><br><span class="line">    <span class="built_in">g</span>(<span class="number">0</span>);              <span class="comment">// Fine</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Fwd</span>(g, <span class="literal">nullptr</span>);   <span class="comment">// Fine</span></span><br><span class="line">    <span class="built_in">Fwd</span>(g, <span class="literal">NULL</span>);      <span class="comment">// ERROR: No function g(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了nullptr就解决了NULL模板推断的一些问题.</p>
<p>所以给指针赋值尽量用nullptr…</p>
<p>ps: 还要就是std::nullptr_t类型的定义比较奇怪&#x3D; &#x3D;.  这样真的大丈夫?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="type">nullptr_t</span></span>;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2017/10/30/C++/C++_switch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/10/30/C++/C++_switch/" class="post-title-link" itemprop="url">C++ switch内部的变量定义</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-10-30 12:15:31" itemprop="dateCreated datePublished" datetime="2017-10-30T12:15:31+00:00">2017-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>c++中的switch语句大家肯定都很熟悉。switch执行流程是匹配相应的case。很显然，可能会跳过某些case标签，忽略某些代码。那么就带来了一个有意思的话题：<strong>如果被忽略的代码中有变量的定义该怎么办</strong>？</p>
<p>先来看一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后编译就错了：</p>
<ul>
<li><code>error: jump to case label [-fpermissive]</code></li>
<li><code>error: crosses initialization of ‘int a’</code></li>
</ul>
<p>编译器的意思是控制流跳过了变量的初始化。乍看之下似乎不太好理解为什么出错。其实如果在case 0标签中要使用的变量a的时候，问题就来了。试图在未初始化的时候使用对象，这显然是行不通的。可能由于举的例子中变量是内置类型，所以不太好理解到问题的严重性，再来看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	std::string s1;</span><br><span class="line">	<span class="function">std::string <span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	<span class="comment">//可能会使用s1或者s2</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就跳过了类的隐式或者显式初始化。</p>
<p>因此c++规定，不允许跨过变量的初始化语句直接跳转到变量作用域的另一个位置。</p>
<p>然而，对于内置类型来说，定义的时候并非一定要初始化。<br>比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	a = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码就不会报错，因为变量并没有初始化。可以从底层来理解。</p>
<p>首先，switch下的大括号是一个完整的作用域，不要被case标签的缩进所欺骗，认为每个case有一个作用域（除非显示地加大括号）。</p>
<p>其次，定义变量并不存在“执行动作”，有的只是改变栈指针从而在栈上分配空间。编译器会保证在相应的作用域之中这个变量的空间是被分配了。大部分编译器实现会选择在函数开始把所有局部变量的空间都分配好。但是变量的初始化是有”执行动作“的，比如说<code>int a = 10</code>，就会在栈上某4个字节存入10（假设机器上int占4字节）。再比如某个类初始化，也会调用相应的构造函数。所以控制流程的跳转可能造成某个对象没有正常的初始化就使用。</p>
<p>所以，就可以回答一开始的问题了。如果被忽略的代码中的定义包含了初始化的过程，就会编译失败。如果是内置类型的定义（不含初始化），那么就能通过编译。</p>
<p>当然，为了不出现上述的问题，可以直接用大括号将case标签下构成一个单独的作用域。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		std::string s;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	<span class="comment">//显然，这里也不可能再使用对象s或者a</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2017/07/13/C++/C++_reference_implemention/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/07/13/C++/C++_reference_implemention/" class="post-title-link" itemprop="url">c++引用的实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-07-13 12:15:31" itemprop="dateCreated datePublished" datetime="2017-07-13T12:15:31+00:00">2017-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>很多c++初学者对于引用（reference）的的印象不外乎就是“对象的别名”、“同义词”。而引用作为c++对于c语言的重要扩充，与指针有着千丝万缕、剪不断理还乱的联系。甚至，引用在底层<del>就是</del>(勘误，应该改成“<strong>可能</strong>”)通过“指针”实现。</p>
<p><strong>左值引用</strong></p>
<p>接下来，看一个很简单的小例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">	<span class="type">int</span> &amp;b = a;</span><br><span class="line">	b = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编后的代码节选：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_Z4testv:</span><br><span class="line">.LFB0:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.seh_pushreg	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.seh_setframe	%rbp, 0</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	.seh_stackalloc	16</span><br><span class="line">	.seh_endprologue           #以上几行是test函数栈帧的建立过程</span><br><span class="line">	movl	$6, -12(%rbp)      #保存a</span><br><span class="line">	leaq	-12(%rbp), %rax    #将a的地址存入rax寄存器</span><br><span class="line">	movq	%rax, -8(%rbp)     #保存b，存入的是a的地址</span><br><span class="line">	movq	-8(%rbp), %rax     #将b，即a的地址传入rax寄存器</span><br><span class="line">	movl	$7, (%rax)         #通过b中保存的地址对a赋值</span><br><span class="line">	addq	$16, %rsp          #从以下几行是test函数栈帧的销毁过程</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br><span class="line">	.seh_endproc</span><br></pre></td></tr></table></figure>

<p>可以看到，内存上b存储的其实是a的地址。</p>
<p><del>在底层，引用是通过指针来实现</del>。引用算的上是c++的一个语法糖。</p>
<p><strong>右值引用</strong></p>
<p><del>以上的讲解都是基于c++传统的、用&amp;表示的引用，也就是左值引用。而c++11标准还有个右值引用的概念。那右值引用也还是用指针的实现的吗？要知道，右值引用可是对于临时变量的引用，万一是存储在寄存器中的临时变量呢？要知道，寄存器内的数据可不能寻址…作为一个c++菜鸟，我对右值引用也没有很深的理解…想到这，我不禁冒冷汗，难道我的猜测错了？上面的都得重写？</del></p>
<p>吓得我赶紧试验一下…</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">	<span class="type">int</span> &amp;&amp;b = a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编之后的节选：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_Z4testv:</span><br><span class="line">.LFB0:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.seh_pushreg	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.seh_setframe	%rbp, 0</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	.seh_stackalloc	32</span><br><span class="line">	.seh_endprologue           #以上是栈帧的建立过程</span><br><span class="line">	movl	$6, -4(%rbp)       #保存a</span><br><span class="line">	movl	-4(%rbp), %eax     #将a存入寄存器eax</span><br><span class="line">	addl	$1, %eax           #eax中数据+1，得到a+1</span><br><span class="line">	movl	%eax, -20(%rbp)    #保存a+1</span><br><span class="line">	leaq	-20(%rbp), %rax    #将保存的a+1的地址传入寄存器eax</span><br><span class="line">	movq	%rax, -16(%rbp)    #保存a+1的地址</span><br><span class="line">	addq	$32, %rsp          #从这以下是这个栈帧的销毁过程</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br><span class="line">	.seh_endproc</span><br></pre></td></tr></table></figure>

<p>可以看到，程序会先将a+1计算结果保存进栈帧，然后把a+1被保存的地址传给b。b保存的还是一个地址。</p>
<p>当然…我由于c++水品有限，可能这只是我错误的猜想和认识。欢迎指正我的错误所在。 </p>
<hr>
<p>2018.1.29</p>
<p>update：</p>
<p>c++标准本身没有规定引用的实现方法。因此引用可能利用指针实现，也可以被优化调(即直接操作被引用的对象)。</p>
<p>实际上不应该对引用的实现做任何假设。搞清楚它语义上是作为对象的别名就够了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2017/07/13/C++/name_mangling/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/07/13/C++/name_mangling/" class="post-title-link" itemprop="url">浅谈name mangling</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-07-13 12:11:31" itemprop="dateCreated datePublished" datetime="2017-07-13T12:11:31+00:00">2017-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>很多语言都允许重载函数，这些函数在源代码中有相同的名字，却又不同的参数列表。这用到了一种叫做name mangling的技术。</p>
<blockquote>
<p><strong>名字修饰</strong>，又译作<strong>名字粉碎</strong>、<strong>名字重整</strong>，译自英文<strong>name mangling</strong>或<strong>name decoration</strong>，是现代计算机程序设计语言的编译器用于解决由于程序实体的名字必须唯一而导致的问题的一种技术。</p>
<p>它提供了在函数、结构体、类或其它的数据类型的名字中编码附加信息一种方法，用于从编译器中向链接器传递更多语义信息。</p>
<p>该需求产生于程序设计语言允许不同的条目使用相同的标识符，包括它们占据不同的命名空间（典型的命名空间是由一个模块、一个类或显式的<em>namespace</em>指示来定义的）或者有不同的签名（例如函数重载）。</p>
</blockquote>
<p>接下来主要以c++的<strong>函数重载</strong>为例，来简要介绍一下name mangling。（当然，其他语言中也有name mangling，而且也c++还有很多其他地方需要name mangling，比如namespace，class，template等）。</p>
<h2 id="name-mangling出现的原因"><a href="#name-mangling出现的原因" class="headerlink" title="name mangling出现的原因"></a>name mangling出现的原因</h2><p>c++源文件经过编译器和汇编器生成可重定位目标文件。链接器生成可执行目标文件。</p>
<p>不同的系统之间，目标文件的格式都不同，但基本的概念都是相同的。</p>
<p>每个可重定位目标模块中包含一个叫做符号表（.symtab）的部分。符号表包含了m所定义和引用的符号。一般分为三种：</p>
<ul>
<li>在m中定义并且能被其他模块引用的<strong>全局符号</strong>。对应于非静态的函数以及不带static的全局变量。</li>
<li>在其他模块中定义并且被模块m引用的<strong>全局符号</strong>。这些符号也被称为外部（external）符号，对应于定义在其他模块的函数和变量。</li>
<li>只被模块m定义和引用的<strong>本地符号</strong>。对应于带static的函数和全局变量。</li>
</ul>
<p>要注意到，符号表中不包含对应于本地非静态程序变量的任何符号。因为这些符号在运行时栈中管理，链接器不care。</p>
<p>（可能有人对上面几段中<strong>模块</strong>一词比较疑惑。一个目标模块（object module）就是一个字节序列，而一个目标文件（object file）就是存储在存储器中的目标模块。）</p>
<p>而链接器做的主要工作，就是进行<strong>符号解析</strong>和重定位。而链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的<strong>一个确定的符号定义</strong>联系起来。</p>
<p>从这里已经可以看出一些倪端了。c++要实现重载，必须让链接器能够区分这些重载函数。而不能像c语言中一样简单的将函数名作为符号。这就必须要用到name mangling。</p>
<p>ps：关于编译链接的过程我也不是很懂，这方面还需要后续的学习。</p>
<h2 id="name-mangling的基本方式"><a href="#name-mangling的基本方式" class="headerlink" title="name mangling的基本方式"></a>name mangling的基本方式</h2><p>name mangling的基本原理就是将每个唯一的函数和参数列表组合编码成一个对链接器来说唯一的名字。换句话说，编译器和链接器需要一定的协议来规范符号的组织格式。</p>
<p>c++中的重载函数区分在于参数数量和某个参数类型的不同。所以区分函数的时候，需要充分考虑参数数量和参数类型这两个语义信息。</p>
<p>然而，c++并没有规定一个标准的name mangling方式，所以不同的编译器采用的各自的name mangling方式（甚至相同编译器的不同版本，或相同编译器在不同平台上，name mangling规则都截然不同）。所以几乎没有链接器可以链接不同编译器产生的目标代码。</p>
<p>以下就以gcc为例子来初步了解一下。</p>
<p>一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="built_in">f</span>(), j = <span class="built_in">f</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译得到可重定位目标文件，然后用gcc工具链中的<a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/binutils/nm.html">nm</a>列出目标文件的符号，可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 b .bss</span><br><span class="line">0000000000000000 d .data</span><br><span class="line">0000000000000000 p .pdata</span><br><span class="line">0000000000000000 r .rdata$zzz</span><br><span class="line">0000000000000000 t .text</span><br><span class="line">0000000000000000 r .xdata</span><br><span class="line">000000000000000b T _Z1fi</span><br><span class="line">0000000000000000 T _Z1fv</span><br><span class="line">0000000000000019 T _Z1gv</span><br></pre></td></tr></table></figure>

<p>这三列分别是 symbol value，symbol type， symbol name。 现在主要关注的就是最后一列的符号名(主要是因为前两个我也不知道是个啥&#x3D; &#x3D;。以后再填坑吧)。</p>
<p>可以看到<code>int f(void)</code> 在符号表中是<code>_Z1fv</code>，<code>int f(int)</code>是<code>_Z1fi</code>，<code>void g(void)</code>是<code>_Z1gv</code>。</p>
<p>大家也可以从这个简单的例子窥见gcc中name mangling的方式。不过本文只是简单的介绍一下name mangling出现的理由和通用策略，并非意在介绍具体某种编译器的name mangling编码规则，所以不会在这块深入。（啊，其实是因为我也不懂）。</p>
<p>最后再做一个实验，看一下涉及到namespace和class的name mangling。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> t &#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">c</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	t::c objc;</span><br><span class="line">	objc.<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nm列出符号表(忽略其他符号)，看一下这几个函数的符号名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000000000000000f T _Z1fv</span><br><span class="line">0000000000000000 T _ZN1t1c1fEv</span><br><span class="line">0000000000000006 T _ZN1t1fEi</span><br><span class="line">0000000000000000 T _ZN1t1fEv</span><br></pre></td></tr></table></figure>

<p>ps：最后的最后，感觉自己还是有很多地方也不是很明白…还得接着学 啊  &#x3D; &#x3D;</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2017/07/10/C++/stack_frame/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/07/10/C++/stack_frame/" class="post-title-link" itemprop="url">浅谈栈帧</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-07-10 12:11:31" itemprop="dateCreated datePublished" datetime="2017-07-10T12:11:31+00:00">2017-07-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/x86/" itemprop="url" rel="index"><span itemprop="name">x86</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>本文内容是结合《深入理解计算机系统》第三章以及自己对于栈帧、C语言函数调用实现机制的浅薄理解。如有错误，欢迎指正。</strong> （逃~</p>
<h2 id="什么是栈帧"><a href="#什么是栈帧" class="headerlink" title="什么是栈帧"></a>什么是栈帧</h2><blockquote>
<p>C语言中，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的返回地址和局部变量。</p>
</blockquote>
<p>大多数机器用程序栈来支持过程调用。机器用栈来传递过程参数，存储返回信息，保存寄存器用于以后恢复，以及本地存储。为单个过程分配的那部分栈成为栈帧（stack frame）。</p>
<p><img src="http://www.myhack58.com/Article/UploadPic/2016-7/201674201749615.jpg" alt="stack frame"></p>
<p>此图描绘了栈帧的通用结构。最顶端的栈帧用两个指针界定。在IA32机器上寄存器%ebp为帧指针，寄存器%esp为栈顶指针。在64位机器上则分别用%rbp和%rsp寄存器。<strong>以下提到的汇编代码如不特别说明一般指的是在32位机器上的汇编结果。</strong></p>
<p>假设过程P（调用者）调用Q（被调用者）时，P会在自己栈帧存储Q的参数，另外会将P的返回地址也压入栈中。返回地址就是程序从Q返回时应该继续执行的地方。当调用返回时，这个返回地址会被pop进%eip（指令指针寄存器，同理，在64位上%rip）。</p>
<h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><p>控制转移指令主要有call和leave和ret。</p>
<ul>
<li><p>call</p>
<p>call指令有一个目标，即指令被调用过程起始指令的地址。</p>
<p>call指令的效果是将返回地址入栈。返回地址也就是当前指令指针寄存器（%eip）中指向的指令的下一个指令的地址。然后指令指针寄存器会存储call的目标，即相当于实现了控制的转移。</p>
<p>call之后会进入另一个函数。此时会建立新的栈帧。建立过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pushl   %ebp</span><br><span class="line">movl    %esp, %ebp</span><br><span class="line">subl    $24, %esp</span><br></pre></td></tr></table></figure>

<p>首先，保存调用者的%ebp，然后赋予%ebp栈顶的地址，最后，为当前栈帧分配空间（这里举得例子是分配24字节，视实际情况而定），由于栈增长方向为较小地址，所以减去某个值即可分配完成。BTW，GCC分配的空间一般是16字节的整数倍。</p>
</li>
<li><p>leave</p>
<p>leave指令可以使栈做好返回的准备。等价于下面的代码序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl	%ebp, %esp</span><br><span class="line">pop     %ebp</span><br></pre></td></tr></table></figure>

<p>将栈顶指针与帧指针同步，然后把当前帧顶，即调用者的帧的最底位置（上一个栈帧的帧底地址）pop给%ebp，实现了调用者帧指针的恢复。</p>
</li>
<li><p>ret</p>
<p>ret的作用就是将call指令时保存的下一个指令的地址，即当前栈顶的数据pop给%eip。此时，调用者%esp也恢复成了调用前的状态。并且指令指针寄存器中的数据也已经变成call指令之后的一条指令的地址。此时，调用完美结束。</p>
</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>以下汇编代码来自64位机器上 gcc编译产生。</strong></p>
<p>这是一个极其简单的c函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Q</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Q(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是编译结果的节选：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Q:</span><br><span class="line">	pushq   %rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br><span class="line">P:</span><br><span class="line">	pushq   %rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	call	Q</span><br></pre></td></tr></table></figure>

<p>可以看出符合上面的讲解。P首先建立栈帧，然后调用Q，Q保存P的%rbp，建立自己的栈帧，最后返回P的控制。</p>
<h2 id="小小进阶"><a href="#小小进阶" class="headerlink" title="小小进阶"></a>小小进阶</h2><p>上面举的实例，以及之前的讲解中都是用的P调用Q的情况。其实P、Q是同一函数也可以啊。蛤蛤，这就拓展到了函数递归了。每次函数调用自身的时候也都是一样的原理。都是先call自身，保存下一条指令地址，接着创建新的栈帧。到达终止条件后，这些栈帧就一个个ret上一个栈帧…毅种循环。蛤蛤，知道为什么没有终止条件的递归容易栈溢出了吧。</p>
<p>以下是一个大家很熟悉的阶乘的递归例子（<strong>64位机器 gcc编译</strong>）</p>
<p>这是c代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> n*fact(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是汇编节选：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fact:</span><br><span class="line">	pushq   %rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	movl	%ecx, 16(%rbp)</span><br><span class="line">	cmpl	$1, 16(%rbp)</span><br><span class="line">	jg	.L2</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	jmp	.L3</span><br><span class="line">.L2:</span><br><span class="line">	movl	16(%rbp), %eax</span><br><span class="line">	subl	$1, %eax</span><br><span class="line">	movl	%eax, %ecx</span><br><span class="line">	call	fact</span><br><span class="line">	imull   16(%rbp), %eax</span><br><span class="line">.L3:</span><br><span class="line">	addq	$32, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>我们可以看到递归调用一个函数本身的结果和调用其它函数是一样的。这种调用机制也适用于更加复杂的情况，比如相互递归调用（P调用Q，Q再调用P）。</p>
<hr>
<p>更新（2017.7.18）：</p>
<p>以上谈的主要是基于X86-32架构的栈帧，而随着X86-64的出现，过程调用有着很大的不同，同时栈帧也不可避免的有一些变化。</p>
<p><strong>x86-64上的栈帧布局特点:</strong></p>
<ul>
<li>参数（最多六个）通过寄存器传递到过程，而不用保存在栈上。</li>
<li>很多函数不需要栈帧。只有那些不能将所有局部变量都放在寄存器中的函数才需要在栈上分配空间。</li>
<li>过程的存储空间拓展到了地址低于当前栈指针的存储空间（最多低128byte）。这就可以避免push带来的开销，而且保持栈指针不变。即可以直接通过栈指针定位到存储的数据。</li>
<li>从上面的描述也可以看出来，帧指针已经没有必要存在了。即<strong>不存在帧指针</strong>。大多数函数在调用开始时分配所需要的整个栈存储，并保持栈指针指向固定的位置。</li>
</ul>
<p>每个栈帧的部分就是在栈指针到保存的返回地址之间。X86-64对栈帧使用的减少，并充分发挥寄存器。而且不用帧指针，多了一个可用的寄存器，栈指针兼职了之前帧指针的作用。</p>
<p>至于其他不同架构上的变化，我就不是很了解了。</p>
<p>ps：GCC编译的时候提供了一个选项“-fomit-frame-pointer”，用来显式的不使用帧指针。以下是文档说明</p>
<blockquote>
<p>Don’t keep the frame pointer in a register for functions that don’t need one. This avoids the instructions to save, set up and restore frame pointers; it also makes an extra register available in many functions. It also makes debugging impossible on some machines.</p>
<p>On some machines, such as the VAX, this flag has no effect, because the standard calling sequence automatically handles the frame pointer and nothing is saved by pretending it doesn’t exist. The machine-description macro “FRAME_POINTER_REQUIRED” controls whether a target machine supports this flag.</p>
</blockquote>
<p>亲测gcc在开启优化的情况下也会省去帧指针。不过缺省情况(不开启优化并且不加“-fomit-frame-pointer”选项)将使用帧指针，建立栈帧的过程与本篇前半段的讲解几乎相同。</p>
<hr>
<p>2018.1.29</p>
<p>update:</p>
<p>上面主要是根据csapp的内容总结的，实际上函数调用时传递参数和获取返回值的方法，以及对与栈帧的具体用法，还和**调用惯例(calling convention)**。这是ABI的范畴。所以可见c&#x2F;c++编译的程序要想做到二进制兼容十分困难。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yiyang Chen</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/cyyzero" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"cyyzero","repo":"cyyzero.github.io","client_id":"1185801249b8bbce5127","client_secret":"fbbb24c3e0613419f2505f94baa921f61606bac1","admin_user":"cyyzero","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"9d8d3da09189165dcde8f1d3e109ad78"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
