<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"cyyzero.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Eden">
<meta property="og:url" content="http://cyyzero.github.io/page/2/index.html">
<meta property="og:site_name" content="Eden">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yiyang Chen">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://cyyzero.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Eden</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Eden" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Eden</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yiyang Chen"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Yiyang Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cyyzero" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cyyzero" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cyyzero@qq.com" title="E-Mail → mailto:cyyzero@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/9748477/cyyzero" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;9748477&#x2F;cyyzero" rel="noopener me" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2018/08/02/Linux/LKD_scheduler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/02/Linux/LKD_scheduler/" class="post-title-link" itemprop="url">《Linux内核设计与实现》读书笔记——进程调度</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-08-02 13:15:31" itemprop="dateCreated datePublished" datetime="2018-08-02T13:15:31+00:00">2018-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>进程调度程序是确保进程能有效工作的一个内核子系统。</p>
<h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p>多任务可以分为两类：</p>
<ul>
<li>非抢占式多任务(cooperative multitasking)。除非进程自己主动停止运行，否则它会一直执行。进程主动让出自己的操作称为让步(yielding)。</li>
<li>抢占式多任务(preemtive multitasking)。Linux提供了抢占式的多任务模式。由进程调度程序来决定什么时候停止一个进程的运行。这个强制的挂起动作就叫做抢占(preemption)。进程在被抢占之前能够运行的时间叫做时间片(timeslice)。</li>
</ul>
<h2 id="Linux的进程调度"><a href="#Linux的进程调度" class="headerlink" title="Linux的进程调度"></a>Linux的进程调度</h2><p>从1991年的Linux第一版到后来的2.4内核系列，Linux的调度程序都相当简陋，设计近乎原始。在Linux2.5开发系列的内核中，采用了一种叫做<code>O(1)</code>调度程序的新调度程序。就如它的名字，时间复杂度是<code>O(1)</code>。</p>
<p><code>O(1)</code>调度器在拥有数以十计的多处理器环境下尚能表现出近乎完美的性能和可拓展性，但是对于响应时间敏感的交互进程来说却有一些先天不足。从2.6内核系统开发初期，开发人员引入了新的调度算法。其中最有名的是<em>反转楼梯最后期限调度算法(<code>Rotating Staircase Deadline scheduler</code>)</em>(<code>RSDL</code>)。该算法吸取了队列理论，将公平调度的概念引入了Linux调度程序，并最终在2.6.23内核版本中替代了<code>O(1)</code>调度算法。它被称为完全公平调度算法(CFS)。</p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>策略决定调度程序在何时让什么进程运行。</p>
<h3 id="I-O消耗型和处理器消耗型的进程"><a href="#I-O消耗型和处理器消耗型的进程" class="headerlink" title="I&#x2F;O消耗型和处理器消耗型的进程"></a>I&#x2F;O消耗型和处理器消耗型的进程</h3><p>进程可被分为I&#x2F;O消耗型和处理器消耗型。前者指进程的大部分时间都用来提交或等待I&#x2F;O请求。相反，处理器消耗型则大部分时间都用在执行代码上。当然两者的划分并非泾渭分明。</p>
<p>调度策略通常就要在两个矛盾的目标中寻找平衡：进程相应迅速和最大系统利用率。</p>
<h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>Linux采用了两种不同的优先级范围。</p>
<p>第一种是使用nice值，范围是-20～+19，默认为0。越大的nice值意味着优先级越低。nice值代表时间片的比例。可以通过<code>ps -el</code>查看，<code>NI</code>列表示的就是nice值。</p>
<p>第二种范围是实时优先级，其范围是可配置的。默认情况下它的变化范围是[0, 99]。与nice值相反，越高的实时优先级代表进程优先级更高。任何实时进程的优先级都高于普通进程，也就是说nice优先级和实时优先级处于互不相交的两个范畴。</p>
<h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><p>时间片是一个数值，表明进程在被抢占前能持续运行的时间。调度策略需要规定默认的一个时间片。但时间片过长会导致系统对交互的效应表现欠佳，过段会明显增加进程切换带来的处理器耗时。而且I&#x2F;O消耗型和处理器消耗型的矛盾也显示出来：I&#x2F;O消耗型不需要过长时间片，而处理器消耗型则希望越长越好。</p>
<p>Linux的CFS调度并没有直接分配时间片到进程，而是讲处理器的使用比例划分给了进程。这样一来，进程所获得的处理器时间其实是和系统负载有关。抢占时机也取决于新的可运行程序消耗了多少处理器使用比。</p>
<h2 id="Linux调度算法"><a href="#Linux调度算法" class="headerlink" title="Linux调度算法"></a>Linux调度算法</h2><h3 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h3><p>Linux调度器是以模块方式提供的，称为调度器类(<code>scheduler classes</code>)，不同类型的进程可以有针对性地选择调度算法。基础的调度器类代码定义在<code>kernel/sched.c</code>文件中，它会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类胜出。</p>
<p>CFS是一个针对简单进程的调度类，在Linux中称为<code>SCHED_NORMAL</code>。</p>
<h3 id="Unix系统中的进程调度"><a href="#Unix系统中的进程调度" class="headerlink" title="Unix系统中的进程调度"></a>Unix系统中的进程调度</h3><p>在Unix系统上，优先级以nice值形式输出给用户空间。在现实中会产生许多问题。</p>
<ul>
<li><p>若要讲nice值映射到时间片，就必然需要将nice单位值对应到处理器的绝对时间。但这样做会导致进程切换无法最优化执行。举例说明，默认nice值为0分配100ms的时间片，最高nice值为20分配5ms。如果同时运行时间片5ms的进程，则要在10ms间进行一次上下文切换；而运行时间片是100ms的进程，则要在100ms间进行一次上下文切换。</p>
</li>
<li><p>相对nice值。假设两个进程nice值分别是0和1，时间片分别是100ms和95ms，区别微乎其微。而两个进程nice值分别为18和19，时间片分别为10ms和5ms，前者是后者的两倍！</p>
</li>
<li><p>如果执行nice值到时间片的映射，需要能分配一个绝对时间片，而这个绝对时间片必须能在内核的测试范围内。</p>
</li>
<li><p>最后一个问题是关于基于优先级的调度器会为了优化交互任务而唤醒相关进程的问题。</p>
</li>
</ul>
<h3 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h3><p>CFS的做法是允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程，而不再采用分配给每个进程时间片的做法了。CFS在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠nice值来计算时间片。nice值在CFS中被作为进程获得处理器运行比的权重。</p>
<p>每个进程都按照其权重在其全部可运行进程中所占比例的时间片来运行。CFS为完美多任务中的无限小调度周期的近似值设立了一个目标。这个目标称为目标延迟。假定目标延迟值是20ms，两个同样优先级的可运行任务会分别运行10ms。</p>
<p>CFS还为每个进程设置了时间片底线，这个底线称为最小粒度。默认情况下是1ms。</p>
<p>任何进程所获得的处理器时间是由它自己和其他所有可运行进程nice值对应的绝对时差值决定的。nice值对时间片的作用是几何加权。</p>
<h2 id="Linux调度的实现"><a href="#Linux调度的实现" class="headerlink" title="Linux调度的实现"></a>Linux调度的实现</h2><p>CFS位于<code>kernel/sched_fair.c</code>中。特别关注四个组成部分：</p>
<ul>
<li>时间记账</li>
<li>进程选择</li>
<li>调度器入口</li>
<li>睡眠和唤醒</li>
</ul>
<h3 id="时间记账"><a href="#时间记账" class="headerlink" title="时间记账"></a>时间记账</h3><p>所有调度器都必须对进程运行时间做记账。</p>
<h4 id="调度器实体结构"><a href="#调度器实体结构" class="headerlink" title="调度器实体结构"></a>调度器实体结构</h4><p>CFS不再有时间片的概念，但是它也必须维护每个进程运行的时间记账。CFS使用<code>sched_entity</code>来跟踪进程运行记账：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span> <span class="comment">/* for load-balancing */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">run_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">group_node</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> on_rq;</span><br><span class="line"></span><br><span class="line">    u64 exec_start;</span><br><span class="line">    u64 sum_exec_runtime;</span><br><span class="line">    u64 vruntime;</span><br><span class="line">    u64 prev_sum_exec_runtime;</span><br><span class="line"></span><br><span class="line">    u64 nr_migrations;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SCHEDSTATS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_statistics</span> <span class="title">statistics</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="comment">/* rq on which this entity is (to be) queued: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span></span><br><span class="line">    <span class="comment">/* rq &quot;owned&quot; by this entity/group: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">my_q</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sched_entity</code>作为PCB中一个名为<code>se</code>的成员变量。</p>
<h4 id="虚拟实时"><a href="#虚拟实时" class="headerlink" title="虚拟实时"></a>虚拟实时</h4><p><code>vruntime</code>变量存放进程的虚拟运行时间，该运行时间的计算是经过了所有可运行进程总数的标准化。虚拟时间是以ns为单位的。CFS用<code>vruntime</code>变量来记录一个程序到底运行了多长时间以及它还应该再运行多久。</p>
<h3 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a>进程选择</h3><p>CFS调度算法的核心：当CFS需要选择下一个运行进程时，它会挑一个具有最小<code>vruntime</code>的进程。接下来就讨论如何选择具有最小<code>vruntime</code>值的进程。</p>
<p>CFS使用红黑树来组织可运行进程队列，并利用其迅速找到最小<code>vruntime</code>值的进程。</p>
<h4 id="挑选下一个任务"><a href="#挑选下一个任务" class="headerlink" title="挑选下一个任务"></a>挑选下一个任务</h4><p>先假设，红黑树存储了系统中所有的可运行进程，其中节点的键值是可运行进程的虚拟运行时间。那么树中最左侧的叶子节点，就是所有<code>vruntime</code>最小的那个。</p>
<h4 id="向树中加入进程"><a href="#向树中加入进程" class="headerlink" title="向树中加入进程"></a>向树中加入进程</h4><p>CFS在进程变为可运行状态(被唤醒)或者通过<code>fork()</code>调用第一次创建进程时，将进程加入<em>rbtree</em>中，并且缓存最右子节点。</p>
<h4 id="从树中删除进程"><a href="#从树中删除进程" class="headerlink" title="从树中删除进程"></a>从树中删除进程</h4><p>CFS从红黑树中删除进程，删除动作发生在进程堵塞(变为不可运行态)或者终止时(结束运行)。</p>
<h3 id="调度器入口"><a href="#调度器入口" class="headerlink" title="调度器入口"></a>调度器入口</h3><p>进程调度的主要入口点是函数<code>schedule()</code>。它选择哪个进程可以运行，何时将其投入运行。<code>schedule()</code>会找到一个最高优先级的调度类——后者需要有自己的可运行队列，然后问后者谁才是下一个该运行的进程。</p>
<h3 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h3><p>休眠(被阻塞)的进程处于一个特殊的不可执行状态。当进程休眠时，内核的操作如下：进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用<code>schedule()</code>选择和执行一个其他进程。唤醒的过程正好相反：进程被设置成可执行状态，然后从可执行队列中移到可执行红黑树中。</p>
<h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>休眠通过等待队列进行处理。等待队列是由等待某些事件发生的进程组成的简单链表。内核通过<code>wake_queue_head_t</code>来代表等待队列。</p>
<p>在内核中进行休眠的推荐操作相对复杂：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// q是我们希望休眠的等待队列</span></span><br><span class="line">DEFINE_WAIT(wait);</span><br><span class="line"></span><br><span class="line">add_wait_queue(q, &amp;wait);</span><br><span class="line"><span class="keyword">while</span> (!condition)</span><br><span class="line">&#123;</span><br><span class="line">    prepare_to_wait(&amp;q, &amp;wait, TASK_INTERRUPTIBLE)；</span><br><span class="line">    <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">        <span class="comment">/* 处理信号 */</span></span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br><span class="line">finish_wait(&amp;q, &amp;wait);</span><br></pre></td></tr></table></figure>

<h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><p>唤醒操作通过函数<code>wake_up()</code>进行。它会唤醒执行的等待队列上的所有进程。</p>
<h2 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h2><p>这里的上下文切换是指进程间的切换，由定义在<code>kernel/sched.c</code>中的<code>context_switch()</code>函数负责处理。每当一个新的进程被选出来投入运行的时候，<code>schedule()</code>会调用该函数。它完成两个基本的工作：</p>
<p>-调用声明在<code>asm/mmu_context.h</code>中的<code>switch_mm()</code>，负责把虚拟内存从上一个进程映射切换到新进程中。</p>
<ul>
<li>调用声明<code>asm/system.h</code>中的<code>switch_to()</code>，负责从上一个进程的处理器状态切换到新进程的处理器状态。</li>
</ul>
<p>内核提供了一个<code>need_resched</code>标志来表明是否需要重新执行一次调度。当某个进程应该被抢占时，<code>scheduler_tick()</code>就会设置这个标志；当一个优先级高的进程进入可执行状态的时候，<code>try_to_wake_up()</code>也会设置这个标志，内核检查该标志，确认其被设置，调用<code>schedule()</code>来切换到一个新的进程。</p>
<p>在2.2以前的内核版本中，该标志位曾是一个全局变量，2.2~2.4版的内核中它在<code>task_struct</code>中。而在2.6版中，它被移到<code>thread_info</code>结构体里，用一个特别的标志变量中的一位来表示。</p>
<h3 id="用户抢占"><a href="#用户抢占" class="headerlink" title="用户抢占"></a>用户抢占</h3><p>用户抢占发生在一下情况：</p>
<ul>
<li>从系统调用返回用户空间时</li>
<li>从中断处理程序返回用户空间时</li>
</ul>
<p>总而言之，内核即将返回用户空间的时候，如果<code>need_resched</code>标志被置位，会导致<code>schedule()</code>被调用。</p>
<h3 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h3><p>大部分的Unix变体不支持内核抢占，调度程序没有办法在内核级的任务正在执行的时候重新调度——内核中的任务是以协作的方式调度的，不具备抢占性。</p>
<p>Linux在2.6版本的内核中，引入了内核抢占。只要重新调度是安全的，内核就可以在任何时候抢占正在执行的任务。它发生在：</p>
<ul>
<li>中断处理程序正在运行，并且返回内核空间之前。</li>
<li>内核代码再一次具有可抢占性的时候。</li>
<li>如果内核中的任务显示地调用<code>schedule()</code>。</li>
<li>如果内核中的任务阻塞(这也会导致调用<code>schedule()</code>)。</li>
</ul>
<h2 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a>实时调度策略</h2><p>Linux提供了两种实时调度策略：<code>SCHED_FIFO</code>和<code>SCHED_RR</code>。而普通的非实时的调度策略是<code>SCHED_NORMAL</code>。这些实时调度器并不被CFS管理，而是被一个特殊的实时调度器管理。</p>
<h2 id="与调度相关的系统调用"><a href="#与调度相关的系统调用" class="headerlink" title="与调度相关的系统调用"></a>与调度相关的系统调用</h2><p>主要通过C库提供的<code>nice()</code>和<code>sched_xxxx()</code>系列函数。基本都是和系统调用的简单对应。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2018/07/27/Linux/LKD_process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/07/27/Linux/LKD_process/" class="post-title-link" itemprop="url">《Linux内核设计与实现》读书笔记——进程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-07-27 13:15:31" itemprop="dateCreated datePublished" datetime="2018-07-27T13:15:31+00:00">2018-07-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>发现读书不记笔记还是不行，过两天就忘得差不多了…最近在看《Linux内核设计与实现》，决定记些笔记。我可能有讲错的地方，一切以书上的讲解以及<em>Linux 2.6.X</em>源码为准  （逃</p>
<hr>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程包括执行的代码，数据，打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间以及一个或多个执行线程。实际上，进程就是正在执行的程序代码的实时结果。</p>
<p>执行线程，简称线程，是进程中活动的独享。每个线程有一个独立的程序计数器、进程栈和一组进程寄存器。Linux对进程和线程并不特别区分，线程只不过是一种特殊的进程。调度的对象是线程。</p>
<p>熟悉Unix&#x2F;Linux系统编程的童鞋都知道，<code>fork()</code>函数通过复制一个已有的进程来创建一个全新的进程。然后可能会用<code>exec()</code>函数创建新的地址空间，然后把新的程序载入其中。最终通过<code>exit()</code>系统调用退出执行，并把占有的资源释放。父进程可以通过<code>wait4()</code>系统调用查询子进程是否终结。进程退出后被设置为僵死状态，直到父进程调用<code>wait()</code>或者<code>waitid()</code>为止。</p>
<p>需要注意的是，Linux上实现<code>fork()</code>是用的<code>clone()</code>系统调用。</p>
<h2 id="进程描述符及任务结构"><a href="#进程描述符及任务结构" class="headerlink" title="进程描述符及任务结构"></a>进程描述符及任务结构</h2><p>内核把进程的列表放在叫做 <code>task list</code> 的双向循环链表中。链表中的每个项目类型为 <code>task_struct</code>，称为进程描述符(process descriptor)的结构。进程描述符中包含一个具体进程的所有信息，包括：打开的文件、进程的地址空间、挂起的信号、进程的状态，还有其他的信息。</p>
<h3 id="分配进程描述符"><a href="#分配进程描述符" class="headerlink" title="分配进程描述符"></a>分配进程描述符</h3><p>Linux 通过 <code>slab</code> 分配器分配 <code>task_struct</code> 结构，能达到对象复用和缓存着色(cache coloring)的目的。在内核栈的栈底(当然，这是对于向下增长的栈来说)创建爱你一个新的结构 <code>struct thread_info</code>，</p>
<p>在X86上，<code>thread_info</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span>        <span class="comment">/* main task structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span> *<span class="title">exec_domain</span>;</span> <span class="comment">/* execution domain */</span></span><br><span class="line">    __u32 flags;                     <span class="comment">/* low level flags */</span></span><br><span class="line">    __u32 status;                    <span class="comment">/* thread synchronous flags */</span></span><br><span class="line">    __u32 cpu;                       <span class="comment">/* current CPU */</span></span><br><span class="line">    <span class="type">int</span> preempt_count;               <span class="comment">/* 0 =&gt; preemptable,</span></span><br><span class="line"><span class="comment">                                        &lt;0 =&gt; BUG */</span></span><br><span class="line">    <span class="type">mm_segment_t</span> addr_limit;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> <span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="type">void</span> __user *sysenter_return;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> previous_esp;      <span class="comment">/* ESP of the previous stack in</span></span><br><span class="line"><span class="comment">                                        case of nested (IRQ) stacks</span></span><br><span class="line"><span class="comment">                                     */</span></span><br><span class="line">    __u8 supervisor_stack[<span class="number">0</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> uaccess_err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct task_struct *task</code> 是指向该任务实际 <code>task_struct</code> 的指针。</p>
<h3 id="进程描述符的存放"><a href="#进程描述符的存放" class="headerlink" title="进程描述符的存放"></a>进程描述符的存放</h3><p>内核通过一个唯一的 <code>PID</code> 来标识每个进程。PID是一个数字，为 <code>pid_t</code> 类型。</p>
<p>在内核中，访问任务通常需要通过 <code>current</code> 宏获得指向其 <code>task_struct</code> 的指针。<code>current</code> 针对专门的硬件体系结构有不同的定义。在X86上，<code>current</code> 把栈指针的后13个有效位屏蔽掉，用来计算出 <code>thread_info</code> 的偏移。该操作是通过 <code>current_thread_info()</code> 函数来完成的。然后从得到的 <code>thread_info</code> 的 <code>task</code> 域中提取并返回 <code>task_struct</code> 的地址： <code>current_thread_info()-&gt;task</code>。</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>进程描述符中的 <code>state</code> 域描述了进程的当前状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Task state bitmask. NOTE! These bits are also</span></span><br><span class="line"><span class="comment"> * encoded in fs/proc/array.c: get_task_state().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We have two separate sets of flags: task-&gt;state</span></span><br><span class="line"><span class="comment"> * is about runnability, while task-&gt;exit_state are</span></span><br><span class="line"><span class="comment"> * about the task exiting. Confusing, but this way</span></span><br><span class="line"><span class="comment"> * modifying one set can&#x27;t modify the other one by</span></span><br><span class="line"><span class="comment"> * mistake.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING         0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_INTERRUPTIBLE   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_STOPPED       4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_TRACED        8</span></span><br><span class="line"><span class="comment">/* in tsk-&gt;exit_state */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_ZOMBIE         16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_DEAD           32</span></span><br><span class="line"><span class="comment">/* in tsk-&gt;state again */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_DEAD           64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKEKILL      128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKING        256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STATE_MAX     512</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>state</code>的状态有五个：</p>
<ul>
<li>TASK_RUNNING（运行）： 进程是可执行的。它正在执行，或者在运行队列中等待执行。</li>
<li>TASK_INTERRUPTIBLE（可中断）： 进程正在睡眠，也就是被阻塞，等待某些条件达成。一旦这些条件达成，内核就会把进程的状态设为运行。处于此状态的进程也会因为接收到信号而提前被唤醒并素食准备投入运行。</li>
<li>TASK_UNINTERRUPTIBLE（不可中断）：除了就算是接收信号也不会被唤醒或准备投入运行外，这个状态与可打断状态相同。</li>
<li>__TASK_STOPPED（停止）：进程停止执行。通常发生在接收到SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU等信号的时候。</li>
<li>__TASK_TRACED：被其他进程跟踪的进程。</li>
</ul>
<h3 id="设置当前进程状态"><a href="#设置当前进程状态" class="headerlink" title="设置当前进程状态"></a>设置当前进程状态</h3><p>一般通过 <code>set_task_state(task, state)</code> 这个函数。<code>set_current_state(state)</code> 和 <code>set_task_state(current, state)</code> 含义是等同的。</p>
<h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><p>可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行。当执行了系统调用或者出发了某个异常，它就陷入了内核空间。此时，我们称内核“代表进程执行”并处于进程上下文中。此时 <code>current</code> 宏是有效的。</p>
<h3 id="进程家族树"><a href="#进程家族树" class="headerlink" title="进程家族树"></a>进程家族树</h3><p>Linux中进程有明显的继承关系，所有的进程都是 PID 为 1 的 <code>init</code> 进程的后代。内核在启动的最后阶段启动 <code>init</code> 进程。该进程读取系统的初始化脚本(initscript)并执行其他的相关程序。</p>
<p>每个进程都有一个父进程，零个或多个子进程。每个 <code>task_struct</code> 都包含一个指向其父进程叫做 <code>parent</code> 的指针，还包含一个称为 <code>children</code> 的子进程链表。</p>
<p>对于当前进程，可以通过下面的代码获得其父进程的进程描述符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">my_parent</span> =</span> current-&gt;parent;</span><br></pre></td></tr></table></figure>

<p>同样，也可以按下面的方式依次访问子进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each(<span class="built_in">list</span>, &amp;current-&gt;children)</span><br><span class="line">&#123;</span><br><span class="line">    task = list_entry(<span class="built_in">list</span>, <span class="keyword">struct</span> task_struct, sibling);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>init</code> 进程的描述符是作为 <code>init_task</code> 静态分配的。向上遍历的方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="keyword">for</span> (task = current; task != &amp;init_task; task = task-&gt;parent)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>可以通过这个树型结构，从任何一个进程出发，查找任意指定的其他进程。但很多时候，只需要通过简单的遍历，因为任务队列本来就是一个双向的循环链表。</p>
<p>对于给定的进程，获取链表的下一个进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_entry(task-&gt;tasks.next, <span class="keyword">struct</span> task_struct, tasks)</span><br></pre></td></tr></table></figure>

<p>获取前一个进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_entry(task-&gt;tasks.prev, <span class="keyword">struct</span> task_struct, tasks)</span><br></pre></td></tr></table></figure>

<p><code>for_each_process(task)</code> 宏提供了依次访问整个任务队列的能力。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"></span><br><span class="line">for_each_process(task)</span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s[%d]\n&quot;</span>, task-&gt;comm, task-&gt;pid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>Unix 通过<code>fork()</code>拷贝当前进程创建一个子进程，然后通过<code>exec()</code>函数负责读取可执行文件并将其载入地址空间开始运行。</p>
<h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><p>Linux的<code>fork()</code>采用写时拷贝（copy-on-write）页实现。写时拷贝是一种推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父进程和子进程共享一个拷贝。只有在需要写入的时候，数据才会被复制。这种技术使得地址空间上页的拷贝被推迟到实际发生写入的时候才进行。<code>fork()</code>的实际开销就是赋值父进程的页表以及给子进程创建唯一的进程描述符。</p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p>Linux通过<code>clone()</code>系统调用实现<code>fork()</code>。这个调用通过一系列的参数标志来指明父子进程需要共享的资源。<code>fork()</code>、 <code>vfork()</code>、 <code>__clone()</code>库函数都根据各自需要的参数去调用<code>clone()</code>，然后由<code>clone()</code>去调用<code>do_fork()</code>。</p>
<p><code>do_fork()</code> 完成了创建进程中的大部分工作。该函数调用<code>copy_process()</code>函数，然后让进程开始运行。</p>
<p><code>copy_process()</code>完成的工作：</p>
<ul>
<li><p>调用<code>dup_task_struct()</code>为新进程创建一个内核栈、<code>thread_info</code>结构和<code>task_struct</code>。这些值与当前进程值相同。</p>
</li>
<li><p>检查并确保新创建子进程后，当前用户所拥有的进程数没有超出给它分配的资源的限制。</p>
</li>
<li><p>子进程着手使自己与父进程区别开来。<code>task_struct</code>内的许多成员都清0或者设置为初始值。大多数据仍然未修改。</p>
</li>
<li><p>子进程的状态被设置为<code>TASK_UNINTERRUPTIBLE</code>，以保证不会投入运行。</p>
</li>
<li><p>调用<code>copy_flags()</code>以更新<code>task_struct</code>的<code>flags</code>成员。</p>
</li>
<li><p>调用<code>alloc_pid</code>为新进程分配一个有效的PID。</p>
</li>
<li><p>根据传给<code>clone</code>的参数标志，<code>copy_process()</code>拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。</p>
</li>
<li><p>最后返回一个指向子进程的指针。</p>
</li>
</ul>
<p>回到<code>do_fork()</code>函数，如果<code>copy_process()</code>函数返回成功，新创建的子进程被唤醒并让其投入运行。</p>
<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h3><p>除了不拷贝父进程的页表项外，<code>vfork()</code>和<code>fork()</code>的功能相同。子进程作为父进程的一个单独的线程再它的地址空间里运行，父进程被阻塞，直到子进程退出或执行<code>exec()</code>。子进程不能向地址空间写入。由于<code>fork()</code>是写时复制并明确子进程先执行，所以<code>vfork()</code>的好处就只限于不拷贝父进程的页表项了。</p>
<h2 id="线程在Linux中的实现"><a href="#线程在Linux中的实现" class="headerlink" title="线程在Linux中的实现"></a>线程在Linux中的实现</h2><p>Linux从内核的角度讲，没有线程的概念。线程被视作一个与其他进程共享某些资源的的进程。每个线程都有一个属于自己的<code>task_struct</code>，所以在内核中，它看起来就像一个普通的进程，只是和其他task会共享某些资源，比如地址空间。</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>线程的创建和普通进程的创建类似，只不过在调用<code>clone()</code>的时候参数需要传递一些参数标志来指明需要共享的资源：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>新创建的task和他的父亲共享地址空间、文件系统资源、文件描述符和信号处理程序。换言之，新创建的task是父进程的一个线程。</p>
<p>对应的，<code>fork()</code>的实现是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(SIGCHLD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><code>vfork()</code>的实现是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VFORK | CLONE_VM | SIGCHLD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>内核经常需要在后台执行一些操作。这种任务可以通过内核线程(kernel thread)完成————独立运行在内核空间的标准进程。和普通进程的区别在于没有独立的地址空间。</p>
<h2 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h2><p>当一个进程结束时，内核会释放它占有的资源并给父进程发送信号。</p>
<p>进程的终止有可能是自身引起的，比如调用<code>exit()</code>系统调用，既可能显示调用，也可能隐式地从某个程序的主函数返回；也可能是被动地终结，比如进程接收到既不能处理又不能忽略的信号或异常。</p>
<p>大部分任务需要靠<code>do_exit()</code>来完成。至此进程不可运行，并处于<code>EIXT_ZOMBIE</code>退出状态，它所占有的所有内存就是内核栈、<code>thread_info</code>结构和<code>task_struct</code>结构。此时进程存在的唯一目的就是向它的父进程提供信息。父进程检索到信息或者通知内核那是无关的信息后，进程所持有的剩余内核被释放，归还给系统使用。</p>
<h3 id="删除进程描述符"><a href="#删除进程描述符" class="headerlink" title="删除进程描述符"></a>删除进程描述符</h3><p><code>wait()</code>这一族的函数都是通过唯一的一个系统调用<code>wait4()</code>来实现的。它的标准动作是挂起调用它的进程，直到其中一个子进程退出，此函数会返回该子进程的PID。</p>
<p>最终释放进程描述符时，<code>release_task()</code>会被调用：</p>
<ul>
<li>它调用<code>__exit_signal()</code>，该函数调用<code>__unhash_process()</code>,后者又调用<code>detach_pid()</code>从<code>pidhash</code>上删除该进程，同时从任务列表中删除该进程。</li>
<li><code>__exit_signal()</code>释放目前僵死进程所使用的所有剩余资源，并进行最终统计和记录。</li>
<li>如果这个进程是进程组最后一个进程，并且领头进程已经死亡，那么通知僵死的领头进程的父进程。</li>
<li>调用<code>put_task_struct()</code>释放掉进程内核栈和<code>thread_info</code>结构所占的页，并释放<code>task_struct</code>所占的slab高速缓存</li>
</ul>
<p>至此，进程描述符和所有的进程独享的资源就被全部释放掉了。</p>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父亲，否则这些子进程就变成了孤儿进程，在退出时永远处于僵死状态。解决方法就是给子进程在当前进程组内找一个线程作为父亲；如果不行，就让<code>init</code>做它们的父进程。在<code>do_exit()</code>会调用<code>exit_notify()</code>，该函数会调用<code>forget_original_parent()</code>，而后者会调用<code>find_new_reaper()</code>来执行寻找父进程。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2018/07/24/C/strange_INT_MIN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/07/24/C/strange_INT_MIN/" class="post-title-link" itemprop="url">扭曲的INT_MIN</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-07-24 13:15:31" itemprop="dateCreated datePublished" datetime="2018-07-24T13:15:31+00:00">2018-07-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这个问题是在CSAPP上看到的，详情可以看<a target="_blank" rel="noopener" href="http://101.96.10.63/csapp.cs.cmu.edu/public/waside/waside-tmin.pdf">这个</a>。</p>
<p>简单来说，问题就是：在用补码表示有符号整型的机器上，C语言中的整型的最大值和最小值的表示方法不同。接下来就以32位int为例子讲解这个问题。</p>
<p>int的最大值INT_MAX和int的最小值INT_MIN，是这么定义的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_MIN (-INT_MAX – 1)</span></span><br></pre></td></tr></table></figure>

<p>熟悉补码的童鞋应该都知道，32位的数据，能表示的最大的整数的位级表示是<code>0x7FFFFFFF</code>，即<code>2147483647</code>，最小的整数的位级表示是<code>0x80000000</code>，即<code>-2147483648</code>。那么是为什么不能直接<code>#define INT_MIN -2147483648</code>或者<code>#define INT_MIN 0x80000000</code>?</p>
<p>CSAPP上是这么来说的，我觉得总结的很好：</p>
<blockquote>
<p>不幸的是，补码表示的不对称性和C语言转换规则之间这种奇怪的交互，迫使我们使用奇怪的方式来写Tmin。虽然理解这个问题需要我们钻研C语言标准中一些隐晦的角落，但是它也能帮助我们理解整数数据类型和表示的一些细微之处。</p>
</blockquote>
<p>接下来以我自己的理解来阐述一下原因。</p>
<p>首先，C语言里有整数常量（<code>integer constant</code>），让整型数值直接在表达式中使用。比如说<code>int a = 10</code>这里出现的<code>10</code>，就是个整型常量。整型常量除了默认的十进制，可以在开头加<code>0</code>表示八进制，比如<code>010</code>就是表示的八进制数字<code>10</code>；还可以在开头加<code>0x</code>或者<code>0X</code>表示十六进制，比如说<code>0xFF</code>就表示十六进制数字<code>FF</code>。</p>
<p>而且<code>integer constant</code>可以添加后缀。可选的后缀有<code>u</code>或者<code>U</code>，<code>l</code>或者<code>L</code>，<code>ll</code>或者<code>LL</code>。带<code>u</code>和带<code>l</code>的后缀可以进行组合（而且不用分先后顺序）。于是这样就有了6种后缀方式：</p>
<ul>
<li>无后缀</li>
<li><code>u</code> 或者 <code>U</code></li>
<li><code>l</code> 或者 <code>L</code></li>
<li><code>ll</code> 或者 <code>LL</code></li>
<li>既有 <code>l/L</code>又有 <code>u/U</code></li>
<li>既有 <code>ll/LL</code> 又有 <code>u/U</code></li>
</ul>
<p><code>integer constant</code> 有自己的类型。而决定每个 <code>integer constant</code> 类型的规则有点复杂。上面提到的3种进制方式和6种后缀方式一共带来了18种组合，每个组合都会有一个由若干个整数类型组成的候选列表，会依次匹配，第一个能容纳这个数值的类型就是这个 <code>integer constant</code> 的类型。<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/integer_constant">完整的表格可以上cppreference上看</a>。</p>
<p>现在再来看<code>INT_MIN</code>。如果<code>#define INT_MIN -2147483648</code>，由于没有负整数常量，那么首先来判断<code>2147483648</code>的类型。它属于无后缀的十进制，从C99开始，候选列表为：</p>
<ul>
<li>int</li>
<li>long int</li>
<li>long long int</li>
</ul>
<p>而在int是32位补码表示的机器上，int最大为 <code>2147483647</code>， <code>2147483648</code>会被当成<code>long int</code>类型或者<code>long long int</code>类型，具体情况由 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/arithmetic_types">data models</a> 来定。总而言之，就无法用 <code>-2147483648</code> 来表示最小的int值了。</p>
<p><code>#define INT_MIN 0x80000000</code>也是类似的情况。首先来判断 <code>0x80000000</code>的类型。它属于无后缀的十六进制，候选列表为：</p>
<ul>
<li>int</li>
<li>unsigned int</li>
<li>long int</li>
<li>unsigned long int</li>
<li>unsigned long long int</li>
</ul>
<p>在 int 是32位补码表示的机器上，int最大为 <code>2147483647</code>，即 <code>0x7FFFFFFF</code>，小于 <code>0x80000000</code>。所以也不能用 int 来表示 <code>0x80000000</code>,自然就无法用 <code>0x80000000</code> 来表示最小的int值了。</p>
<p>在网上看到的一句话总结，我觉得说的挺有道理：虽然 <code>-2147483648</code> 这个数值能够用int类型来表示，但在C语言中却没法写出对应这个数值的int类型常量。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2018/05/25/x86/x86_address_defination/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/25/x86/x86_address_defination/" class="post-title-link" itemprop="url">x86体系结构中各种“地址”的概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-05-25 13:15:31" itemprop="dateCreated datePublished" datetime="2018-05-25T13:15:31+00:00">2018-05-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/x86/" itemprop="url" rel="index"><span itemprop="name">x86</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>之前看CSAPP的时候，看到虚拟地址和物理地址的概念，对CPU的内存映射、地址空间这些有了粗略的印象。后来看了些关于X86的体系结构的内容，感觉相关的概念还是复杂了很多，所以特地整理一下。 (再次证明CSAPP还是当成入门书来看比较合适 ((逃</p>
<hr>
<p>在具体介绍这些概念之前，还是简单的总结一下X86的实模式和保护模式在内存管理上的区别。</p>
<p>X86的实模式(real mode)始于当年的8086芯片。现在的X86芯片刚启动时也默认先进入实模式。保护模式内存管理比较简单，寻址就是 段地址 + 段内偏移。8086提供了四个16位段寄存器用于保存段地址，分别是CS，DS，ES，SS，段内偏移量也是16位。但是地址线却有20位，也就是说物理地址是20位。所以英特尔公司就设计了一种很巧妙的方法，计算物理地址的时候段基址左移4位，再和偏移地址相加，这就得到了20位的物理地址。</p>
<p>80286处理器首次提出了保护模式的概念，但本文说的保护模式是指IA-32的保护模式。保护模式提供的内存管理机制大概分成了两个部分：分段和分页。分段能够隔离单独的代码模块、数据模块和栈模块，让彼此互不干扰(地址空间分离)。分页提供了虚拟内存的机制，让程序的各个部分能够根据执行环境的需要被映射到物理内存。值得一提的是，分段不能关闭，但是分页是可关闭的。</p>
<p>但是对于几乎所有操作系统来说，其实并没有用到保护模式提供的分段机制。一般都是将所有内存当成一个段来处理，这就是所谓的平坦模式(flat mode)。</p>
<h2 id="物理地址-physical-address"><a href="#物理地址-physical-address" class="headerlink" title="物理地址 physical address"></a>物理地址 physical address</h2><p>物理地址的概念很好理解，就是物理内存真正的地址。CPU最终对于内存的访问就得通过给总线物理地址的信号。</p>
<p>在X86的保护模式下，得到物理地址的方法就是16位的<code>段基址</code>左移4位加上16位的 <code>段内偏移地址</code>，最终得到的就是20位物理地址。</p>
<p>在IA-32的保护模式下，物理地址也是类似的概念，但是扩充到了32位，寻址4GBytes。从Pentium Pro处理器开始，IA-32架构地址扩充到了 2^36 Gbytes。在开启分页的情况下，虚拟地址通过MMU和页表的映射后引发缺页中断或者直接得到物理地址。</p>
<h2 id="有效地址-effective-address"><a href="#有效地址-effective-address" class="headerlink" title="有效地址 effective address"></a>有效地址 effective address</h2><p>有效地址就是段内偏移地址，不论是实模式还是保护模式都是如此。</p>
<h2 id="逻辑地址-logical-address"><a href="#逻辑地址-logical-address" class="headerlink" title="逻辑地址 logical address"></a>逻辑地址 logical address</h2><p>在实模式下，逻辑地址包括16位段地址和16位偏移地址。</p>
<p>在保护模式下，逻辑地址包括16位的段选择子和32位的偏移地址。</p>
<p>至于段选择子是什么，我在英特尔手册上摘抄了一段：</p>
<blockquote>
<p>A segment selector is a 16-bit identifier for a segment (see Figure 3-6). It does not point directly to the segment,but instead points to the segment descriptor that defines the segment.</p>
</blockquote>
<p>简单来说，段选择子就是一个16位的索引，它不直接指向段，而是指向段描述符。每个段都需要一个段描述符，为了放这些段描述符，在内存中开辟了一些空间，构成一个段描述符表。</p>
<p>也不细讲了，再从手册上摘抄些资料看看凑合吧：</p>
<blockquote>
<p>A logical address consists of a segment selector and an offset. The segment selector is a unique identifier for a segment. Among other things it provides an offset into a descriptor table (such as the global descriptor table, GDT) to a data structure called a segment descriptor. Each segment has a segment descriptor, which specifies the size of the segment, the access rights and privilege level for the segment, the segment type, and the location of the first byte of the segment in the linear address space (called the base address of the segment). The offset part of the logical address is added to the base address for the segment to locate a byte within the segment. The base address plus the offset thus forms a linear address in the processor’s linear address space.</p>
</blockquote>
<h2 id="线性地址-linear-address"><a href="#线性地址-linear-address" class="headerlink" title="线性地址 linear address"></a>线性地址 linear address</h2><p>在保护模式下，处理器能把每个逻辑地址转换成一个线性地址。线性地址是32位。具体转换方式如下：</p>
<ul>
<li>通过段选择子中的偏移定位到 GDT 或者 LDT 中的段描述符，读进处理器。</li>
<li>检查段描述符中的各种标志位是否访问本段，然后确认32位的偏移是在段的限制内。</li>
<li>从段描述符中得到段的基址，然后和逻辑地址的32位的偏移相加，就得到了线性地址。</li>
</ul>
<p>如果没有开启分页，那这个线性地址就已经是物理地址。如果开启了分页，那得到的线性地址就是虚拟地址。</p>
<h2 id="虚拟地址-physical-address"><a href="#虚拟地址-physical-address" class="headerlink" title="虚拟地址 physical address"></a>虚拟地址 physical address</h2><p>从上面对线性地址的描述可以看到，如果开启了分页，那线性地址就是虚拟地址，CPU通过页表的映射可以得到物理地址。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2018/05/20/C++/C++_sfinae/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/20/C++/C++_sfinae/" class="post-title-link" itemprop="url">SFINAE概念的介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-05-20 13:15:31" itemprop="dateCreated datePublished" datetime="2018-05-20T13:15:31+00:00">2018-05-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>前段时间看 <code>std::unique_ptr</code> 的实现，发现里面用到了好多用到<code>std::enable_if</code> 的地方，查了下才知道这涉及到C++ 里 <em>SFINAE</em> 的规则，还有定义成员类型的时候也在注释里提到了利用 <em>SFINAE</em> ，所以特地查阅资料记录下。</p>
<h1 id="SFINAE-定义"><a href="#SFINAE-定义" class="headerlink" title="SFINAE 定义"></a>SFINAE 定义</h1><p><em>SFINAE</em> 表示 <em>Substitution Failure Is Not An Error</em> (替换失败不是错误)。这里的 <em>Substitution</em>　（替换）是个什么概念呢？</p>
<p>先来了解一下模板实参替换的概念：</p>
<blockquote>
<p>已指定、推导出或从默认模板实参获得所有模板实参时，函数参数列表中每次模板形参的使用都会被替换成对应的模板实参。</p>
</blockquote>
<blockquote>
<p>替换发生于:<br>-所有用于函数类型中的类型（包含返回类型和所有参数的类型）<br>-所有用于模板形参声明中的所有类型<br>-所有用于函数类型中的表达式<br>-所有用于模板形参声明中的表达式 </p>
</blockquote>
<p>（ps：后两种替换都是从C++11起）</p>
<p>听起来很拗口，总之就是模板形参会被替换成实参。</p>
<p>举个简单的例子就能懂了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">         <span class="keyword">typename</span> U = <span class="keyword">typename</span> T::type&gt;    <span class="comment">// 第二种替换</span></span><br><span class="line">T&amp;                                         <span class="comment">// 第一种替换</span></span><br><span class="line"><span class="built_in">fun</span>(T)                                     <span class="comment">// 第一种替换</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不替换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>粗略的了解了替换之后，就能明白 <em>SFINAE</em> 大概什么意思了：模板形参替换推导类型失败时，从重载集抛弃特化，而非导致编译失败。其实还是挺好理解的，举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                <span class="comment">// 重载版本1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">typename</span> T::type)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                <span class="comment">// 重载版本2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>&lt;test&gt;(<span class="number">0</span>);                   <span class="comment">// 调用1</span></span><br><span class="line">    <span class="built_in">fun</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>);                    <span class="comment">// 调用2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于调用1，它模板参数为test，替换就已经开始了。</p>
<ul>
<li>重载版本1，替换后它变成了类似 <code>void fun(int)</code>；</li>
<li>重载版本2，替换后它变成了类似 <code>void fun(test)</code>。</li>
</ul>
<p>两者都是在重载集中的。根据函数重载匹配规则，匹配到前者。可以看到，这里其实并没有用到 <em>SFINAE</em>。</p>
<p>对于调用2，它模板参数为int</p>
<ul>
<li><p>重载版本1， 替换后它变成了类似 <code>void fun(int::type)</code>，很显然，这个替换是failure（失败）。所以它从重载集被中删除。</p>
</li>
<li><p>重载版本2，替换后它变成了类似 <code>void fun(int)</code>。</p>
</li>
</ul>
<p>所以调用版本2。</p>
<p>说道底，<em>Substitution Failure</em> 的含义就是：替换的实参写入时，带来了无效(invalid)的类型或表达式(参考上面提到的替换的四种情况)为 ill-formed 。（就像上面例子里出现的类似 <code>int::type</code>）。我查了下C++标准草案，发现里面并没有提到 <em>SFINAE</em> 的概念，只提到了替换后的类型或表达式为无效的话，模板类型推导就失败了。而且标准还特地强调了，当且仅当替换后的无效(invalid)类型和表达式是在函数类型和它的模板类型参数的立即上下文(immediate context)时，才导致类型推断失败。如果替换后的类型或者表达式会引发副作用(实例化某模板特化、生成某隐式定义的成员函数等)的话，就认为它并不是在 immediate context 中，会引发程序为 ill-formed。所以说，我猜正是因为只是模板类型推断失败，就不会引发错误（error）。</p>
<p>上面这段说的很拗口，我也没办法。<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/language/sfinae">cppreference</a>和C++标准草案n上上说的也很拗口。而且cppreference上的描述还有很多奇怪的地方，一会而 Substitution Failure， 一会又冒出个 <em>SFINAE error</em> ，后来看了草案才知道 <em>SFINAE error</em> 就是让类型推断失败的情况。我把这段摘录下来，可以结合<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/language/sfinae">cppreference</a>上的描述一起看下：</p>
<blockquote>
<p>If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression is one that would be ill-formed, with a diagnostic required, if written using the substituted arguments. [ Note: If no diagnostic is required, the program is still ill-formed. Access checking is done as part of the substitution process. — end note ] Only invalid types and expressions in the immediate context of the function type and its template parameter types can result in a deduction failure. [ Note: The substitution into types and expressions can result in effects such as the instantiation of class template specializations and&#x2F;or function template specializations, the generation of implicitly-defined functions, etc. Such effects are not in the “immediate context” and can result in the program being ill-formed. — end note ]</p>
</blockquote>
<p>草案上还明确规定了什么情况下会让模板参数推断失败。<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/language/sfinae">cppreference</a>上也介绍了，只不过正如上面所提到的，说法改了下，变成了 <em>SFINAE error</em> 出现的情况。相当于是对于标准的提炼和总结。</p>
<p>最后再提一下，如果 SFINAE 完美工作，但最终还是匹配不到某个函数，那显然也会造成编译失败。</p>
<h1 id="SFINAE-应用例子"><a href="#SFINAE-应用例子" class="headerlink" title="SFINAE 应用例子"></a>SFINAE 应用例子</h1><h2 id="std-enable-if"><a href="#std-enable-if" class="headerlink" title="std::enable_if"></a>std::enable_if</h2><p>这差不多算是很经典的利用 SFINAE 的例子了。直接上源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Primary template.</span></span><br><span class="line"><span class="comment">/// Define a member typedef @c type only if a boolean constant is true.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span>, <span class="keyword">typename</span> _Tp = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> enable_if </span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial specialization for true.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">enable_if</span>&lt;<span class="literal">true</span>, _Tp&gt;</span><br><span class="line">&#123; <span class="keyword">typedef</span> _Tp type; &#125;;</span><br></pre></td></tr></table></figure>

<p>根据 SFINAE 规则，<code>std::enable_if&lt;true, someType&gt;</code>的时候，它提供了成员类型 <code>type</code>； <code>std::enable_if&lt;false, someType&gt;</code>的时候，它无成员类型 <code>type</code>。而且由于它有了个默认模板参数 <code>_TP = void</code>，所以 <code>std::enable_if&lt;true&gt;</code> 提供了成员类型 <code>type</code> 为 void，当然，<code>std::enable_if&lt;false&gt;</code> 仍然无类型成员 <code>type</code>。 </p>
<p><code>std::enable_if</code>对不同类型特性提供分离的函数重载与特化的便利方法。它可用作额外的函数参数、返回类型、或类模板或函数模板形参。来看个使用它的例子。<code>std::unique_ptr</code>所使用的默认的删除器 <code>std::default_delete</code>，它有一个重载版本的构造函数标准规定是这样的：从另一 <code>std::default_delete</code> 构造 <code>std::default_delete</code> 对象。此构造函数仅若 U* 可隐式转换为 T* 才参与重载决议。大概函数原型就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">default_delete&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">default_delete</span><span class="params">( <span class="type">const</span> default_delete&lt;U&gt;&amp; d )</span> <span class="keyword">noexcept</span></span>;     <span class="comment">//仅若 U* 可隐式转换为 T* 才参与重载决议。T是 default_delete 能删除的类型</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了 <code>std::enable_if</code>，再配合 <em>type_traits</em> 头文件提供的用于判断两种类型是否能转化的函数 <code>std::is_convertible</code>，完成这样的需求就很容易了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">default_delete &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> = </span><br><span class="line">        <span class="keyword">typename</span> std::enable_if&lt;std::is_convertible&lt;U*, T*&gt;::value&gt;::type&gt;</span><br><span class="line">    <span class="built_in">default_delete</span>(<span class="type">const</span> default_delete&lt;Up&gt;&amp;) <span class="keyword">noexcept</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>U*</code> 能够转化成 <code>T*</code> 的时候，<code>std::is_convertible&lt;U*, T*&gt;::value</code> 为 <code>true</code> ，<code>std::enable_if&lt;std::is_convertible&lt;U*, T*&gt;::value&gt;::type</code> 为void，模板参数能正常推断；反之，当 <code>U*</code> 不能够转化成 <code>T*</code> 的时候，<code>std::is_convertible&lt;U*, T*&gt;::value</code> 为 <code>false</code> ，<code>std::enable_if&lt;std::is_convertible&lt;U*, T*&gt;::value&gt;::type</code> 为 ill-formed 。模板参数推断失败，显然无法实例化这个函数，也无法加入重载集。达到了 <em>仅若 U</em> 可隐式转换为 T* 才参与重载决议* 的要求。</p>
<h2 id="确定-std-unique-ptr-成员类型-pointer"><a href="#确定-std-unique-ptr-成员类型-pointer" class="headerlink" title="确定 std::unique_ptr 成员类型 pointer"></a>确定 std::unique_ptr 成员类型 pointer</h2><p>这个也是阅读<code>std::unique_ptr</code>源码学习到的。感觉这个用法也很巧妙。首先需求是这样的，<code>std::unique_ptr</code> 有一个成员类型 pointer，若该类型存在则为 <code>std::remove_reference&lt;Deleter&gt;::type::pointer</code> （其中 Deleter 是unique_ptr 的第二个模板参数，用于表示删除器的类型），否则为 T* 。必须满足可空指针 (NullablePointer) 。</p>
<p>是这么实现的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter = default_delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Use SINFAE to determine whether std::remove_reference&lt;Deleter&gt;::type::pointer exits</span></span><br><span class="line">    <span class="keyword">class</span> _Pointer</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">using</span> _Del = <span class="keyword">typename</span> std::remove_reference&lt;Deleter&gt;::type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">        <span class="type">static</span> <span class="keyword">typename</span> U::pointer __test(<span class="keyword">typename</span> U::pointer*);       <span class="comment">// 重载版本1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">        <span class="type">static</span> T* __test(...);                                         <span class="comment">// 重载版本2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> type = <span class="keyword">decltype</span>(__test&lt;_Del&gt;(<span class="number">0</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _pointer::type pointer;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果<code>std::remove_reference&lt;Deleter&gt;::type</code>有类型成员 <code>pointer</code> ，<code>__test&lt;_Del&gt;(0)</code>优先调用重载版本1，从而 <code>decltype(__test&lt;_Del&gt;(0))</code> 为重载版本1的返回值，即<code>std::remove_reference&lt;Deleter&gt;::type::pointer</code>；否则，只能调用重载版本2，<code>decltype(__test&lt;_Del&gt;(0))</code> 为重载版本2的返回值，即<code>T*</code>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2018/04/22/C/do_while(0)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/22/C/do_while(0)/" class="post-title-link" itemprop="url">do{...}while(0)在宏定义中的应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-22 13:15:31" itemprop="dateCreated datePublished" datetime="2018-04-22T13:15:31+00:00">2018-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天在看linux内核中链表操作的接口的时候，碰到这样一个宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// INIT_LIST_HEAD宏用于运行时初始化链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_LIST_HEAD(ptr) do &#123; \</span></span><br><span class="line"><span class="meta">    (ptr)-&gt;next = (ptr); (ptr)-&gt;prev = (ptr); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>不太明白这里的<code>do&#123;...&#125;while(0)</code>是个什么操作，看起来似乎没有什么用——因为这里<code>while(0)</code>显然并没有起到循环的效果。后来查了下资料(<a target="_blank" rel="noopener" href="https://kernelnewbies.org/FAQ/DoWhile0">网址在这</a>)，才知道在Linux内核和其它一些著名的C库中有许多使用do{…}while(0)的宏定义，也大概明白了这么写的作用。</p>
<ul>
<li><p>第一个理由：空的 <em>statement</em> 会让编译器发出警告，所以会看到有些宏定义是这样的： <code>#define FOO do&#123; &#125;while(0)</code> 。（暂时没看到这样的宏 &#x3D; &#x3D;。  先记录一下</p>
</li>
<li><p>第二个理由：它提供了一个 block 用于声明局部变量。可能你会想到不使用 <code>do&#123;...&#125;while(0)</code> 而简单地使用一对大括号 <code>&#123;...&#125;</code> 。这样有缺陷，具体看下一条。</p>
</li>
<li><p>第三个理由：让你能够声明复杂的宏定义。想象一下一个宏定义如下：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FOO(x) \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;arg is %d\n&quot;</span>, x); \</span></span><br><span class="line"><span class="meta">        do_something_useful(x);</span></span><br></pre></td></tr></table></figure>

<p>  现在这么使用它：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (blah == <span class="number">2</span>)</span><br><span class="line">    FOO(blah);</span><br></pre></td></tr></table></figure>

<p>  宏本质上就是文本替换，所以它实际上：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (blah == <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg is %d\n&quot;</span>, blah);</span><br><span class="line">do_something_useful(blah);              <span class="comment">// 不论 blah为何止，都会执行这条</span></span><br></pre></td></tr></table></figure>

<p>  所以显然，这可能带来用于预期之外的效果。而如果用了 <code>do&#123;...&#125;while(0)</code> ，就会是这样的：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (blah == <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arg is %d\n&quot;</span>, blah);</span><br><span class="line">        do_something_useful(blah);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"><span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>  可能有人会想，既然需要一个 block ，那么加个大括号不就好了？好的，假如说有这样一个宏定义：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换两个值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> exch(x, y) &#123; int tmp; tmp = x; x = y; y = tmp; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &gt; y)</span><br><span class="line">    exch(x, y);            <span class="comment">// 看起来似乎没问题</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    do_something();</span><br></pre></td></tr></table></figure>

<p>  很显然，这个相当于这样：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br><span class="line">;                       <span class="comment">// 注意这里！！</span></span><br><span class="line"><span class="keyword">else</span>                    <span class="comment">// 语法错误</span></span><br><span class="line">    do_something();</span><br></pre></td></tr></table></figure>

<p>  问题就出现在那个 <code>;</code> 。当然，你可以选择当初写下 <code>each(x, y)</code> 的时候在这行末尾不加分号，但是(我觉得)这实在显得太奇怪了。</p>
<p>  用了 <code>do&#123;...&#125; while (0)</code> 就没有这个问题：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; y)</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        tmp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = tmp;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);           <span class="comment">// Ok</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    do_something();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总结：Linux和其它代码库里的宏都用 <code>do&#123;...&#125;while (0)</code> 来包围执行逻辑，因为它能确保宏的行为总是相同的，而不管在调用代码中使用了多少分号和大括号。</p>
<p>（一点吐槽：感觉就是给C语言的宏擦屁股的？还有就是 <code>if/else</code> 即使只有一条语句也加大括号真是个好习惯 &#x3D; &#x3D;。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2018/04/20/C++/effective_modern_cpp_4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/20/C++/effective_modern_cpp_4/" class="post-title-link" itemprop="url">Effective Modern C++读书笔记(四)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-20 13:15:31" itemprop="dateCreated datePublished" datetime="2018-04-20T13:15:31+00:00">2018-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h1><p>首先来明确一下三个概念：</p>
<ul>
<li><p>lambda 表达式只是一个表达式。它是源码的一部分。</p>
</li>
<li><p><em>closure</em> 是由lambda创造的运行期对象。根据捕获的模式，<em>closure</em> 持有被捕获对象的副本或者引用。</p>
</li>
<li><p><em>closure class</em> 是给 <em>closure</em> 实例化的。每个 <em>lambda</em> 会让编译器生成一个独一无二的 <em>closure class</em> 。<em>lambda</em> 内的声明将变成它 <em>closure class</em> 内的成员函数的可执行指令。</p>
</li>
</ul>
<hr>
<h2 id="Item-31"><a href="#Item-31" class="headerlink" title="Item 31"></a>Item 31</h2><ul>
<li><p>在C++11里有两种默认的捕获模式： <em>by-reference</em> 和 <em>by-value</em> 。默认的 <em>by-reference</em> 捕获可以导致空悬引用。比如说这个 <em>closure</em> (或者它的副本)比捕获的引用的对象的声明周期长。 (这也应该是处理引用本就应该小心的地方)。应该不使用默认捕获，捕获的时候添上引用的对象。这样可以让程序员注意到引用的对象，从而对它的生命周期有了考量。或者直接就通过传值来捕获。但如果传值的对象是 <em>raw pointer</em> ，那又得考虑是否会出现空悬指针的问题。</p>
</li>
<li><p>有种情况 <em>by-value</em> 捕获会造成意想不到的悬垂指针。看个例子：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt;&gt; filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> divisor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [=](<span class="type">int</span> value)&#123; <span class="keyword">return</span> value % divisor&#125; == <span class="number">0</span>; &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里看似 <em>by-value</em> 捕获了divisor，但是却并非如此。首先，divisor是类内 <em>non-static 数据成员</em> ，是不能被捕获的。但是这段代码却可以编译过。原因就在与 <em>this</em> 指针。类的 <em>non-static</em> 函数体中隐含了一个 <em>this</em> 指针，它是个纯右值(prvalue)表达式，表示调用这个函数的对象的地址。所以其实捕获的是 <em>this</em> 指针，而lambda表达式中的 <code>divisor</code> 其实也是 <code>this-&gt;divisor</code> 。</p>
<p>  所以既然是 <em>by-value</em> 捕获的 <em>this</em> 指针，那么就有可能出现空悬指针。为了避免这种情况，还是老实地在 <code>addFilters</code> 函数体内用一个 local 变量作为 <em>divisor</em> 的副本，然后 <em>by-value</em> 捕获这个副本。</p>
</li>
<li><p>还有就是要注意，静态存储周期的对象都是可以直接在lambda 表达式中使用的，而且<em>不能捕获</em> 。所以在lambda表达式中用默认 <em>by-value</em> 捕获，就会让人产生错觉。但实际上什么都没捕获。</p>
</li>
</ul>
<hr>
<h2 id="Item-32"><a href="#Item-32" class="headerlink" title="Item 32"></a>Item 32</h2><ul>
<li><p>C++14 提供了 <em>init capture</em> 这种新的捕获方式。具体来说就是在捕获列表中可以通过 <code>=</code> 的方式，等号左边是从 <em>lambda</em> 表达式生成的闭包类的数据成员，右边是表达式，用于初始化左边。可以明显看出，<code>=</code>左边和右边的作用域也不同。所以，通过这种语法，让“移动”捕获成为了可能，而非 C++11 那样只能传值和传引用捕获。</p>
</li>
<li><p>不过在C++11中也是可以模拟出“移动”捕获的。</p>
<ul>
<li><p>lambda 表达式可以看成定义一个函数类并构造它的对象。所以没有什么是直接定义一个类不能解决的。类中自然可以通过移动的方式初始化数据成员。</p>
</li>
<li><p>通过 <code>std::bind</code> 来模拟。可以看个例子：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line"><span class="comment">// In C++14</span></span><br><span class="line"><span class="keyword">auto</span> func = [data = std::<span class="built_in">move</span>(data)]()&#123; <span class="comment">/*uses of data*/</span> &#125;;</span><br><span class="line"><span class="comment">// 以下是等价的版本</span></span><br><span class="line"><span class="comment">// In C++11</span></span><br><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>(</span><br><span class="line">    [](<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; data)</span><br><span class="line">    &#123; <span class="comment">/*uses of data*/</span> &#125;,</span><br><span class="line">    std::<span class="built_in">move</span>(data)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>  <code>std::bind</code>构造的对象持有所有参数的副本。当参数是左值，就拷贝构造；当参数是右值，就移动构造。所以参数<code>data</code>通过移动构造传进了 bind 对象内(姑且称之为d)，然后每次调用 <code>func</code> 的 <code>operator()</code> 的时候，都会调用那个 <em>lambda</em> 表达式的 <code>operator()</code> 。而参数就是 bind 对象内的data对象的副本。由于 <em>lambda</em> 没有加 <code>multable</code>，闭包类内的 <code>operator()</code>是 <code>const</code> 限定的的。而 bind 对象的data的副本却不是const的。为了防止它被修改，所以参数加了<code>const</code>。但其实这样也可以：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func =</span><br><span class="line">    std::<span class="built_in">bind</span>(</span><br><span class="line">        [](std::vector&lt;<span class="type">double</span>&gt;&amp; data) <span class="keyword">mutable</span></span><br><span class="line">        &#123; <span class="comment">/* uses of data */</span> &#125;,</span><br><span class="line">        std::<span class="built_in">move</span>(data)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="Item-33"><a href="#Item-33" class="headerlink" title="Item 33"></a>Item 33</h2><p>C++14 引入了 <em>generic lambdas</em> 的特性。具体来说就是 <em>lambda</em> 表达式的参数列表的类型是 <code>auto</code> 。这个特性的实现也很直观：生成的闭包类的 <code>operator()</code> 函数是个模板。所以，随着来的 <em>universal reference</em> 和完美转发都可以实现了。完美转发的关键还是在对引用折叠和 <code>std::forward</code> 函数实现的理解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; param)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">func</span>(std::forward&lt;<span class="keyword">decltype</span>(param)&gt;(param));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp;... params)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">func</span>(std::forward&lt;<span class="keyword">decltype</span>(param)&gt;(params)...);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Item-34"><a href="#Item-34" class="headerlink" title="Item 34"></a>Item 34</h2><p>用 <em>lambda</em> 表达式与 <code>std::bind</code> 相比有些优势，如下：</p>
<ul>
<li><p><em>lambda</em> 表达式比较清晰。(这里书中给的代码有误，最后再详细讲)</p>
</li>
<li><p><em>lambda</em> 表达式内可以调用重载的函数，但是<code>std::bind</code>第一个参数是重载函数的话得明确调用的版本(通过<code>static_cast</code>)。而且由于使用的指针，还会减少它被内联优化的可能性。</p>
</li>
<li><p><code>std::bind</code> 默认是将参数拷贝的。想要保存参数的引用，必须要用<code>std::ref</code>。比如：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> compressRateB = std::<span class="built_in">bind</span>(compress, std::<span class="built_in">ref</span>(w), _1);       <span class="comment">// compressRateB acts as if it holds a reference to w, rather than a copy</span></span><br></pre></td></tr></table></figure>

<p>  这点就很不如 <em>lambda</em> 表达式直观。</p>
</li>
</ul>
<p>在 C++14 中，<em>lambda</em> 表达式已经十分优秀，再也没有使用 <code>std::bind</code> 的理由了。但是在 C++11 中，<code>std::bind</code> 在以下情况下还是很有用的：</p>
<ul>
<li><em>Move capture</em> 。C++11 <em>lambda</em> 表达式没有提供通过移动捕获的方式，但是能通过 <code>std::bind</code> 模拟出来。但 C++14 开始， <em>lambda</em> 表达式通过 <em>init capture</em> 已经能够实现这个。</li>
<li><em>Polymorphic function objects</em> 。<code>std::bind</code>绑定一个模板函数的时候，它能完美转发任何参数。但是 C++14 开始，<em>lambda</em> 表达式可以通过 <code>auto</code> 实现泛型。</li>
</ul>
<p>ps：这章里的代码竟然还有错误的地方，琢磨半天&#x3D; &#x3D;。 最后在 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/42207520/why-nested-bind-can-defer-evaluation-of-the-expression"><em>StackOverflow</em> 上查到了正确的写法</a>。</p>
<p>先还原一下问题的引入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;          <span class="comment">// needed for use of &quot;_1&quot;</span></span><br><span class="line"><span class="keyword">auto</span> setSoundL = [](Sound s) &#123;</span><br><span class="line">    <span class="built_in">setAlarm</span>(steady_clock::<span class="built_in">now</span>()) + <span class="number">1</span>h,</span><br><span class="line">             s,</span><br><span class="line">             <span class="number">30</span>s);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>(setAlarm,</span><br><span class="line">                           steady_clock::<span class="built_in">now</span>() + <span class="number">1</span>h,</span><br><span class="line">                           _1,</span><br><span class="line">                           <span class="number">30</span>s);</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>setSoundL</code> 和 <code>setSoundB</code> 看似完成相同的功能，但是实际上却并非如此。因为 在调用 <code>setSoundL</code> 时会调用<code>setAlarm</code>函数。显然，此时才会<code>now</code> 函数。而对于 <code>setSoundB</code> 来说，它在生成的时候就已经被调用了 <code>now()</code> 函数。然后每次调用它的时候，并不会再对 <code>now()</code> 调用。所以可以看到，在语义上双方已经不同了。解决方法也很简单，将后者对 <code>now</code> 函数的调用推迟到它自身被调用的时候。</p>
<p>书上给出的修改是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了一系列的 using</span></span><br><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>(setAlarm,</span><br><span class="line">                           std::<span class="built_in">bind</span>(std::plus&lt;&gt;(), steady_clock::<span class="built_in">now</span>(), <span class="number">1</span>h),       <span class="comment">// 在 C++14 中，标准操作模板的模板参数声明通常可以被省略。注意， C++ 11 并不支持这么写。</span></span><br><span class="line">                           <span class="number">30</span>s);</span><br></pre></td></tr></table></figure>

<p>但这显然也不能达成目标，<code>now</code> 函数还是会在 <code>setSoundB</code> 生成的时候就调用。不难想到，<code>std::bind</code>第一个参数，即可调用对象，是不会提前被调用的。所以应该这么改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了一系列的 using</span></span><br><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>(setAlarm,</span><br><span class="line">                           std::<span class="built_in">bind</span>(std::plus&lt;&gt;(), std::<span class="built_in">bind</span>(steady_clock::<span class="built_in">now</span>()), <span class="number">1</span>h),</span><br><span class="line">                           <span class="number">30</span>s);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2018/03/01/C++/effective_modern_cpp_3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/01/C++/effective_modern_cpp_3/" class="post-title-link" itemprop="url">Effective Modern C++读书笔记(三)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-03-01 13:15:31" itemprop="dateCreated datePublished" datetime="2018-03-01T13:15:31+00:00">2018-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="右值引用，移动语义和完美转发"><a href="#右值引用，移动语义和完美转发" class="headerlink" title="右值引用，移动语义和完美转发"></a>右值引用，移动语义和完美转发</h1><ul>
<li><p>*移动语义(Move semantics)*往往可以用来替代copy操作，减小开销。而且还要某些对象(比如<code>std::unique_ptr</code>, <code>std::futrue</code>, <code>std::thread</code>)只允许move，禁止copy。可是在某些情况下，它的开销并不一定比copy小。</p>
</li>
<li><p>*完美转发(Perfect forwarding)*可以让模板接受参数，然后转发给其它函数，保持参数的类型不变。在某些时候，它也并不是完美的。</p>
</li>
</ul>
<p>而*右值引用(Rvalue reference)*就是使上述两个看似不相干的特性连接起来的胶水。它是支撑着移动语义和完美转的潜在语言机制。</p>
<hr>
<h2 id="Item-23"><a href="#Item-23" class="headerlink" title="Item 23"></a>Item 23</h2><p><code>std::move</code>不移动任何东西。<code>std::forward</code>不转发任何东西。在运行期间，不产生可执行的代码，不产升任何字节。它们只是是执行类型转换的函数模板(function templates)。</p>
<h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><ul>
<li><p><code>std::mvoe</code>无条件地将它的参数转化成右值。可以看下一个接近标准库的简单实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  并且在c–14中，,<code>std::move</code>还能实现得更精炼：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  由于<code>std::move</code>只做了将参数转化成右值的工作，甚至有人建议将它的名字改成<code>ralue_cast</code>。当然，右值是可移动的，所以将<code>std::move</code>用于一个对象，可以告诉编译器这个对象是可被移动的。可能这就是命名为<code>std::move</code>的原因。</p>
</li>
<li><p><code>std::mvoe</code>并不一定真正能引发移动操作。举个例子：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="type">const</span> std::string text)</span></span></span><br><span class="line"><span class="function">    : value(std::move(text)) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  你可能预想<code>value(std::move(text))</code>讲引发<code>std::string</code>的移动构造函数。但是，这里却发生了copy。原因在于<code>text</code>是个const对象。<code>std::move</code>作用于const对象时，返回值是个const限定的右值。而std::string构造函数的签名却大概是如下这样的：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;                          <span class="comment">// typedef for std::basic_string&lt;char&gt;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::<span class="built_in">string</span>(<span class="type">const</span> string&amp; rhs);     <span class="comment">// copy ctor</span></span><br><span class="line">    std::<span class="built_in">string</span>(string&amp;&amp; rhs);          <span class="comment">// move ctor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...Other code</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  <code>const std::string</code>的右值不能传给<code>rvalue reference to a non-const std::string</code>(即不会调用移动构造函数)，却可以传给<code>lvalue-reference-to-const</code>(即会调用拷贝构造函数)。因为移动一个对象会改变它的某些值，所以c–不允许<code>const</code>对象传给可能会改变它们值的函数。</p>
<p>  所以，有两个教训：</p>
<ul>
<li>如果你想要移动某个对象，不要将它声明为const。否则实际将会引发copy操作。</li>
<li><code>std::move</code>不移动任何东西。它只是保证它转化的对象将会有资格被移动，即被转化成右值。</li>
</ul>
</li>
</ul>
<h3 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h3><ul>
<li><p><code>std::forward</code>的转化只在某些特定情况下工作。它最常用的场景是在<code>universal reference</code>作为参数的函数模板(function template)中，用于将参数传给另一个函数。比如说：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> Widget&amp; lvalArg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; rvalArg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndProcess</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(<span class="string">&quot;Calling &#x27;process&#x27;&quot;</span>, now);</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget W;</span><br><span class="line"><span class="built_in">logAndProcess</span>(w);               <span class="comment">// (1) call with lvalue</span></span><br><span class="line"><span class="built_in">logAndProcess</span>(std::<span class="built_in">move</span>(w));    <span class="comment">// (2) call with rvalue</span></span><br></pre></td></tr></table></figure>

<p>  试想一下，如果没有<code>std::forward</code>会如何。param会被推断成左值或者右值的引用(详情见第一章)。但是，无论如何，param本身都是一个左值，所以调用process的参数匹配的时候，都会调用参数是lvalue reference的重载版本。<em>我们需要一个机制，只有当传给<code>param</code>的对象是右值的时候，将<code>param</code>从rvalue reference(是左值)转换右值。</em>事实上，这就是上述提到的希望<code>std::forward</code>工作的特定情况。</p>
<p>  BTW，你可能会奇怪<code>std::forward</code>如何区分传给它的对象被初始化之前的类型。秘密就藏在模板参数T里面。后面Item 28会详细讲。</p>
<p>  事实上，某些时候，我们可以用<code>std::forward</code>来代替<code>std::move</code>：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs)</span><br><span class="line">    : <span class="built_in">s</span>(std::<span class="built_in">move</span>(rhs.s)) &#123; &#125;</span><br><span class="line"><span class="comment">// 等价于下面这么写</span></span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs)</span><br><span class="line">    : <span class="built_in">s</span>(std::forward&lt;std::string&gt;(rhs)) &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  注意到<code>std::forward</code>的模板参数是<code>std::string</code>,这可以让它的返回值是右值。但是这么写很不方便。所以还是用<code>std::move</code>来得好。</p>
</li>
</ul>
<hr>
<h2 id="Item-24"><a href="#Item-24" class="headerlink" title="Item 24"></a>Item 24</h2><ul>
<li><p><code>univsersialcv reference</code>可以绑定到任意类型，const或volatile限定的rvalue或lvalue。通常有两个运用的地方，并且都伴随着类型推断：</p>
<ul>
<li><p>模板中：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;          <span class="comment">// param is a universal reference</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>auto 表达式</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = val1;         <span class="comment">// var2 is a universal reference</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如果加了const，就会绑定到rvalue reference</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;           <span class="comment">// param is a rvalue reference</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在模板里看到<code>T&amp;&amp;</code>就以为是<code>universal reference</code>。比如在vector中：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);                 <span class="comment">// x is a reference to rvalue</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span>;     <span class="comment">// args are universial references</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++14的lambda表达式可以声明 <code>auto&amp;&amp;</code> 参数：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> timeFuncInvocation = </span><br><span class="line">    [](<span class="keyword">auto</span>&amp;&amp; func, <span class="keyword">auto</span>&amp;&amp;... params)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//start timer;</span></span><br><span class="line">        std::forward&lt;<span class="keyword">decltype</span>(func)&gt;(func)(</span><br><span class="line">            std::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params)...</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">//stop timer and record elapased time</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>universal reference</code>只是一层抽象，背后的原理是 <code>reference collapsing</code>(引用折叠)。</p>
</li>
</ul>
<hr>
<h2 id="Item-25"><a href="#Item-25" class="headerlink" title="Item 25"></a>Item 25</h2><ul>
<li><p>合理运用<code>universal reference</code>可以有许多好处。考虑下以下两端代码：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With universial reference</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name = std::forward&lt;T&gt;(newName);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ... Other codes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// With two override functions</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(std::string&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> = newName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ... Other codes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  前者就比后者好一些。首先，后者增加了源代码的编写以及要维护的代码量。其次，它可能更加低效。比如说：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.<span class="built_in">setname</span>(<span class="string">&quot;cyyzero&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  使用<code>universal reference</code>版本，那么它被转发给<code>std::string</code>,并且只调用 <code>std::string</code> 的一次赋值函数。而对于两个重载版本的<code>setName</code>，将会创建一个临时的<code>std::string</code>对象，然后临时对象移动，最后析构。Last but not least，对于后者不仅源代码体积膨胀和执行期的效率低下，而且它是一种可拓展性很差的设计。可能需要重载的数量会很多。</p>
</li>
<li><p>在某些情况下，你想要用绑定到 <em>rvalue reference</em> 或者 <em>universal reference</em> 的值多次，那么在最后一次才用<code>std::move</code>或者<code>std::forward</code>.</p>
</li>
<li><p>RVO， 即<code>return value optimization</code>，是指编译器对于返回值需要copy 的情况进行了优化，让copy避免。通常<em>当local对象和返回值类型相同，并且这个local对象被返回</em>，则会进行RVO优化。如果不符合消除拷贝的条件，返回值会被视为右值。所以对于<code>return std::move(ret);</code>这样试图对返回局部变量进行优化的情况，属于画蛇添足。它不会帮到编译器，还可能阻碍了优化(因为所返回对象的类型变成了rvalue reference)。</p>
</li>
<li><p>对于返回值是传值，但返回的对象是左值或者右值引用的情况，那么把 <code>std::move</code> 用在右值引用上， <code>std::forward</code> 用在 <em>universal reference</em> 上。</p>
</li>
</ul>
<hr>
<h2 id="Item-26"><a href="#Item-26" class="headerlink" title="Item 26"></a>Item 26</h2><ul>
<li><p>对参数是 <em>universal reference</em> 的模板函数的重载，将会导致几乎都只调用参数是 <em>universal reference</em> 的版本。</p>
</li>
<li><p>完美转发的构造函数一般会导致很多问题，因为对于参数是<code>non-const lvalue</code>的拷贝构造，和它的继承类调用它的拷贝或移动构造函数的时候，都会调用它。</p>
</li>
<li><p>总而言之，尽量别对参数是<em>universal reference</em>的函数重载。</p>
</li>
</ul>
<hr>
<h2 id="Item-27"><a href="#Item-27" class="headerlink" title="Item 27"></a>Item 27</h2><p>对于上述的问题，有一些办法可以解决。</p>
<ul>
<li><p>放弃重载。定义多个不同的函数。</p>
</li>
<li><p>通过<code>const T&amp;</code>传参数。缺陷就在于效率可能会降低（因为不能move）。但是有时候选择放弃效率带来代码的简单，不失为一种方案。</p>
</li>
<li><p>传值。这可能是反直觉的，因为传值意味着拷贝对象，很多时候都会带来很大的开销。但是知道需要拷贝的时候，就可以考虑传值，然后再将副本move。</p>
</li>
<li><p>用<em>Tag dispath</em>（标签分派）。函数A参数设置为<em>universal reference</em>，然后通过对参数类型的分类，分派给其他函数。举个例子：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; names;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">nameFromIdx</span><span class="params">(<span class="type">int</span> idx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(<span class="type">int</span> idx, std::true_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logAndAdd</span>(<span class="built_in">nameFromIdx</span>(idx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(T&amp;&amp; name, std::false_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrno::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logAndAddImpl</span>(</span><br><span class="line">        std::forward&lt;T&gt;(name), </span><br><span class="line">        std::is_integral&lt;<span class="keyword">typename</span> std::remove_referene&lt;T&gt;::type&gt;()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>约束接收universal reference作为参数的模板。这是后需要用到<code>std::enable_if</code>。它的工作原理基于SFINAE。配合type traits，可以出色地完成工作：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span></span><br><span class="line">    &lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if</span><br><span class="line">        &lt;</span><br><span class="line">            !std::is_base_of</span><br><span class="line">            &lt;</span><br><span class="line">                Person,</span><br><span class="line">                <span class="keyword">typename</span> std::decay&lt;T&gt;::type</span><br><span class="line">            &gt;::type</span><br><span class="line">            &amp;&amp;</span><br><span class="line">            !std::is_integeral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;::value</span><br><span class="line">        &gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="built_in">Person</span>(T&amp;&amp; t)</span><br><span class="line">        :<span class="built_in">name</span>(std::forward&lt;T&gt;(t)) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> Idx)</span><br><span class="line">        :<span class="built_in">name</span>(<span class="built_in">nameFromIdx</span>(Idx)) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  不太好理解的地方：<code>std::enable_if</code>,<code>std::is_base_of</code>,<code>std::decay</code>,<code>std::is_integeral</code>.</p>
</li>
<li><p>权衡。使用universal reference通常能减小开销，但是随之而来的也有许多劣势。一来有些参数不能玩么转发。二来有时候完美转发后的出错信息可读性差。比如说上面的例子，传给Person的参数不能构造<code>std::string</code>，此时的报错将很感人。所以最好用<code>static_assert</code>确定它时候符合要求。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span></span><br><span class="line">    &lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if</span><br><span class="line">        &lt;</span><br><span class="line">            !std::is_base_of</span><br><span class="line">            &lt;</span><br><span class="line">                Person,</span><br><span class="line">                <span class="keyword">typename</span> std::decay&lt;T&gt;::type</span><br><span class="line">            &gt;::type</span><br><span class="line">            &amp;&amp;</span><br><span class="line">            !std::is_integeral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;::value</span><br><span class="line">        &gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="built_in">Person</span>(T&amp;&amp; t)</span><br><span class="line">        :<span class="built_in">name</span>(std::forward&lt;T&gt;(t))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">static_assert</span></span><br><span class="line">            (</span><br><span class="line">                std::is_constructible&lt;std::string, T&gt;::value,</span><br><span class="line">                <span class="string">&quot;Parameter n can;t be usedd to construct a std::string&quot;</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="Item-28"><a href="#Item-28" class="headerlink" title="Item 28"></a>Item 28</h2><p>C++禁止声明引用的引用。但是编译器可能在特定上下文，以及模板实例化的时候遇到它们。这时候，引用折叠(<em>reference collapsing</em>)就派上用场了。引用折叠大概的规则就是：<em>如果有一个是左值引用，结果就是左值引用。否则(即都是右值引用)，结果为右值引用</em>。</p>
<ul>
<li>T&amp;&amp; &amp;&amp; &#x3D;&gt; T&amp;&amp;</li>
<li>T&amp;&amp; &amp;  &#x3D;&gt; T&amp;</li>
<li>T&amp; &amp;&amp;  &#x3D;&gt; T&amp;</li>
<li>T&amp; &amp;   &#x3D;&gt; T&amp;</li>
</ul>
<p>引用折叠主要在四种情况中出现：</p>
<ul>
<li><p>模板实例化。其实主要就是参数是<em>universal reference</em>的函数模板实例化的时候。<em>universal reference</em>配上<code>std::forward</code>，主要就是引用折叠的规则才使得完美转发成为可能。比如说有个完美转发的例子：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//std::forward的简单实现</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_refrence&lt;T&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">someFunc</span>(forward&lt;T&gt;(fParam));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回Widget对象的工厂函数</span></span><br><span class="line"><span class="function">Widget <span class="title">getWidget</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="built_in">f</span>(w);                <span class="comment">// 情况(1)</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="built_in">getWidget</span>());      <span class="comment">// 情况(2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  对于情况(1)，f函数和forward函数会被推断成这样：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp; &amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">someFunc</span>(forward&lt;Widget&amp;&gt;(fParam));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget&amp; &amp;&amp; <span class="title">forward</span><span class="params">(Widget &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  正是由于引用折叠的存在，它事实上是这样的：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">someFunc</span>(forward&lt;Widget&amp;&gt;(fParam));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget&amp; <span class="title">forward</span><span class="params">(Widget &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <em>函数返回左值引用，返回值是个左值</em>。所以 forward 返回值是 Widget 左值。于是完美转发成功。</p>
<p>  对于情况(2)， f 函数和 forward 函数会被推断成这样：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">someFunc</span>(forward&lt;Widget&gt;(fParam));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  *函数返回右值引用，返回值是 xvalue (一种右值)*。所以forward的返回值是 Widget 右值。完美转发也成功了。</p>
<p>  ps：一开始我对于在f函数体内somefunc函数匹配规则不太理解，不太理解引用作为参数模板怎么推断。后来查了下，<em>从函数调用推导模板参数 P 的时候，若 P 是引用类型，则用 P 所引用的类型推导</em>。那么一切问题都迎刃而解了。</p>
</li>
<li><p>auto类型推导的时候。这个也不难想到，因为 auto 推导规则和模板类型推导差不多(见 Item 3)。还是来看一些例子：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; wi = w;</span><br><span class="line"><span class="comment">// 等价于 Widget&amp; &amp;&amp; w1 = w;   =&gt;     Widget &amp;w1 = w;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; w2 = <span class="built_in">getWidget</span>();</span><br><span class="line"><span class="comment">// 等价于 Widget&amp;&amp; w2 = getWidget();</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><em>typedef</em> 和 <em>alias declarations</em>。在模板中声明等价类型的时候，也经常运用引用折叠。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;&amp; RvalueRefToT;     <span class="comment">// RvalueRefToT类型可能和预期的右值引用不太一样，由于T类型未知，如果发生引种折叠，它还可能是左值引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>decltype</em>。当使用<em>decltype</em>配合引用的时候，也可可能发生引用折叠。</p>
</li>
</ul>
<p>最后总结:<code>universal reference</code>能工作就是依靠两点，一是类型推导能区分左值和右值，二是引用折叠的作用。</p>
<hr>
<h2 id="Item-29"><a href="#Item-29" class="headerlink" title="Item 29"></a>Item 29</h2><ul>
<li><p>有时候，移动不一定比拷贝快。举个例子：</p>
<ul>
<li><code>std::array</code>。<code>std::array</code> 的数据不会存放在堆上，基本就是内置数组类型的简单封装。所以移动也是O(n)复杂度。</li>
<li>很多 <code>std::string</code> 的实现都采用了 *small string optimization(SSO)*。比较短的字符串可能不会在存在堆上。这样移动的话效率也不会比拷贝高。</li>
</ul>
</li>
<li><p>有些时候，为了保证老代码在C++98下的强异常安全，如果有移动操作但移动操作没有声明 <code>noexcept</code>，编译器也会选择采用拷贝操作。</p>
</li>
</ul>
<hr>
<h2 id="Item-30"><a href="#Item-30" class="headerlink" title="Item 30"></a>Item 30</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(T&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;T&gt;(params)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很简答的完美转发的例子。但是实际上，它有时候并非如“完美”。在以下情况中完美转发会失败：</p>
<ul>
<li>编译器无法推断类型。</li>
<li>推断的类型并非预期。这可能会造成编译失败，或者匹配重载函数的其他版本。</li>
</ul>
<p>当参数比较特殊的收就很容易出错。举一些例子：</p>
<ul>
<li><p><em>Branced initializers</em> 。假设 <em>f</em> 声明为如下：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);             <span class="comment">// Ok, 列表隐式转化为向量</span></span><br><span class="line"><span class="built_in">fwd</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);           <span class="comment">// 编译失败</span></span><br></pre></td></tr></table></figure>

<p>  这是因为如果直接调用 <em>f</em> ，编译器将会对实参和形参类型匹配，但必要的时候会进行隐式转化。而通过 <em>fwd</em> 调用的时候，标准规定不能推断表达式 <code>&#123;1,2,3&#125;</code> 的类型(<code>std::initializer_list</code> 是 “<em>non-deduced context</em>”)。只有fwd的参数被声明为 <code>std::initializer_list</code>的时候，才可以这么传参数。而 <code>auto</code> 就不受这个限制了，可以这么写：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> il = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">fwd</span>(il);              <span class="comment">// It works.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>0 或者 <em>NULL</em>。很可能会被腿短成int类型，而非空指针。所以用 <code>nullptr</code> 代替它们。</p>
</li>
<li><p>只有声明的 static const 成员变量。建议写上定义(不要重复初始化)。否则可能会在参数是引用的函数传参时链接失败。</p>
</li>
<li><p>重载函数的名字或者模板的名字。这通常对于 <em>f</em> 参数是函数指针的时候，给 <em>f</em> 传重载函数的函数名，编译器会选择签名相同函数传指针过去。而对于 <em>fwd</em> ，来说，如果给它的参数是重载函数或者模板的名字，就无法推断，编译出错。解决的办法就是先定义一个函数指针，然后再作为参数传递给 <em>fwd</em> 。</p>
</li>
<li><p>位域(<em>Bitfields</em>)。因为位域的成员是无法引用的，所以将它作为参数传递给 <em>fwd</em> 就会出问题。(原因在于位域的成员可能是任意的bit，比如说一个32位int类型的第3到第5个bit，这就无法寻址)。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2018/02/12/C++/effective_modern_cpp_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/12/C++/effective_modern_cpp_2/" class="post-title-link" itemprop="url">Effective Modern C++读书笔记(二)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-02-12 13:15:31" itemprop="dateCreated datePublished" datetime="2018-02-12T13:15:31+00:00">2018-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>首先，raw pointer有着诸多缺陷</p>
<ul>
<li>指向对象的不明确(单个对象or数组？)</li>
<li>析构方式的不明确(<code>delete</code>，<code>delete[]</code>还是一个特殊的析构机制，比如调用某个函数)</li>
<li>析构的时机、次数容易出错</li>
<li>容易出现dangling pointer</li>
</ul>
<p>所以，c++11有了智能指针。</p>
<hr>
<h2 id="Item-18"><a href="#Item-18" class="headerlink" title="Item 18"></a>Item 18</h2><ul>
<li><p>资源紧缺的机器上也可以用<code>std::unique_ptr</code>，因为当它使用默认或者stateless lambda作为删除器的时候，和raw pointer大小一样。而且对于很多操作(比如解引用)，它们执行相同的指令。</p>
</li>
<li><p><code>std::unique_ptr</code>体现了独占所有权(exclusive ownership)的语义。只能move，不能copy。</p>
</li>
<li><p>对于层级继承关系来说，可以用工厂函数返回<code>std::unique_ptr</code>。并且调用方可以用<code>std::shared_ptr</code>来接收工厂函数的返回值。</p>
</li>
<li><p><code>std::unique_ptr</code>有两种形式，一个是单独的对象(<code>std::unique_ptr&lt;T&gt;</code>)，另一个是数组(<code>std::unique_ptr&lt;T[]&gt;</code>)。不过对于后者来说，c++中已经有了足够多足够好的替代品(比如说<code>std::array</code>、<code>std::vector</code>、<code>std::string</code>)。最好在使用返回一个裸指针的C-like API的时候才使用std::unique_ptr&lt;T[]&gt;。</p>
</li>
</ul>
<hr>
<h2 id="Item-19"><a href="#Item-19" class="headerlink" title="Item 19"></a>Item 19</h2><ul>
<li><p><code>std::shared_ptr</code>性能影响:</p>
<ul>
<li>大小是raw pointer的两倍。因为还有一个指向control block的raw pointer。</li>
<li>引用计数的内存是动态分配的。</li>
<li>引用计数增加和减少是原子操作。可能会降低速度。</li>
<li>control block用到了虚函数。</li>
</ul>
</li>
<li><p><code>std::shared_ptr</code>的移动操作比拷贝操作快。因为移动操作会直接让源std::shared_ptr置null，这意味着旧的std::shared_ptr引用计数不用操作。</p>
</li>
<li><p>对于<code>std::unique_ptr</code>来说，删除器是它类型的一部分；而对于<code>std::shared_ptr</code>来说却不是。而且改变<code>std::shared_ptr</code>的删除器不会改变它的大小(因为分配在堆上)。</p>
</li>
<li><p>std::shared_ptr<T>包含两个部分：Ptr to T和Ptr to Control Block。</p>
<ul>
<li><p>Ptr to T指向Ｔ Object;</p>
</li>
<li><p>Ptr to Control Block指向：</p>
<ul>
<li>Reference Count</li>
<li>Weak Count</li>
<li>Other Data(e.g.,custon deleter,allocto,etc)</li>
</ul>
</li>
</ul>
</li>
<li><p>一些关于control block的规则：</p>
<ul>
<li><code>std::make_shared</code>总是会创建一个control block。</li>
<li>当一个<code>std::shared_ｐtr</code>用unique_ptr或者auto_ptr构造的时候，也会创建一个control block。</li>
<li>用一个raw pointer构造<code>std::shared_ptr</code>的时候，也会创建一个control block。</li>
</ul>
</li>
<li><p>基于以上的规则，用同一个raw pointer构造多个<code>std::shared_ptr</code>是未定义行为。会有多个control block，导致对象被多次析构。</p>
</li>
<li><p><code>std::shared_ptr</code>不同于<code>std::unique_ptr</code>，不能很好地工作于数组。没有<code>std::shared_ptr&lt;T[]&gt;</code>的版本。所以默认删除器用的<code>delete</code>，而且没有重载<code>oparetor[]</code>。而且对于单个对象，<code>std::shared_ptr</code>允许从派生类向基类的转化；当作用在数组上时，可能会有奇怪的行为。所以尽量用<code>std::array</code>或者<code>std::vector</code>代替build-in array。</p>
</li>
</ul>
<hr>
<h2 id="Item-20"><a href="#Item-20" class="headerlink" title="Item 20"></a>Item 20</h2><ul>
<li><p><code>std::weak_ptr</code>不能解引用。所以一般还得用<code>std::shared_ptr</code>。</p>
<ul>
<li><p>一种形式</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从前有一个wpw是std::weak_ptr</span></span><br><span class="line">std::shared_ptr&lt;Widget&gt; spw1 = wpw.<span class="built_in">lock</span>();  <span class="comment">//如果wpw悬垂，spw1是空指针。</span></span><br><span class="line"><span class="keyword">auto</span> spw2 = wpw.<span class="built_in">lock</span>();                     <span class="comment">//同上。</span></span><br><span class="line"><span class="comment">//其他操作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>另一种形式</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw3</span><span class="params">(wpw)</span></span>;  <span class="comment">//如果wpw悬垂，抛出std::bad_weak_ptr异常</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用<code>std::weak_ptr</code>的例子：</p>
<ul>
<li><p>由于某个类构造开销比较大，所以设计了cache factory function，将不同的对象构造并缓存，返回<code>std::shared_ptr</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">const</span> Widget&gt; <span class="title">fastLoadWidget</span><span class="params">(WidgetId id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> std::unordered_map&lt;WidgetID, std::weak_ptr&lt;<span class="type">const</span> Widget&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> objPtr = cache[id].<span class="built_in">lock</span>();     <span class="comment">//objPtr是指向缓存对象的std::shared_Ptr(当然，对象无缓存就是null了)</span></span><br><span class="line">    <span class="keyword">if</span> (!objPtr)</span><br><span class="line">    &#123;                                  <span class="comment">//如果没缓存，</span></span><br><span class="line">        objPtr = <span class="built_in">loadWidget</span>(id);       <span class="comment">//构造它</span></span><br><span class="line">        cache[id] = objPtr;            <span class="comment">//缓存它</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>观察者设计模式(Observer design pattern)中，subject(状态会变化的对象)通常有一个成员是指向observer(观察者，观察subject的变化)的指针。这个指针对于控制observer的生命周期不感兴趣(即不需要std::shared_ptr)，但是需要确定指向的observer是否已经被析构，所以用<code>std::weak_ptr</code>。</p>
</li>
<li><p>三个对象A，B，C。A和C通过std::shared_ptr指向B，即共享B的所有权。B需要有一个指针也指向A。有三个选择：</p>
<ul>
<li><em>Raw pointer</em>。如果A被析构，就悬垂了。</li>
<li><em>std::shared_ptr</em>。A和B都用std::shared_ptr指向对方，这个嵌套会导致A和B都不会被析构。</li>
<li><em>std::weak_ptr</em>。这是个最佳选择，不会有上述的问题。</li>
</ul>
<p>  ps：用std::weak_ptr阻止<code>std::shared_ptr</code>循环的方法不是很常见。对于有严格分层的数据机构，比如说树来说，子节点属于父节点，父节点析构，子节点也应该被析构。父节点指向子节点用<code>std::unique_ptr</code>，子节点指向父节点用raw pointer。因为子节点总是会随着父节点被析构，不会出现子节点指向的父节点悬垂的情况。</p>
</li>
</ul>
</li>
<li><p><code>std::weak_ptr</code>和<code>std::shared_ptr</code>大小相同。<code>std::weak_ptr</code>不参与对象的所有权，因此不会影响指向对象的reference count。</p>
</li>
</ul>
<hr>
<h2 id="Item-21"><a href="#Item-21" class="headerlink" title="Item 21"></a>Item 21</h2><ul>
<li><p>有三个make函数，作用都是完美转发参数然后构造某个对象，并让智能指针指向它。分别是</p>
<ul>
<li><p><code>std::make_unique</code>.c++14才加入了标准库。不过自己也可以写个类似很简单的实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">        std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Ts&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">        &#125;</span><br><span class="line">        ````</span><br><span class="line">    * `std::make_shared`。和`std::make_unique`大同小异。</span><br><span class="line">    * `std::allocate_shared`。和`std::make_shared`作用几乎相同。但是它的第一个参数是一个allocator对象。</span><br><span class="line"></span><br><span class="line">* 用make函数的好处</span><br><span class="line"></span><br><span class="line">    * 一是不用重复类型</span><br><span class="line"></span><br><span class="line">        ```<span class="function">cpp</span></span><br><span class="line"><span class="function">        <span class="keyword">auto</span> <span class="title">upw1</span><span class="params">(std::make_unique&lt;Widget&gt;())</span></span>;    <span class="comment">//with make func</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;Widget&gt; <span class="title">upw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>; <span class="comment">//without make func</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>而是异常安全。考虑以下这个代码：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从前有两个函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; spw, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">computePriority</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">computePriority</span>());</span><br></pre></td></tr></table></figure>

<p>  将会导致可能的内存泄露。因为上述最后一行代码的参数完成操作需要：</p>
<ul>
<li>new Widget，即一个Widget对象被创建在堆上。</li>
<li>std::shared_ptr<Widget>被构造。</li>
<li>computePriority必须执行一次。</li>
</ul>
<p>  构造<code>std::shared_ptr&lt;Widget&gt;</code>肯定会发生在<code>new Widget</code>之后，毕竟后者作为前者的参数。但是<code>computePriority</code>函数执行的时间不确定。编译器可能会让<code>computePriority</code>正好在<code>new Widget</code>之后被调用。如果在运行期间，<code>computePriority</code>函数抛出异常，那么就内存泄漏了。所以应该用make函数</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个函数同上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; spw, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">computePriority</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">make_shared</span>&lt;Widget&gt;(), computePriority);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>用make函数性能上也可能会更好。考虑一下代码</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br></pre></td></tr></table></figure>

<p>  它总共分配了两次空间。一次是<code>new Widget</code>，另一个是构造<code>std::shared_ptr&lt;Widget&gt;</code>时，分配cotrol block。</p>
<p>  而对于make函数</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = std::<span class="built_in">make_shared</span>&lt;Widget&gt;();</span><br></pre></td></tr></table></figure>

<p>  只需要申请一次空间。因为会一次分配能容纳Widget对象和control block大小之和的空间，然后在分别初始化它们。不仅如此，根据cpu cache局部性，以后缓存命中率还可能更高。</p>
</li>
<li><p>不过make函数也有一些局限性：</p>
<ul>
<li><p>不能指定删除器。而直接用智能指针的构造函数却可以。</p>
</li>
<li><p>当你小要用花括号作为对象构造函数的时候，不能用make函数。或者这么用：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create std::initalizer_list</span></span><br><span class="line"><span class="keyword">auto</span> initList = &#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="comment">//createstd::vector using std::initializer_list ctor</span></span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(initList);</span><br></pre></td></tr></table></figure>

<p>  对于<code>std::unique_ptr</code>，它的make函数有以上缺点。但是对于<code>std::shared_ptr</code>和它的make函数来说，还有另外两个缺点(都是极端情况</p>
</li>
<li><p>如果一个对象的类型有自定义版本的operator new和operator delete，那么使用make函数来创建他们通常是一个糟糕的想法。</p>
</li>
<li><p>上面也提到过，当使用make函数的时候，会一次分配能容纳Widget对象和control block大小之和的空间。而control block有reference count和weak count。只要weak count大于0，引用快就必须存在。那么显然，会有对象所占的内存无法及时释放的情况出现：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReallyBigType</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">auto</span> pBigObj = std::<span class="built_in">make_shared</span>&lt;ReallyBigType&gt;();      <span class="comment">//通过make_shared创建一个很大的对象</span></span><br><span class="line"></span><br><span class="line">...                                                    <span class="comment">//创建若干个指向此对象的std::shared_ptr和std::weak_ptr并使用它们</span></span><br><span class="line"></span><br><span class="line">...                                                    <span class="comment">//最后一个指向此对象的std::shared_ptr在这被销毁。但是std::weak_ptr仍然保持</span></span><br><span class="line"></span><br><span class="line">...                                                    <span class="comment">//在这期间，先前创建的大对象所占的内存仍然没有被回收</span></span><br><span class="line"></span><br><span class="line">...                                                    <span class="comment">//最后一个指向此对象的std::weak_ptr在这被销毁。对象和control所占的内存才被释放。</span></span><br></pre></td></tr></table></figure>

<p>  这种情形直接用new反而更好。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReallyBigType</span>&#123;...&#125;;                                       <span class="comment">//和之前一样</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;ReallyBigType&gt; <span class="title">pBigObj</span><span class="params">(<span class="keyword">new</span> ReallyBigType)</span></span>;      <span class="comment">//通过new创建一个很大的对象</span></span><br><span class="line"></span><br><span class="line">...                                                             <span class="comment">//和之前一样，创建若干个指向此对象的std::shared_ptr和std::weak_ptr并使用它们</span></span><br><span class="line"></span><br><span class="line">...                                                             <span class="comment">//最后一个指向此对象的std::shared_ptr在这被销毁。但是std::weak_ptr仍然保持。为对象分配的空间已经被释放</span></span><br><span class="line"></span><br><span class="line">...                                                             <span class="comment">//在这期间，只有control block的空间还没释放</span></span><br><span class="line"></span><br><span class="line">...                                                             <span class="comment">//最后一个指向此对象的std::weak_ptr在这被销毁。control block所占的内存才被释放。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="Item-22"><a href="#Item-22" class="headerlink" title="Item 22"></a>Item 22</h2><p><em>Pimpl(“pointer to implementation”) Idiom</em>是医用用来缩短编译时间的技术。用一个指向某个class(or struct)的指针来代替具体的成员对象。举个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in header &quot;widget.h&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;            <span class="comment">//Gadget是用户自定义的类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每次Gadget.h改变，都得重新编译。所以运用<code>Pimpl Idiom</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//still in header &quot;widget.h&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;   <span class="comment">// declare implementation struct</span></span><br><span class="line">    Impl *pImpl;   <span class="comment">// and pointer to it</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每次Gadget.h改变，Widget不受影响。<br>不过学了智能指针，你可能互相到把raw pointer换成std::unique_ptr。就想下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in &quot;widget.h&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in &quot;widget.cpp&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gadget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>()</span><br><span class="line">: <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>可能注意到了，由于用智能指针管理资源，似乎用编译器生成的析构函数就能正常工作了的样子。编译没问题。不过，当你写下<code>WIdget w;</code>，想要使用它的时候，却会编译出错。</p>
<p>问题出在试图析构w，生成代码的时候。此时，析构函数将会被调用。根据编译器生成特殊成员函数的规则(详情见Item 17)，编译器试图生成一个析构函数。这个生成的析构函数会调用plmpl(一个使用默认删除器的std::unique_ptr)的析构函数。在这个指针的析构函数中，将会直接用<code>delete</code>作用于一个raw pointer。要注意到，在这时，Impl还是个不完全类型。但是，由于在实现在实现作用，默认deleter通常会用c++11的static_assert来确保指针指向完整类型。所以当编译器生成析构函数的时候，它就碰到了一个失败的static_assert。</p>
<p>要解决这个问题也很简单，做到在析构的时候Impl是完整类型就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in file &quot;widget.h&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ~<span class="built_in">Widget</span>();                          <span class="comment">// 只声明</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in file &quot;widget.cpp&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gadget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123; </span><br><span class="line">    std::string name; </span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() </span><br><span class="line">: <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;())</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()                       <span class="comment">// ~Widget的定义</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要强调编译器生成的析构函数就可以工作(声明它的唯一理由就是为了在Widget的实现中生成)，你也可以这么干:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget::~<span class="built_in">Widget</span>() = <span class="keyword">default</span>;  <span class="comment">//same effect as above</span></span><br></pre></td></tr></table></figure>

<p>处于同样的考量，还能加上move和copy操作。完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in file &quot;widget.h&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ~<span class="built_in">Widget</span>();                          <span class="comment">// 只声明</span></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(Widget&amp;&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in file &quot;widget.cpp&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gadget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123; </span><br><span class="line">    std::string name; </span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() </span><br><span class="line">: <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;())</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>() = <span class="keyword">default</span>;</span><br><span class="line">Widget::<span class="built_in">Widget</span>(Widget&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">: <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;(*rhs.pImpl));</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    *pImpl = *rhs,pImpl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果Pimpl采用<code>std::unique_ptr</code>，即使编译器生成的函数能工作，也需要明确的把比声明和实现分开来。</p>
<p>但是如果采用<code>std::shared_ptr</code>，上述的建议就不需要了。直接用编译器生成的函数就能够工作。</p>
<p>造成不同的根本原因是它们支持custom deleter的不同方式。</p>
<ul>
<li>对于<code>std::unique_ptr</code>，deleter是类型的一部分，使得编译器能够生成更小的运行期数据结构和更快的运行期代码。这个带来的后果就是，当编译器生成特殊函数的时候，指向的类型必须完整。</li>
<li>对于<code>std::shared_ptr</code>，deleter不是类型的一部分，使得需要更大的运行期数据结构和更慢的代码。但是当编译器产生特殊函数的时候，指向的类型不需要是完整的。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://cyyzero.github.io/2018/02/12/C++/effective_modern_cpp_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yiyang Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/12/C++/effective_modern_cpp_1/" class="post-title-link" itemprop="url">Effective Modern C++读书笔记(一)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-02-12 12:15:31" itemprop="dateCreated datePublished" datetime="2018-02-12T12:15:31+00:00">2018-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-29 07:13:44" itemprop="dateModified" datetime="2023-10-29T07:13:44+00:00">2023-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ps:第一本看的英文原版…希望这个寒假能看完吧</p>
<h1 id="Item-1-5"><a href="#Item-1-5" class="headerlink" title="Item 1-5"></a>Item 1-5</h1><ul>
<li>（建议直接看书，个人认为很重要</li>
</ul>
<h1 id="Item-6"><a href="#Item-6" class="headerlink" title="Item 6"></a>Item 6</h1><ul>
<li>警惕<code>auto</code>被类型推导为某个意想不到的proxy class（ie. vector<bool>::operator[]）</li>
</ul>
<h1 id="Item-7"><a href="#Item-7" class="headerlink" title="Item 7"></a>Item 7</h1><ul>
<li><p>大括号可以用来完成uniform initialization，且不会发生隐式narrowing conversion.</p>
</li>
<li><p>一般来说，<code>Object o&#123;xxx&#125;;</code>会优先匹配参数是std::initializer_list的构造函数</p>
</li>
<li><p>类内非静态成员不能用()初始化</p>
</li>
<li><p><code>auto t = &#123;xxx&#125;;</code>, t类型被推断为std::initializer_list</p>
</li>
<li><p>一组对比</p>
<ul>
<li><code>Object o();</code> &#x3D;&gt; Error</li>
<li><code>Object o&#123;&#125;;</code> &#x3D;&gt; OK</li>
</ul>
</li>
<li><p>另一组对比</p>
<ul>
<li><code>Object o&#123;&#125;;</code>调用默认构造函数</li>
<li><code>Object o&#123; &#123;&#125;&#125;;</code>或者<code>Object o( &#123;&#125;);</code>调用参数为空的std::initializer_list的构造函数</li>
</ul>
</li>
</ul>
<h1 id="Item-8"><a href="#Item-8" class="headerlink" title="Item 8"></a>Item 8</h1><ul>
<li>0，NULL和nullptr三者，用nullptr表示空指针(之前单独总结过，不多说了)（逃</li>
</ul>
<h1 id="Item-9"><a href="#Item-9" class="headerlink" title="Item 9"></a>Item 9</h1><ul>
<li><p>With a alias template:</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                          <span class="comment">// MyAllocList&lt;T&gt;</span></span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;; <span class="comment">// is synonym for</span></span><br><span class="line">                                              <span class="comment">// std::list&lt;T,</span></span><br><span class="line">                                              <span class="comment">//     MyAlloc&lt;T&gt;&gt;</span></span><br><span class="line"></span><br><span class="line">MyAllocList&lt;Widget&gt; lw;                       <span class="comment">// client code</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">MyAllocList&lt;T&gt; list;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>And with a typedef:</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// MyAllocList&lt;T&gt;::type</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAllocList</span> &#123;</span><br><span class="line"><span class="comment">// is synonym for</span></span><br><span class="line"><span class="keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type; <span class="comment">// std::list&lt;T,</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//MyAlloc&lt;T&gt;&gt;</span></span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw;</span><br><span class="line"><span class="comment">// client code</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="comment">// Widget&lt;T&gt; contains</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// a MyAllocList&lt;T&gt;</span></span><br><span class="line"><span class="keyword">typename</span> MyAllocList&lt;T&gt;::type list;</span><br><span class="line"><span class="comment">// as a data member</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>c++14运用alias template的一点改进</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::remove_const&lt;T&gt;::type</span><br><span class="line">std::<span class="type">remove_const_t</span>&lt;T&gt;</span><br><span class="line"><span class="comment">// C++11: const T → T</span></span><br><span class="line"><span class="comment">// C++14 equivalent</span></span><br><span class="line">std::remove_reference&lt;T&gt;::type</span><br><span class="line">std::<span class="type">remove_reference_t</span>&lt;T&gt;</span><br><span class="line"><span class="comment">// C++11: T&amp;/T&amp;&amp; → T</span></span><br><span class="line"><span class="comment">// C++14 equivalent</span></span><br><span class="line">std::add_lvalue_reference&lt;T&gt;::type</span><br><span class="line"><span class="comment">// C++11: T → T&amp;</span></span><br><span class="line">std::<span class="type">add_lvalue_reference_t</span>&lt;T&gt;</span><br><span class="line"><span class="comment">// C++14 equivalent</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Item10"><a href="#Item10" class="headerlink" title="Item10"></a>Item10</h1><ul>
<li><p>一般来说，用scoped enums代替unscoped enums。</p>
<ul>
<li>scoped emums带来了namespace pollution。</li>
<li>unscoped enums的成员会隐式转化成整数类型。scoped enums则不会（但可以显式转化）。（这个带来了一点好处。见下</li>
</ul>
</li>
<li><p>tuple和unscoped enum搭配更佳， 免去记住所有参数序列。否则就得…</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">toUType</span><span class="params">(E enumerator)</span> noexecpt</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;<span class="built_in">toUType</span>(UserInFoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Item-11"><a href="#Item-11" class="headerlink" title="Item 11"></a>Item 11</h1><ul>
<li><p>c++11前常常将成员函数声明放在private区域而不实现，以防止编译器自动生成。现在有了<code>=delete</code></p>
</li>
<li><p><code>=delete</code>不光能用于成员函数。还能通过讲“重载函数”声明为<code>=delete</code>防止函数的参数被隐式转换。</p>
</li>
<li><p><code>=delete</code>还能用于阻止template instantiation。</p>
</li>
</ul>
<h1 id="Item-12"><a href="#Item-12" class="headerlink" title="Item 12"></a>Item 12</h1><ul>
<li><p>override虚函数的时候加上 <code>override</code>关键词。</p>
</li>
<li><p>member function reference qualifiers能区分<code>*this</code>的类别（类似于以前的const</p>
</li>
</ul>
<h1 id="Item-13"><a href="#Item-13" class="headerlink" title="Item 13"></a>Item 13</h1><ul>
<li><p>在c++98的时候，容器的非const对象无法直接获得const_iterator，一般通过强制转化，或者用绑定到一个reference-to-const。</p>
</li>
<li><p>在c++98，const_iterator不能用于在插入或者删除的函数指示位置。</p>
</li>
<li><p>c++11提供了<code>begin</code>和<code>end</code>函数（包括许多容器的成员函数和非成员函数的通用版本）。但是c++14才提供了（这里指的是non-member版本）<code>cbegin</code>, <code>cend</code>, <code>rbegin</code>, <code>rend</code>和<code>crend</code>。有个用c++11实现<code>cbegin</code>的例子。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">C</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cbegin</span><span class="params">(<span class="type">const</span> C&amp; container)</span>-&gt;<span class="title">decltype</span><span class="params">(std::begin(container))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">retrurn <span class="title">std::begin</span><span class="params">(container)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Item-14"><a href="#Item-14" class="headerlink" title="Item 14"></a>Item 14</h1><ul>
<li><p>exception-neutral函数(指这类函数：它本身不抛出异常，但是它调用的函数可能会抛出异常)不能加noexcept</p>
</li>
<li><p>典型地，move operations，swap，memory deallocation函数， destructor都默认noexcept</p>
</li>
</ul>
<h1 id="Item-15"><a href="#Item-15" class="headerlink" title="Item 15"></a>Item 15</h1><ul>
<li><p>constexpr对象是编译期常量。(不过准确的说，应该<code>translation</code>期间的常量，包括编译<code>compile</code>和链接<code>link</code>)</p>
</li>
<li><p>对于constexpr函数来说，有两种情况。这意味着不需要对运行期和编译期执行的函数进行重载</p>
<ul>
<li><p>如果所有参数都是编译期常量，函数将在编译期就得到结果。</p>
</li>
<li><p>当一个或多个参数不是编译期常量的时候，就和普通函数一样，在运行期执行。</p>
</li>
</ul>
</li>
<li><p>constexpr是函数接口的一部分，不能随意去除</p>
</li>
</ul>
<h1 id="Item-16"><a href="#Item-16" class="headerlink" title="Item 16"></a>Item 16</h1><ul>
<li>对于某个需要同步的对象来说，用std::atomic就够了。但是对于多个对象作为一个整体需要同步的时候，往往需要用到mutex。</li>
</ul>
<h1 id="Item-17"><a href="#Item-17" class="headerlink" title="Item 17"></a>Item 17</h1><ul>
<li><p>c++11开始，特殊成员函数有</p>
<ul>
<li>defualt constructor 默认构造函数</li>
<li>destructor 析构函数</li>
<li>copy constructor 拷贝构造函数</li>
<li>copy assignment operator 拷贝赋值函数</li>
<li>move constructor 移动构造函数</li>
<li>move assignment operator 移动赋值函数</li>
</ul>
</li>
<li><p>对于后两个移动操作有关的函数(构造和赋值)来说，编译器默认生成的版本的行为是对所有非static成员调用执行对应(构造或赋值)的移动操作。对于带有继承的类来说，还会对基类进行对应的移动操作。但是，遇到不支持移动操作的对象，所以会用copy来替代move操作。</p>
</li>
<li><p>完成上述操作的核心是将std::move用于相应的对象(即非static成员或者基类部分)，然后根据函数重载规则，会调用相应的copy和move函数。</p>
</li>
<li><p>这两个移动操作不是相互独立的。如果声明了其中一个，编译器将不会自动生成另一个。</p>
</li>
<li><p>声明了拷贝操作(拷贝构造函数和拷贝赋值函数),那么编译器将不会生成移动操作的版本。反之亦然。</p>
</li>
<li><p>c++98开始就有个<code>Rule of Three</code>，即析构函数，拷贝构造函数，拷贝赋值函数三者自定义了任意一个，那一般来说其他两个也得自定义，编译器生成的很可能是错误的行为。</p>
</li>
<li><p>总结：下面三个条件都成立，则移动操作将会被编译器生成：</p>
<ul>
<li>没有声明拷贝操作</li>
<li>没有声明移动操作</li>
<li>没有声明析构函数</li>
</ul>
</li>
<li><p>想让编译器生成可以显示地用<code>=default</code>。尽量别依赖编译器隐式生成的规则，一是能规避复杂规则带来的bug，二是让代码意图明显。</p>
</li>
<li><p>成员函数模板不会影响编译器生成这些特殊成员函数。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yiyang Chen</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/cyyzero" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"cyyzero","repo":"cyyzero.github.io","client_id":"1185801249b8bbce5127","client_secret":"fbbb24c3e0613419f2505f94baa921f61606bac1","admin_user":"cyyzero","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"c853ec00cc9d13bc22336b7d45d1416e"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
